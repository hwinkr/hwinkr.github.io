{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"레벨 3에서 얻은 것에 관하여 레벨 3 방학(8/26-9/2) 동안, 정말 푹 쉬었다. 레벨 4가 분명히 더 바빠질 것이고, 슬슬 취업 준비로 인해서 몇 배는 더 정신 없을 것이라는 생각이 들어서 일어나서 돌아다니는 시간보다 누워 있는 시간이 더 많다고 느낄 만큼 정말 푹 쉬었다. 그래도 레벨 3에 모모 서비스를 만들면서 내가 어떤 것들을 얻었는지 키워드…","fields":{"slug":"level-4-1week-retrospect"},"frontmatter":{"date":"September 11, 2024","title":"우아한테크코스 레벨4 1주차 돌아보기","tags":["회고","우아한테크코스"]},"rawMarkdownBody":"\n# 레벨 3에서 얻은 것에 관하여\n\n레벨 3 방학(8/26-9/2) 동안, 정말 푹 쉬었다. 레벨 4가 분명히 더 바빠질 것이고, 슬슬 취업 준비로 인해서 몇 배는 더 정신 없을 것이라는 생각이 들어서 일어나서 돌아다니는 시간보다 누워 있는 시간이 더 많다고 느낄 만큼 정말 푹 쉬었다. 그래도 레벨 3에 모모 서비스를 만들면서 내가 어떤 것들을 얻었는지 키워드라도 정리해 보는 시간을 가졌다.\n\n### 1. 약속 날짜 범위를 생성할 수 있는 캘린더 UI를 구현했다.\n\n캘린더 UI를 제공해서 날짜 범위를 선택할 수 있도록 했던 의도는 **사용자가 날짜를 쉽게 선택할 수 있도록 하기 위해서**라고 할 수 있겠다. 날짜를 직접 입력하는 것 보다, 달력을 보면서 날짜만 클릭하면 선택되도록 하는 것이 더 편할것이라고 생각했다.\n\n대부분의 숙박 서비스나 날짜를 선택해야 하는 서비스들은 모두 캘린더 UI를 활용하고 있는 것을 파악할 수 있었다. 라이브러리를 사용하지 않고, 레벨 2에서 배운 사고 방식을 활용해서 캘린더 UI를 하나의 작은 문제를 해결한다는 생각으로 구현했다. 이 후 스토리북 환경에서 팀원들이 UI를 확인할 수 있도록 했다.\n\nUT(Usability Test), 런칭데이에서 연속된 긴 날짜 범위를 선택해야 하는 경우 모든 날짜를 모두 클릭해야 하는 것이 조금 불편하다는 피드백이 있어 레벨 4에서 해당 피드백을 반영해 볼 생각이다.\n\n### 2. 약속 시간을 선택할 때, 데스크탑 & 모바일 환경 모두 드래그해서 시간을 선택할 수 있도록 했다.\n\n드래그를 통해서 시간을 선택할 수 있도록 하는 기능의 의도는 약속을 주최하는 사람, 약속에 참여하는 사람 모두 시간을 편하게 표시할 수 있도록 하기 위해서이다. 최대한 편하고 빠르게 시간을 선택하도록 하는 것이 우리 서비스가 해결해줘야 하는 문제였다. 시간을 선택하는 방법에 대해서 팀원들과 정말 많이 이야기를 나누었고, 드래그가 가장 적합한 해결 방법이라고 결론지었다.\n\n[레벨 3 해커톤](https://hwinkr.github.io/woowacourse-level-3-hackathon-retrospect/)을 했을때, 이 기능을 구현했다. 모모 서비스에서 가장 먼저 구현한 기능, 해커톤에서 밤을 새면서 구현했던 기능이라는 점에서 의미가 있는 기능인 것 같다.\n\n해당 기능 구현을 했을 때, 아쉬운 점은 테스트 코드를 작성해 보지 못했다는 것이다. 아직 해당 기능을 스토리북, RTL, Cypress 중 어느 도구를 활용해서 테스트하면 좋을지 결론내리지 못했다 :(\n\n### 3. 특정 시간을 선택한 사용자 목록을 툴팁 UI를 활용해서 보여주도록 했다.\n\n툴팁 UI를 제공하기로 결정한 기능의 의도는 다음과 같다. 모모(모두 쉽게 모이자, 모모!) 서비스는 약속 시간을 결정하는데 까지 오래 걸린다는 것을 문제를 해결하려 한다.\n\n- 즉, **약속 시간 의사 결정을 빠르게 하는 것을 도와주는 서비스**이다.\n- → 어떤 요소들이 빠르게 약속 시간을 결정하는데 도움을 줄 수 있을지에 대해 팀원들과 이야기를 나눴다.\n- → 약속 참여자들에게 약속 시간과 관련된 많은 정보들을 보여줄 수 있으면 사용자들은 빠르게 의사 결정을 할 수 있을 것이라는 가설을 세웠다.\n- → 해당 가설이 옳았는지 확인해 보기 위해서 약속 후보 시간의 범위 중 특정 시간을 클릭하거나(모바일), 마우스를 올리면(데스크탑) 해당 시간을 선택한 사용자들을 보여주는 기능을 제공해 보자는 의견이 나왔다.\n\n재공해 볼만한 가치가 있는 UI라 생각되어, 툴팁 UI를 구현했다. 한 번도 구현해 보지 않은 UI라 정말 많은 어려움을 겪었고, 구현 중간중간 버그도 많이 생겨서 구현하느라 정말 애를 많이 썼다. 구현한 후, 스토리북을 활용해서 팀원들에게 컴포넌트 사용법과 해당 컴포넌트의 기능에 대해서 소개했다.\n\n![](./assets/level4-1.png)\n\n런칭데이에 코치 솔라에게 하나의 시간 셀(30분)을 선택한 사용자들의 목록을 보여주는 것에서 시간의 범위로 보여주는 것으로 개선되면 더 사용성이 좋을 것 같다는 피드백을 받았다. 오…정말 좋은 피드백인 것 같지만 구현을 어떻게 해야할 지 감도 잡히지 않아서 반영 우선순위가 낮은 피드백으로 정리했다…😅\n\n### 4. 재사용할 수 있는 텍스트 컴포넌트를 만들었다.\n\nUT(usability test)를 진행한 후, 피드백 받은 내용들을 적용하기 위해서 피그마 디자인을 개선했다. 개선 후, 재사용할 수 있는 텍스트들이 많은 것 같아 재사용성이 있는 하나의 텍스트 컴포넌트를 만드는 과정을 경험했다. 블로그에서도 확인할 수 있다\n\n### 5. 프론트엔드 리소스 배포를 자동화했다.\n\n우테코를 시작하기 전에는 aws amplify를 사용했기 때문에 cd(continuos deploy) yml 파일을 생성할 필요 없었지만 모모 서비스를 만들 때는 aws s3, cloudfront를 사용해야 했다. 수동으로 배포하는 것에 불편함을 느껴 배포 자동화를 위한 스크립트를 작성하고, yml 파일 내부 코드들을 이해해 보는 시간을 가졌다.\n\n### 6. 웹팩을 활용해서 로컬에서 https로 실행할 수 있는 방법에 대해서 알게 되었다.\n\n사파리 환경에서 특정 기능을 테스트 하다 사파리 브라우저는 http 환경에서 클라이언트와 서버가 쿠키를 주고 받을 수 없다는 것을 알게 되었고, 쿠키를 주고 받기 위해서 웹팩을 활용해 로컬에서 https 환경을 만들 수 있는 방법에 대해서 학습하고 적용했다. 해당 내용은 정리중이다.\n\n### 7. 디스코드 + yml 파일을 활용해 작업 현황 알람 자동화를 진행했다.\n\n카톡으로 업무 현황을 공유하는 것보다는\n\n> 누군가 특정 작업을 다 하면 알람을 주는 것이 좋지 않을까?\n\n라는 생각이 들어 작업 현황을 빠르게 공유할 수 있도록 디스코드 웹 훅을 활용해서 알림 자동화 작업을 진행했다.\n\n하나의 서비스를 만들면서 개인적으로 느낀점도 기록해 본다.\n\n1. 서비스에서 **개발자체가 차지하는 영역**은 생각보다 작다.\n2. 일에서 **컴팩트**는 중요하다.\n3. 같은 개발을 하는 사람들이라도 생각은 정말 다양하고 다르다.\n4. 사용자는 개발자의 의도대로 사용하지 않는 경우가 더 많다.\n\n# 시간에 관하여\n\n방학 마지막 날, 유튜브 영상을 뭐 볼지 내리다가 해당 영상을 발견하게 되었고 홀린듯이 시청했다. 췌장암 판정을 받고 6개월 정도 남은 한 미국 대학 교수의 연설 영상이다. 이 교수는 시간에 대해서 이야기 하고 있다.\n\n- https://www.youtube.com/watch?v=y2a3lLjjTGI&t=10s\n\n영상에 나오는 교수는 삶이 180일 정도 남았다. 내 삶이 언제쯤 끝날지 아는 사람이 시간에 대해서 이야기를 하니 더 인상 깊었다.\n\n> _사람들은 돈에 대해서는 정말 꼼꼼하게 관리를 하지만, 시간에 대해서는 돈 만큼 관리하지 않는다._\n\n정말 공감되는 말이다. 무엇이든 미친듯이 꼼꼼하게 관리하면 너무 피곤해지고, 예민해진다. 돈과 시간에 대한 관리 또한 마찬가지일 것이다. 하지만, 돈에 비해 상대적으로 시간에 대해서 더 관대하게 관리한다는 것에 공감되는 이유는 무엇일까. 아마 대부분의 사람이 그렇게 살아가기 때문일 것이다. 시간의 가치는 돈의 가치보다 월등히 높고 내가 보낸 오늘은 다시는 돌아오지 않는다는 것을 알지만, 삶에 치이다보면 간과하기 쉬운 명제인 것 같다. 나도 그렇게 사는 듯하다. 시간보다는 돈을 더 꼼꼼하게 관리하려고 하는…? 가계부도 쓰지만 정작 내가 내 시간을 어떻게 쓰고 있는지에 대해서는 기록을 하지 않는다. 해당 영상에서 교수는\n\n> 내 1시간의 가치를 돈으로 환산한다면 과연 얼마가 될까?\n\n에 대해서 물어보기를 권장한다. 해당 영상은 `시간 관리` 에 대한 강의는 아니며, 그저 삶이 얼마남지 않은 사람의 인생 조언이다. 소중한 나의 시간을 더 효율적으로 사용하고, 더 많은 일을 해결함으로써 더 행복한 삶으로 나아갈 수 있는 방법에 대한 조언이다.\n\n인생에서 가장 큰 목표가 즐거움이 되어야 행복한 삶을 살게될 수 있다는 조언을 해준다.\n\n![](./assets/level4-2.png)\n\n> 즐겁지 않은 일을 굳이 왜 해야 할까요?\n\n에 대한 질문도 던진다. 레벨 1에서 공원과 면담했던 내용이 떠올랐다. 무엇이 됐든 그 일을 오래, 지속적으로 하려면 우선 즐거워야 한다는 것. 레벨 3에서는 확실히 즐거움을 잃어버렸기에 이렇게 살고 싶지는 않다는 생각을 하면서 캠퍼스에 출근을 한 날들이 많아졌다. 일상 속 즐거움도 잘 느끼지 못했고, 점점 예민해지고 있다는 것을 느꼈고 심지어 주변 사람들에게 화가 많아진 것 같다는 이야기도 들었다. 즐거움에 대한 조언을 잠시 잊고 살았다.\n\n다시 돌아와서, 해당 교수는 틀에 박힌 소리일 수도 있다고 하면서 다음 이야기를 꺼낸다.\n\n> 성공한 사람이 시간 관리를 잘 하는것이 아니라, 시간 관리를 잘 하는 사람이 성공한다.\n\n시간 관리를 잘 하기 위해서는 자기 자신을 잘 아는 것이 중요하다고 말한다. 어떤 집단에 속하게 되면, 분명 나보다 뛰어나다고 느껴지는 사람들이 많고 우테코에 와서도 많이 느끼고 있다. 그렇다면 내가 이 사람들이랑 함께하기 위해서 나는 어떤 것을 해야 하는지를 아는것이 중요하다.\n\n> ‘난 여기서 어떤 행동을 해서 내 가치를 끌어올릴 수 있을까?’\n\n에 대한 고민을 해보는 것이 중요하다. 시간 관리를 잘 하기 위해선 목표, 우선순위, 계획이 매우 중요하다고 말한다.\n\n## 목표\n\n내가 어떤 ‘일’을 한다고 할 때, 일을 하면서 가장 중요한 생각은\n\n> 내가 지금 이 일을 `왜` 하고 있는가?\n\n이다. 이 부분은 정말 간과하기 쉽다. 많은 선배 개발자, 테크 리드, 코치분들도 모두 특정 기능을 개발할 때 해당 기능을 만드는 이유와 의도에 대해서 굉장히 많이 강조를 하는데 실제로 개발을 하다보면 마감 기한과 트러블 슈팅들에 치여서 잊기 쉬운 질문이 되버린다. **왜 하는지도 모르면서 그저 투두 리스트를 채우지는 말자.**\n\n앞으로 특정 기능을 구현하거나 피그마에서 디자인을 하게 된다면\n\n- 왜 이 기능을 구현하는지? 해당 기능의 의도는 무엇인지?\n- 이 기능이 정말 중요한 기능인지? 사용자에게 서비스의 가치를 전달하는데 한 발짝 더 나아갈 수 있을지?\n- 왜 이 디자인을 하는지? 이 디자인으로 전달하려는 UI/UX는 무엇인지?\n\n에 대해서 스스로에게 물어보고 시작하자. **이 질문에 대해서 정답을 찾을 필요는 없다고 생각한다.** 정답은 실제 사용자에게 서비스를 만들어서 제공하기 전 까지는 **아무도 모른다.** 그럼에도 이 질문을 해보는 것이 중요한 이유는 **내가 인지를 하고 개발을 시작하는 것의 가치가 엄청나게 크기 때문**이다. 그리고 내가 하는 일, 만들어야 하는 기능, 디자인의 진짜 목표는 무엇인지와 이 일을 해냈을 때 나에게 어떤 도움이 되는지를 알고 시작하면 일을 하는 중간중간 내가 올바르게 하고 있는 것이 맞는가에 대한 의심을 하는 가능성이 줄어들게 될 것이다. 특히 스스로에 대한 의심이 많고 이유가 없으면 행동으로 옮기고 싶지 않아하는 나에게는 정말 중요한 질문이 될 것 같다.\n\n레벨 3에서는 이유를 잊은 채 개발하는 순간들이 많았다. 많이 잤다하면 4-5시간, 데모데이 전 날에는 2시간 정도, 서비스 런칭 날에는 40분 정도 밖에 자지 못했고 체력적으로 지친 것이 자연스럽게 나의 정신력에도 영향을 주게 되었다. 충분한 수면 시간을 확보한 후 다시 내가 좋아하는 사고 방식으로 개발을 시작해 보자 :)\n\n이유를 안다면 자연스럽게 목표는 따라오지 않을까? 😊\n\n목표와 관련된 이야기 말고도 시간 관리와 관련된 많은 이야기들을 해주신다. 계획을 세우는 방법, 우선 순위를 정하는 방법에 대해 조언해 주신다. 영상을 시청한 후 영상에서 전달하고자 하는 메시지를 **내 삶에 적용해볼 수 있는 것은 없을까**에 대해서 고민하고 액션 플랜을 세워봤다. 하루에 내가 시간을 어떻게 보내고 있는지에 대한 **시간 일지**를 작성해보는 것이다.\n\n## 시간 일지 작성해 보기\n\n내가 하루에 시간을 어떻게 보내고 있는지에 대한 **시간 일지**를 작성해 본다. (`시간을 어떻게 썼는지 알아가는 과정 === 나를 알아가는 과정`)\n\n- 점심을 먹고난 후, 오전에 무엇을 했는지\n- 저녁을 먹고난 후, 오후에 무엇을 했는지\n- 잠에 들기 전, 저녁에 무엇을 했는지\n\n결국, **유한한 나의 시간을 더욱 더 쓸모있게 사용하기 위한 노력**이라고 할 수 있겠다.\n\n![](./assets/level4-3.png)\n\n![](./assets/level4-4.png)\n\n노션 템플릿을 만들고 캠퍼스에 출근하면 **mm/dd 시간일지**를 제목으로 하는 페이지부터 생성했다. 보통 일기를 쓰면 자기 전에 작성하는데 너무 정신없는 날이라면 오늘 무슨일들이 일어났는지 조차 기억하기 어려워 하루를 돌아보기 힘들었던 적이 많았다. 오전, 오후, 저녁으로 구분된 내용을 채우면서 느낀 것은 얼마 지나지 않은 일에 대해 작성하는 것이기 때문에 정말 생생하게 기록을 할 수 있다는 것이다.\n\n좋은 인사이트를 주는 영상을 보고, 좋은 계획을 세운 것 같아 만족하며 작성중이다. 영상에서 교수님은 한 달에 한 번 자신의 영상을 시청할 것을 권장한다. 아이폰 **미리 알림** 앱을 사용해서 매달 1일 마다 해당 영상을 시청하고 내가 시간 관리를 지난 달 보다 잘 했는지를 생각해 볼 예정이다.\n\n# 다시 시작한 러닝\n\n4월달 쯤이였나, 햄스트링 부상을 겪은 날 달리다가 햄스트링이 찢어지는 고통이 느껴졌다. 쿠션이 없는 뉴발 993을 신고 달리다가 햄스트링이 크게 다친 후, 달리기가 무서워서 4개월 정도를 쉬었다 그 뒤로 달리는게 조금 무서워졌다. 그래서, 햄스트링 재활을 하기 위한 특별한 노력도 하지 않으며 그저 걷기를 반복했다. 잘못된 자세로 달리는 것이 정말 큰 문제라는 것을 깨달을 수 있었다.\n\n한동안 계속 달리지 못하다가 러닝화를 사고 난 후 다시 달리기 시작했다. 보통 누나와 함께 달리는데 내가 달리지 못한 사이에 누나는 정말 많이 성장해 있었다. 15KM을 5:30 페이스로 달리는…\n\n달리기에서 인생의 가치에 대해서 정말 많이 배울 수 있는 것 같다. 무언가를 꾸준하게 한다면 눈부신 성장은 가능하다. 2월달에 처음 같이 달리기 시작했을 때만 해도 누나는 항상 나의 뒤에 있었고, 중간에 지쳐서 걷는 날이 많았다. 하지만, 이제는 내가 누나 뒤에서 달리며 누나를 따라가지 못해 달리기를 중간에 멈추고 있다. 지금은 누나에게 오래 달리기 위한 자세를 추천 받고, 달리기를 잘 알려주시는 유튜버도 추천받고 있다.\n\n누나에게 배운 올바른 자세, 꾸준함으로 올해 안에 통증을 느끼지 않으면서 10KM을 달려보는 것을 목표로 세워본다!\n\n# 레벨4 OT\n\n레벨 4 개강 날, OT가 있었다. 레벨 4 생활 가이드, 학습 목표를 공유해 주셨다. OT 내용 중, 포비의\n\n> 다시, 어떻게 살 것인가?\n\n![](./assets/level4-5.png)\n\n라는 주제로 말씀해주신 부분이 인상깊었다.\n\n> 대량 생산의 시대가 끝나고 인공 지능 시대가 도래하고 있다. 어떻게 사는 삶이 경쟁력 있는 삶인가?\n\n위 질문에 대한 포비의 생각을 말씀해 주셨다. 협력, 소통, 비판적 사고, 자신만의 생각, 색깔, 개성, 그리고 소프트웨어에 대한 진정성 등 많은 키워드들이 나왔다. 나는 여기서 진정성이라는 단어에 이끌렸다.\n\n> 나는 어떤 부분에 진정성을 느끼면서 살아가고 있을까?\n\n에 대해서 생각해봤다. 가장 가까운 레벨 3에서 진정성이 드러난 순간들을 떠올려 봤다.\n\n- 우리 서비스가 해결하려고 하는 문제가 진짜로 해결할 필요성이 있는 문제인지 의심했던 순간\n  - 빙봉에게 내 고민을 말한 후, 빙봉과의 대화를 통해 내 의심을 덜어냈다.\n  - 의심을 덜어내니 자연스럽게 진심으로 모모 서비스를 만들어 가고 있다는 것을 느꼈다.\n- 비슷한 문제를 해결하려고 하는 다른 서비스들을 항상 브라우저 탭에 올려놓고, 시간이 날 때마다 참고도 하고 비교도 해봤던 순간\n- 해결하려고 하는 문제는 다르지만 우리가 제공해야 하는 기능들을 우선적으로 제공하고 있는 다른 서비스들을 항상 브라우저 탭에 올려놓고, 참고하려고 했던 순간\n- 팀 내부에서 **공유**가 잘 되지 않는 것 같아서 백로그 문화를 제안해 봤던 순간\n- 작업을 더 효율적으로 진행할 수 있도록 디스코드를 활용한 알람 자동화를 구축하려 했던 순간\n- 버튼의 위치나 사용자에게 전달하는 텍스트들에 대해서 고민했던 순간\n\n등등 생각보다 많은 부분에서 내 진정성이 드러났던 것 같다.\n\n레벨 4에서 나는 개발을 하면서, 살아가면서 어떤 부분에서 진성성이 드러나는지 알아보고 싶어 팀 내에서 진행하는 유강스(유연성 강화 스터디)에서 관련된 목표를 정했다.\n\n![](./assets/level4-6.png)\n![](./assets/level4-7.png)\n\n그리고 포비는 위 이미지의 질문들에 답 해보는 것도 중요하다고 말씀해 주셨다. 정말 답하기 어려운 질문이지만, 답을 해야만 하는 질문이기도 하다. 개발자로 살아가지 않더라도 3, 4 번째 질문은 고민해봐야 하는 질문이다. 어쩌면 저 질문에 답을 하기 위해서 살아가고 있는 것이 아닌가 하는 생각이 들기도 한다.\n\n# 레벨4 첫 수업 : 프론트엔드 웹 성능 최적화\n\n프론트엔드 영역에서 할 수 있는 웹 성능 최적화를 주제로 레벨 4 첫 수업이 시작됐다. 수업에서 최적화와 관련된 정말 다양한 키워드들이 나왔다.\n\n- Lighthouse `95점` 이상\n- Home 페이지에서 불러오는 스크립트 리소스 크기 `< 60kb`\n- 히어로 이미지 크기 `< 120kb`\n- `프랑스 파리`에서 `Fast 3G` 환경으로 접속했을 때 Home 두 번째 이후 로드시 `LCP` < 1.2s\n  - `WebPageTest`에서 Paris - EC2 Chrome CPU 6x slowdown Network Fast 3G 환경 기준으로 확인\n- Chrome CPU 6x slowdown Network Fast 3G 환경에서 화면 버벅임 최소화\n  - `Dropped Frame` 없음. `Partially Presented Frame` 최소화.\n\n자 여기서 내가 아는 단어가 뭘까? Home…? ~~아는 단어가 Home 밖에 없어서 집에 가고 싶었다 ㅋㅋ~~\n\n수업이 끝난 후, 정말 멍했었다. 어디서 부터 어떻게 시작해야 성능을 최적화 할 수 있는 것인지 감도 잡히지 않았다. 캠퍼스를 돌아다니면서 다른 크루들의 반응을 살폈다.\n\n> 방금 뭐가 지나간거야…?\n\n다른 크루들의 반응도 비슷했다. 현재 만들고 있는 서비스에서 성능 최적화에 대한 필요성을 느껴서 시작한 작업이 아니라 미션을 위해서 성능 최적화를 해야 한다는 것도 어려움이 느껴진 부분 중 하나였다. 하지만, 나중에 언젠가는 서비스의 규모가 커질 때, 성능 최적화를 해야 할 필요성이 느껴졌을 때 어떤 부분을 개선할 수 있을지, 어떻게 개선할 수 있을지 파악하는 방법을 미리 한 번 배워본다는 느낌으로 미션을 진행하고자 했다. 실제로 이번 미션의 학습 목표이기도 했다.\n\n> _이 수치를 완벽히 맞추기 위한 미션이 아니라, 개선 방법들을 한번씩 직접 경험해보기 위한 미션이랍니다. 🙂_\n\n미션을 진행하면서 웹팩 공식문서를 정말 많이 읽었다. 기존에는 웹팩과 같은 번들러는 충돌 없이 효율적으로 모듈 시스템을 사용하도록 해주고 하나의 파일로 합쳐주는 기능을 제공해주는 이점 때문에 사용하는 것이라고 알고 있었다. 공식문서를 읽고\n\n- 요청 크기를 줄이기 위해서, js 파일의 크기를 줄이고 난독화\n- 요청 크기를 줄이기 위해서, css 파일의 크기를 줄이는 플러그인 제공\n- 프로덕션에서 필요하지 않은 의존성을 tree-shaking\n- 이미지 크기를 최적화할 수 있는 플러그인 제공\n\n등 성능 최적화를 위한 많은 기능을 웹팩에서 제공해주고 있다는 사실을 새롭게 알게되었다. 번들러 도구를 사용하는 이유를 더 다양한 관점에서 파악해볼 수 있는 의미있는 학습이었다. 추가로 HTTP Cache 개념과, CDN, Reflow를 발생시키는 css 속성과 그렇지 않은 css 속성을 비교해볼 수 있었다.\n\n미션을 시작할 때만 해도, 어떻게 미션을 진행할지 감이 전혀 잡히지 않았는데 나중에 할 수도 있는 일을 당황하지(?)않고 할 수 있도록 미리 배워본다는 느낌으로 미션을 대하니 많은 키워드들을 학습할 수 있었다. 미션을 진행했던 방법들은 나중에 한 번에 정리해놔야겠다.\n\n1주차 회고 끗~\n"},{"excerpt":"재사용할 수 있는 Text 컴포넌트를 만드는 여정 \n UT와 주변 크루들의 디자인 피드백을 받고나서 피그마 디자인 개선 작업을 진행했다. 개선하면서 사용자들에게 정보를 알려주는 텍스트들이 많아졌고 하나의 Text 컴포넌트를 잘 만들면 여러 상황에서 유연하게 재사용할 수 있을 것 같았다. 재사용할 수 있는 유연한 Text 컴포넌트를 만들기 위해서 인터페이스…","fields":{"slug":"reusable-text-component"},"frontmatter":{"date":"August 16, 2024","title":"재사용할 수 있는 Text 컴포넌트를 만들어 보자","tags":["React","모모"]},"rawMarkdownBody":"\n## 재사용할 수 있는 Text 컴포넌트를 만드는 여정\n\n![](./assets/figma-design-1.png)\n![](./assets/figma-design-2.png)\n\nUT와 주변 크루들의 디자인 피드백을 받고나서 피그마 디자인 개선 작업을 진행했다. 개선하면서 사용자들에게 정보를 알려주는 텍스트들이 많아졌고 하나의 Text 컴포넌트를 잘 만들면 여러 상황에서 유연하게 재사용할 수 있을 것 같았다. 재사용할 수 있는 유연한 Text 컴포넌트를 만들기 위해서 인터페이스를 설계하고 합성 컴포넌트 패턴까지 도입하게 된 흐름을 소개한다.\n\n모모 서비스에서는 약속과 관련된 정보를 알려주기 위한 텍스트가 많다. 여러 컴포넌트에서 공통적으로 쓰일 수 있는 Text 컴포넌트를 만들어두면, 재사용하기 좋고 따라서 작업 속도가 빨라지는 장점이 있을 것 같았다.\n\nText 컴포넌트를 구현하기 전, **UI 인터페이스부터 정의**했다\n\n## UI 인터페이스 설계\n\n### 1) Input\n\n- variant\n  - default : 가장 기본이 되는 텍스트이며, 검은색을 사용한다.\n  - caption : 사용자에게 추가적인 정보를 알려주기 위해 사용되는 텍스트이며, 회색을 사용한다. 약속을 생성하기 위해 정보를 입력할 때, 추가 정보를 주기 위해서 사용하거나 / 조회 페이지에서 추가 정보를 주기 위해서 사용할 수 있다.\n  - warning : 사용자에게 예외 피드백, 경고를 주기 위해서 사용되는 텍스트이며, 빨간색을 사용한다. 약속을 생성하기 위해 정보를 입력할 때, 잘못된 입력을 할 경우 예외 피드백을 주기 위해서 사용할 수 있다.\n  - accent : ‘**페드로**님 반가워요' 에서 ‘페드로’라는 단어를 강조할 때 사용되는 텍스트이며, 모모 서비스의 주 색상인 핑크색을 사용한다.\n- typo\n  - 디자인 토큰을 생성할 때, 만들었던 `TYPOGRAPHY`를 사용하며 titleBold, titileMedium,,,등 다양한 typo의 텍스트를 만들 수 있다.\n- chidren(React.ReactNode)\n\n  - 텍스트 컴포넌트를 사용해서, 사용자에게 전달할 메시지\n\n### 2) output\n\nText 컴포넌트 인터페이스의 output은 여러 상황에서 유연하게 그려지는 텍스트 UI라고 할 수 있다!\n\n## Text 컴포넌트에서 아이콘을 그려주는 책임을 줄지 말지에 대한 고민\n\n### 줄까?\n\n![](./assets/figma-design-2.png)\n\n`시간을 클릭하여 해당 시간에 참여할 수 있는 참여자들을 확인해 보세요` 메시지를 보여줄 때, `i` 아이콘을 함께 그려주고 있다. 우선 텍스트 컴포넌트에서 아이콘을 그려주는 책임도 함께 가지고 있으면 사용하기 편리할 것 같아서 인터페이스의 input(props)에 `leftContent` 를 추가했고, 타입은 `JSX.Element` 로 정의했다.\n\n```tsx\ninterface TextProps extends PropsWithChildren {\n  variant?: TextVariant\n  typo?: TextTypo\n  leftContent?: JSX.Element\n}\n\nexport default function Text({\n  variant = \"default\",\n  typo = \"bodyMedium\",\n  leftContent,\n  children,\n}: TextProps) {\n  return (\n    <span css={[s_baseTextStyle, s_textStyles({ variant, typo })]}>\n      {leftContent && leftContent}\n      {children}\n    </span>\n  )\n}\n```\n\n```tsx\nexport const CaptionWithIcon: Story = {\n  args: {\n    variant: \"caption\",\n    typo: \"captionLight\",\n    children:\n      \"시간을 클릭하여 해당 시간에 참여할 수 있는 참여자들을 확인해 보세요\",\n    leftContent: <InformationIcon />,\n  },\n}\n```\n\n`leftContent`가 있는 경우에 `props`로 넘겨주고 유연하게 **Text 컴포넌트를 재사용할 수 있도록 했다.**\n\n### `<span />` vs `<p />`\n\n아이콘이 있는 경우의 스토리인 `CaptionWithIcon` 을 스토리북에서 띄워보니 아이콘과 텍스트의 수직 정렬이 맞지 않는 문제가 생겼다. `CaptionWithIcon` 의 typo인 captionLight의 스타일은\n\n```js\nconst TYPOGRAPHY = {\n\t//...\n  captionLight: {\n    fontSize: '1.2rem',\n    fontWeight: FontWeight['light'],\n    lineHeight: '1.3',\n  },\n} as const;\n```\n\n위와 같다. font-size와 line-height의 관계는\n\n![](./assets/font-line-height.png)\n\n이미지 처럼 자연스럽게 수직 정렬된다.\n\n![](./assets/line-height-story.png)\n\n하지만 **아이콘의 경우 수직 정렬이 가운데로 되지 않았다.** 이 문제를 해결하기 위해, 기본 텍스트 스타일에 `display : flex`와 `align-items : center` 스타일을 추가해줬다.\n\n```js\nexport const s_baseTextStyle = css`\n  display: flex;\n  gap: 0.4rem;\n  align-items: center;\n`\n```\n\n![](./assets/text-flex-story.png)\n\n하지만 이렇게 하니, 폰트가 `line-height` 기준 가운데에 있지 않고 약간 위쪽으로 밀려나는 문제가 있어 아이콘과 텍스트의 수직 정렬이 여전히 맞지 않았다. 인라인 요소인 `<span />` 태그를 사용하는 것이 문제일까 싶어, 텍스트를 표현하는데 사용되는 블럭 요소인 `<p />` 태그를 사용해봐도 문제는 해결되지 않았다. 아이콘, 텍스트 모두 수직 정렬이 되지 않는 문제를 해결하기 위해서 정말 많은 삽질을 했지만 원인은 정말 허무하게도 폰트 문제였다.\n\n![](./assets/font-spoqa.png)\n![](./assets/font-pretendard.png)\n\n기존에 모모 서비스에서 사용하고 있던, `Spoqa Han Sans Neo` 폰트는 특정 `line-height`에서 텍스트가 가운데에 오지 않는 문제가 있지만, 혹시나 하고 어떤 폰트를 결정할지 고민할 때 2순위 폰트였던 `Pretendard` 폰트를 사용해보니 모든 `line-height`에 대해서 텍스트가 가운데에 잘 배치됐다. 폰트를 변경하는 것으로 아이콘, 텍스트가 수직 정렬이 되지 않는 문제가 허무하게 해결되었다.\n\n하지만, 이번 삽질을 통해서, `<span />`태그와 `<p />`태그를 비교하는 학습을 해볼 수 있었고 텍스트 컴포넌트를 만드는 만큼 `<p />` 태그를 사용하는 것으로 결정을 변경했다.\n\n```tsx\nexport default function Text({\n  variant = 'default',\n  typo = 'bodyMedium',\n  leftContent,\n  children,\n}: TextProps) {\n  return (\n    <p css={[s_baseTextStyle, s_textStyles({ variant, typo })]}>\n      {leftContent && leftContent}\n      {children}\n    </p>\n  );\n```\n\n### 말까?\n\n아이콘을 함께 보여주는 경우에도, Text 컴포넌트의 재사용할 수 있도록 하기 위해서 위해서 `leftContent` props를 추가했었다. 하지만 Text 컴포넌트는 말 그대로 **텍스트(글자)를 그려주기 위한 컴포넌트**라서 svg와 같은 asset들을 **Text 컴포넌트에서 함께 그려주는 것이 과연 옳은가에 대한 고민**을 하게 되었다. 아이콘과 텍스트를 함께 그릴 때, 수직 정렬이 맞지 않는 문제가 발생한 것도 폰트 문제이긴 했지만, 사실 묶을 필요가 없는 요소들을 억지로 한 컴포넌트에서 묶으려고 했기 때문에 생긴 문제가 아닐까하는 생각도 들었다. `<p />` 태그를 사용하는 만큼 Text 컴포넌트는 **글자만 유연하게 그릴 수 있도록 하는 책임을 가지도록 책임을 덜어주는 것으로 결정**했다.\n\n그리고, 기존에 아이콘과 텍스트를 함께 보여주기 위해서 작성했던 스타일 코드\n\n```js\nexport const s_baseTextStyle = css`\n  display: flex;\n  gap: 0.4rem;\n  align-items: center;\n`\n```\n\n에서 확인할 수 있듯, leftContnet와 텍스트 사이에 약간의 거리를 두기 위해서 `gap` 속성을 사용했다. 0.4rem으로 고정되어 있기 때문에 더 좁거나 넓은 거리가 필요한 경우에는 유연하게 재사용하지 못한다는 단점도 추가로 있었다. gap 또한 props로 받아서 처리할 수 있지만, 글자만 유연하게 그려주는 책임만 가지도록 결정을 변경한 것에 따라 gap 속성을 제거하기로 했다.\n\n```tsx\ninterface TextProps extends PropsWithChildren {\n  variant?: TextVariant\n  typo?: TextTypo\n}\n\nexport default function Text({\n  variant = \"default\",\n  typo = \"bodyMedium\",\n  children,\n}: TextProps) {\n  return <p css={s_textStyles({ variant, typo })}>{children}</p>\n}\n```\n\n아이콘 안녕~\n\n## Text 컴포넌트에 합성 컴포넌트 패턴 적용해 보기\n\n![](./assets/nak-code-review.png)\n\n```tsx\nexport const TitleText: Story = {\n  render: (args) => (\n    <div style={{ display: 'flex', alignItems: 'center' }}>\n      <Text {...args} variant=\"accent\" typo=\"titleMedium\">\n        모모 런칭데이 회식\n      </Text>\n      <Text {...args} typo=\"titleMedium\">\n        약속 참여자들이 선택한 시간대를 알려드릴게요\n      </Text>\n    </div>\n};\n```\n\nText 컴포넌트를 사용할 때, 강조해야하는 부분이 있으면 위 코드와 같이 Text 컴포넌트를 두 번 호출해야했다. 낙타가 합성 컴포넌트 패턴을 활용해서 한 번만 호출하는 방향으로 개선해보는 것을 제안했다.\n\n처음에는 위 스토리북 코드 처럼, 여러개의 `<p />`태그를 감싸는 상위 `<div />`태그가 있어야 한다고 생각했다. `<p />` 태그 내부에는 텍스트만 있어야 하며, 다른 태그가 있는 것은 안티 패턴이라고 생각했기에, 여러개의 `<p />`태그를 감싸는 `<div />`태그가 있어야 하지 않을까 생각했다. 그래서 합성 컴포넌트 패턴을 사용하는 것으로 개선하면, 사실 상 Text 컴포넌트가 아니라 TextWrapper 컴포넌트가 아닌가…하는 생각에 낙타의 제안을 받아들이지 않으려고 했었다.\n\n![](./assets/p-tag.png)\n\n<p /> 태그에 대해서 더 알아보니 단락(paragraph)를 나타낼 때 사용되는 태그이며 블록 레벨 요소이기 때문에 p 태그 안에 다른 인라인 요소를 넣는 것은 허용된다는 것을 알게되었다. 그래서 특정 텍스트를 강조할 때 사용되는 <strong /> 태그를 활용하여 기존 Text 컴포넌트의 구조를 합성 컴포넌트 구조로 변경하기로 했다.\n\n### 특정 글자의 색을 강조하는 Accent 컴포넌트\n\n```tsx\nimport type { PropsWithChildren } from \"react\"\n\nimport { s_accentTextStyle } from \"./Accent.styles\"\n\ninterface AccentProps extends PropsWithChildren {}\n\nexport default function Accent({ children }: AccentProps) {\n  return <strong css={s_accentTextStyle}>{children}</strong>\n}\n```\n\n처음, Text 컴포넌트를 구현할 때 설계했던 인터페이스의 `variants`에서 `accent`를 제거하고 특정 글자의 색을 모모 서비스의 색으로 강조해서 보여주는 책임을 가지는 Accent 컴포넌트를 추가로 구현했다.\n\n### 변경된 Text 컴포넌트 구조\n\n```tsx\nimport type { PropsWithChildren } from \"react\"\n\nimport Accent from \"./Accent\"\nimport { s_textStyles } from \"./Text.styles\"\nimport type { TextTypo, TextVariant } from \"./Text.types\"\n\ninterface TextProps extends PropsWithChildren {\n  variant?: TextVariant\n  typo?: TextTypo\n}\n\nexport default function Text({\n  variant = \"default\",\n  typo = \"bodyMedium\",\n  children,\n}: TextProps) {\n  return <p css={s_textStyles({ variant, typo })}>{children}</p>\n}\n\nText.Accent = Accent\n```\n\n### 변경된 Text 컴포넌트 사용 방법\n\n```tsx\nexport const TitleText: Story = {\n  render: (args) => (\n    <Text>\n      <Text.Accent>모모 런칭데이 회식</Text.Accent>약속 참여자들이 선택한 시간대를 알려드릴게요\n    </Text>\n};\n```\n\n훨씬 깔끔해진 것을 확인할 수 있다.\n\n## 느낀점\n\n정말 간단한 Text 컴포넌트를 만든 과정이지만\n\n> 직접 디자인을 하고 -> 디자인에서 공통적으로 묶을 수 있는 컴포넌트를 뽑고 -> 재사용성에 대해서 고민하고 -> `<span />`, `<p />` 태그 중 어느 것을 쓰는게 옳은지 고민 후 판단하고 -> 낙타 & 빙봉과 의견을 주고 받기\n\n이 순서대로 만들어가니 개인적인 학습, 팀 단위의 학습을 모두 챙길 수 있어서 좋았다. 특히 그냥 하기 보다는 필요에 의해서 고민하고 비교해 보니 더 뜻깊은 경험이 되었다.\n\n- [[FE] 재사용할 수 있는 탭 컴포넌트 구현](https://github.com/woowacourse-teams/2024-momo/pull/291)\n"},{"excerpt":"레벨 3 유강스, 처참히 실패하다. 지금까지의 유강스를 돌아봤을 때, 매우 성공적인 스터디였다고 감히 말할 수 있다. 일을 할 때 온/오프를 전혀 하지 못해 번아웃과 함께 살아왔던 나로써, 우아한테크코스에서 진행하는 유강스는 너무나도 소중한 스터디였다. 의식적으로 유강스 목표를 떠올리면서 개발과 일상을 구분하기 위한 노력들을 했었고, 정말 바쁘고 정신 없…","fields":{"slug":"woowacourse-level-3-writing"},"frontmatter":{"date":"August 16, 2024","title":"우아한테크코스 레벨3 글쓰기 미션","tags":["회고","우아한테크코스"]},"rawMarkdownBody":"\n## 레벨 3 유강스, 처참히 실패하다.\n\n지금까지의 유강스를 돌아봤을 때, **매우 성공적인 스터디였다**고 감히 말할 수 있다. 일을 할 때 온/오프를 전혀 하지 못해 번아웃과 함께 살아왔던 나로써, 우아한테크코스에서 진행하는 유강스는 너무나도 소중한 스터디였다. 의식적으로 유강스 목표를 떠올리면서 개발과 일상을 구분하기 위한 노력들을 했었고, 정말 바쁘고 정신 없는 우테코를 버틸 수 있게 해주는 버팀목이 되었다. 자연스럽게 레벨 3 유강스 목표를 정할 때, **구분**과 관련된 목표를 떠올렸다. **팀의 성장을 위해서 노력하는 시간, 개인의 성장을 위해서 노력하는 시간**을 잘 구분하는 것을 레벨 3 유강스 목표로 정했다. 결론부터 말하자면 레벨 3 유강스는 처참히 실패했다.\n\n## 내 개인 시간은 어디로...?\n\n레벨 3은 내가 상상했던 것 이상으로 바쁘고 정신없는 시간이었다. 팀 프로젝트를 진행하면서 실제 사용자들을 위한 서비스를 만드는 과정은 매일매일이 예상치 못한 도전들이었다. 그러다 보니 자연스럽게 개인의 시간은 레벨 1, 2에 비해 현저히 줄어들었다. 퇴근을 해도 게더에 모여 계속해서 모모 서비스를 만들었고, 데모데이가 있는 주에는 모든 팀원이 새벽 3-4시까지 기능을 완성하고, 버그를 수정했다. 처음에는 이런 상황을 적응하지 못했고, 유강스를 할 때에도 팀원들에게 나의 개인 시간이 점점 줄어드는 거 같다는 장난스러운 하소연도 했다. 지금 생각해보면 장난스러움을 빌려서 개인 시간이 진심으로 필요하다고 말하려고 했던 것 같다.\n\n하지만 3차 스프린트가 끝난 주말 내 걱정들을 조금 다른 시선으로 보게 되었다. 모모 서비스를 만들어가는 과정에서 예상치 못한 방식으로 내가 성장하고 있었던 것이다.\n\n## 팀의 성장이 곧 나의 성장\n\n팀과 우리가 만드는 서비스의 성장을 위해 노력하면서, 이전에는 전혀 해보지 못했던 경험들을 하게 되었다. 예를 들어,\n\n- 팀원들의 작업 공유를 위한 노션 백로그 템플릿을 만들고 제안했다.\n- PR, Issue, Code Review를 효율적으로 관리하기 위해 디스코드 알람 자동화 시스템을 구축했다.\n- 개발적으로는 처음 시도해보는 툴팁과 드래그 가능한 테이블 UI를 구현했다.\n\n이러한 경험들은 단순히 팀 프로젝트를 위한 것이었지만, 결과적으로 나의 기술적, 협업적 역량을 크게 향상시켰다. 팀의 필요에 맞춰 새로운 도전을 하면서, 나도 모르는 사이에 큰 성장을 이루고 있었던 것이다. 위와 같은 경험들과, 모모를 만들어가면서 느꼈던 작은 경험들을 기록하기 위해 TIL(Today I Learned)를 활용했다. TIL을 통해 모모 서비스를 만들어가는 과정 속에서 내가 어떤 부분에서 성장했는지, 몰랐는데 새롭게 알게된 내용은 무엇이었는지를 알게되었다. 생각보다 많은 부분에서 개인의 성장을 이루고 있었다.\n\n내 걱정에 대한 시선을 바꿨을 때, '구분'에 집중했던 내 목표가 잘못 설정되었다는 것을 깨달았다. **모모가 아니었다면 경험하지 못했을 개인의 성장을 경험하고 있었다.** 팀과 개인의 시간을 구분하려 노력하는 대신, 팀에 유연하게 동화되는 것을 목표로 잡는 것이 맞았을지도 모른다.\n\n## 유연함의 진정한 의미\n\n레벨 1,2에서 설정했던 유연성 강화 목표에서 '구분'은 나에게 도움이 되는 구분이었다. 반면 레벨 3에서 설정한 유연성 강화 목표에서 '구분'은 도움이 되지 않았던 구분이었다. 유강스 목표를 잘못 정하고, 걱정하다가, 시선을 바꿔서 걱정을 다르게 바라본 과정을 통해 나는 유연함의 진정한 의미를 깨달았다. 나에게 유연함은, 특히 레벨 3에서 필요했던 유연함은 단순히 시간을 구분하는 것이 아니라, 주어진 상황에 적응하고 그 안에서 성장 기회를 찾는 능력이었다. 팀 프로젝트에 몰입하면서 나는 개인적으로 정말 많이 성장했고, 팀의 성장을 위한 시간과 개인의 성장을 위한 시간을 분리할 필요가 없을지도 모른다는 것을 이해하게 되었다.\n\n결과적으로, 내가 처음에 '실패'라고 생각했던 레벨 3 유강스는 오히려 가장 큰 성공이었다. 나는 팀과 함께 호흡하면서, 더 넓은 시야와 다양한 경험을 얻을 수 있었고, 이는 단순히 '개인 시간'을 가졌을 때보다 훨씬 값진 성장이었다.\n\n## 새로운 시작\n\n이제 나는 '구분'이 아닌 '조화'에 초점을 맞추려 한다. 팀의 성장와 개인의 성장이 서로 구분되어야 하는 것이 아니라, 조화를 이루며 함께 성장할 수 있다는 것을 배웠다. 앞으로의 프로젝트와 협업에서도 이러한 마음가짐을 가지고 임할 것이다.\n유연함은 결국 변화하는 환경에 적응하고, 그 안에서 기회를 발견하는 능력이다. 레벨 3의 경험을 통해, 나는 진정한 유연함을 배웠고, 이는 앞으로의 나에게 정말 큰 자산이 될 것이다.\n\n**팀의 성장은 곧 나의 성장이다.** 이 깨달음은 단순한 프로젝트 경험을 넘어, 앞으로의 삶의 방식에도 큰 영향을 미칠 것이다. 레벨 3에서 나에게 진정으로 필요했던 유연함을 알게된 과정들을 통해 나는 팀과 개인의 의미를 넓은 시야로 볼 수 있게 되었고, 더 큰 성장의 기회를 발견하게 되었다. 이제 나는 자신 있게 말할 수 있다. 레벨 3 유강스는 실패가 아닌, 새로운 시작이었다고.\n"},{"excerpt":"배경 모모 서비스를 만들면서 구현하고 사용중이었던 캘린더 UI를 UT(Usability Test)가 끝난 후, 같이 학습을 하는 크루들에게 피드백을 받은 후 개선하면서 했던 고민들과 해결 과정들을 기록한다...! 기존 캘린더 UI  기존 캘린더 UI에서 개선했으면 하는 사항들 모바일에서 선택된 날짜가 계란처럼 보이는 문제 해결  모모 서비스에서 약속을 만…","fields":{"slug":"improvement-calendar-ui"},"frontmatter":{"date":"August 14, 2024","title":"[TIL] 캘린더 UI를 개선하면서...이런 저런 고민들과 해결 과정","tags":["TIL","우아한테크코스"]},"rawMarkdownBody":"\n## 배경\n\n모모 서비스를 만들면서 구현하고 사용중이었던 캘린더 UI를 UT(Usability Test)가 끝난 후, 같이 학습을 하는 크루들에게 피드백을 받은 후 개선하면서 했던 고민들과 해결 과정들을 기록한다...!\n\n## 기존 캘린더 UI\n\n![](./assets/prev-calendar.png)\n\n## 기존 캘린더 UI에서 개선했으면 하는 사항들\n\n- 모바일에서 선택된 날짜가 계란처럼 보이는 문제 해결\n\n![](./assets/egg-calendar.png)\n\n모모 서비스에서 약속을 만드는데 사용되는 캘린더 컴포넌트를 모바일에서 사용할 때 약간의 문제가 생겼다. 모바일 환경에서 특정 날짜를 강조하는 UI가 계란 형태로 보여지는 문제였다. 개발자 도구의 Element 탭에서 이유를 분석해보니, 스타일 속성에 기본적으로 padding이 6으로 설정되어 있는 것을 확인할 수 있었다. `<button />` 태그는 기본적으로 padding : 6 스타일 속성을 가지는 것인지, 아니면 내가 인지하지 못하는 곳에서 스타일 속성을 설정한 것인지 궁금해서, 완전 기본 `<button />` 태그를 만들어봤다.\n\n![](./assets/text-button.png)\n\n![](./assets/f12-button.png)\n\n아무런 스타일을 설정하지 않아도 기본적으로 padding : 6 스타일이 적용된 것을 확인할 수 있었다. 이제 이 스타일 속성을 제거하자 :)\n\n![](./assets/egg-resolve-calendar.png)\n\n개발자라면, 브라우저의 개발자 도구를 활용해서 문제를 빠르게 해결하자! 때로는 AI에게 물어보는 것 보다 개발자 도구를 열어서 빠르게 확인하는 것이 좋은 것 같다고 느꼈다.\n\n- 가장 왼쪽에 일요일이 오도록 변경 + 일요일 색 수정\n\n새벽 4시까지 디자인을 했었던 날에 이유는 확실하게 기억이 나지는 않지만, 월요일이 가장 왼쪽에 오도록 달력 디자인이 설계됐었다. 이 후 다른 크루들에게 피드백을 몇 번 받았었는데 다른 서비스의 달력은 모두 일요일이 가장 왼쪽에 있으니, 모모 달력도 이에 맞춰 변경했으면 좋겠다는 피드백들을 받았다. 월요일이 가장 왼쪽에 있어야 하는 확실한 이유도 없었기에, 수용할 만한 피드백이라고 생각해서 개선하기로 했다!\n\n```tsx\nexport function getYearMonthInfo(year: number, month: number) {\n  const startDate = new Date(year, month - 1, 1)\n\n  /* \n   로직 설명(@hwinkr)\n   - 월요일을 index 0으로 변경하기 위해서 나머지 연산자를 활용한다.\n   - 자바스크립트 Date 객체는 기본적으로 일요일이 인덱스가 0인데, 모모 달력은 월요일을 인덱스를 0으로 만들어줘야 한다.\n   - 따라서, 특정 달의 시작 날짜에 대한 인덱스에 6을 더해주고 7로 나눈 나머지를 사용하는 것으로 구현했다.\n  */\n  const firstDayIndex = (startDate.getDay() + 6) % 7\n\n  const lastDayOfMonthDate = new Date(year, month, 0)\n  const lastDayNumber = lastDayOfMonthDate.getDate()\n\n  const daySlotCount = firstDayIndex + lastDayNumber\n\n  return { year, month, firstDayIndex, daySlotCount } as const\n}\n```\n\n일요일이 가장 첫 번째 요일 즉, 인덱스가 0이기 때문에 월요일을 가장 왼쪽에 배치하기 위해서는 월요일의 인덱스를 0으로 만들어줘야 했다. 이를 위해서 나머지 연산자를 사용했다.\n\n```tsx\nconst firstDayIndex = (startDate.getDay() + 6) % 7\n```\n\n월요일은 인덱스가 1이기 때문에 `(1 + 6) % 7 = 0` 이 되고, 월요일 인덱스를 0으로 변경해줄 수 있었다.\n\n하지만, 피드백을 반영하면서 다시 일요일 인덱스를 0으로 만들어줘야 했기에 해당 로직은 제거하게 되었다.\n\n```tsx\nexport const generateMonthDaySlots = (year: number, month: number) => {\n  const startDate = new Date(year, month - 1, 1)\n  const firstDayIndex = startDate.getDay()\n\n  const lastDateOfMonth = new Date(year, month, 0)\n  const lastDayNumber = lastDateOfMonth.getDate()\n\n  const daySlotCount = firstDayIndex + lastDayNumber\n\n  return { firstDayIndex, daySlotCount } as const\n}\n```\n\n- 토요일에 색 추가 +) 요일을 보여주는 텍스트 크기 변경\n\n위 캘린더를 보여주니, 일요일에 빨간색을 표시해주는 것은 좋지만 토요일에도 파란색 표시가 있으면 사용자가 더 쉽게 달력 UI를 이용할 수 있을 것 같다는 피드백도 받았다. 이를 수용해서 알맞은 색을 찾았고, 달력에서 활용하기로 했다. `#8c9eff`\n\n![](./assets/dayOfWeek-calendar.png)\n\n추가로, 요일을 보여주는 텍스트의 크기가 실제로 휴대폰에서 확인해보니 너무 작은 것 같아서 1.6rem(1.6px)로 변경했다.\n\n- 일요일 색 변경\n\n기능 구현에 집중하느라, 디자인에 신경 쓰지 못해서 일요일의 색을 `red` 로 했었다. 모모 서비스의 MVP가 완성되고 달력을 다시 보니 일요일의 색을 변경해야 할 필요성을 느꼈다. 그래서, col.or앱을 참고해서 모모의 분홍색에 그나마 어울리는 빨간색을 찾아서 변경했다. `#fa665b`\n\n- 오늘 이전은 선택할 수 없도록 disabled 처리 +) 오늘 날짜에 색 추가\n\n과거 날짜에 대한 약속은 잡지 않기 때문에, 사용자에게 과거 날짜는 선택할 수 없음을 UI로 표시해줘야 했다. 다른 캘린더 UI를 참고하면서 `<button />`이 disabled 상태일 때 보여주는 UI와 비슷하게 표시하면 사용자에게 지난 날짜는 선택할 수 없다는 것을 알려줄 수 있을 것 같았다.\n\n![](./assets/egg-resolve-calendar.png)\n\n확실히 사용자에게 선택할 수 없는 날짜임을 암묵적으로 알려줄 수 있을 것 같았다.\n\n여기까지 작업을 하고, 한 가지 고민을 추가로 하게 되었다. 선택할 수 없는 요소 즉, clickable 하지 않은 요소인데 `<button />` 태그를 사용하는 것이 맞는지에 대한 고민이었다.\n\n```tsx\nreturn isValidDate ? (\n  <button\n    key={fullDate}\n    onClick={() => onDateClick(fullDate)}\n    disabled={isPrevDate}\n    css={[s_baseDaySlot, s_daySlotButton]}\n  >\n    <span\n      css={[\n        s_baseDaySlotText,\n        s_daySlotText({\n          isSelectedFullDate,\n          isPrevDate,\n          isHoliday,\n          isSaturday,\n          isToday,\n        }),\n      ]}\n    >\n      {date}\n    </span>\n  </button>\n) : (\n  <div key={fullDate} css={s_baseDaySlot}></div>\n)\n```\n\n실제로 달력 UI를 구현하는 코드에서는 유효한 날짜가 아니면\n\n![](./assets/div-cell-calendar.png)\n\n즉, 날짜로 표시할 필요가 없고 빈칸으로 보여줘야할 경우에 `<button />`이 아닌 <div /> 태그를 사용해서 보여주기 때문에 이미 지난 날짜에 대해서도 <div />를 사용해서 보여줘야할지에 대한 고민이었다. 웹 접근성을 고려했을 때, 클릭할 수 있는 요소에 대해서만 `<button />` 태그를 사용하는 것이 좋다는 것을 알고 있으므로 이미 지난 날짜는 선택할 수가 없는데(클릭할 수가 없는데) `<button />` 태그를 사용해도 되는지에 대한 의문이 생겼다. 이에 대한 고민을 낙타에게 이야기를 했고, 과거에는 선택할 수 있는 날짜였지만 시간이 지나서 선택할 수 없게된 것 뿐이고, 사용자에게 표시를 해줘야 하는 유효한 날짜이기 때문에 `<button />` 태그를 사용하는 것이 좋을 것 같고 추가로, disabled 처리를 하면 될 것 같다는 결론을 지었다. 다른 서비스는 어떻게 하고 있나 궁금해서 네이버를 방문해서 알아보았다.\n\n![](./assets/naver-calendar.png)\n\n네이버도 이미 지난 날짜에 대해서도 `<button />` 태그를 사용하고 disabled를 활용하고 있는 것을 확인할 수 있었다.\n\n오늘 날짜를 표시하는 경우에는 모모 서비스의 primary color인 분홍색의 보색인 녹색 계열의 색을 활용했다. 기존에는 선택된 날짜들의 스타일과 비슷하게 동그란 원을 추가로 그려줬다.\n\n![](./assets/egg-resolve-calendar.png)\n\n해당 디자인을 적용하고 나서, 오늘 날짜를 잘 강조한 것 같아서 괜찮다 싶었다. 하지만, 약속 후보 날짜들을 선택하고 나니 생각이 달라졌다.\n\n![](./assets/today-selected-calendar.png)\n\n동그란 원을 활용한다는 점이 비슷해서, 오늘 날짜와 선택된 날짜들을 강조하는 것이 헷갈릴 수 있겠다는 생각을 했다. 모모 팀원들과 다른 팀 사람들을 찾아가서 물어보니 나와 생각이 비슷했다. 이를 해결하기 위해서 다른 서비스들의 달력은 어떻게 오늘 날짜를 강조하고 있는지 찾아보았다. 그 중 동그란 원을 활용하지 않고 오늘 날짜 밑에 작은 점을 두는 UI를 찾게되었고, 이 UI를 활용하면 선택된 날짜들을 강조하는 스타일과 달라지니 헷갈릴 수 있는 문제를 해결할 수 있을 것이라 판단해 적용해보았다.\n\n![](./assets//div-cell-calendar.png)\n\n적용한 뒤, 다시 다른 팀원들을 찾아가서 물어보니 날짜 뒤, 동그란 원을 두는 것 보다 날짜 아래에 작은 점을 두는 것이 스타일이 구분되어 헷갈리지 않을 것이라는 피드백을 받게 되었다. :)\n\n정말 작은 디자인 요소이지만, 헷갈림을 줄 수도 있을 것 같은 부분을 개선하는 과정을 통해서 사용자 친화적인 디자인을 하는 것이 얼마나 중요한 것인지를 한 번더 깨닫게 되었다!\n\n## 기타 배운점들\n\n1. 자바스크립트 객체를 활용해서 특정 달의 마지막 날짜를 구하기\n\n```tsx\nconst lastDayOfMonth = new Date(2024, 8, 1)\n```\n\n자바스크립트에서 월은 인덱스가 0부터 시작하기 때문에, 위 처럼 코드를 입력하면 숫자 8은 실제로 9를 가르키게 된다.\n\n```tsx\n\"9/1/2024, 12:00:00 AM\"\n```\n\n자바스크립트 Date 객체에서 세 번째 인자는 특정 달의 n번째 날짜를 가르키게 되어 1로 호출하게 되면 9월 1일을 가르키게된다. 여기서 0으로 변경하면 9월 1일의 전 날인 8월 31일을 반환하게 된다. 그래서 특정 달의 마지막 날짜를 구하기 위해서는 세 번째 인자를 0으로 변경해서 호출하는 방법을 활용할 수 있다.\n\n```tsx\nconst lastDayOfMonth = new Date(2024, 8, 0);\n\nconsole.log(lastDayOfMonth.toLocaleString())\n\n-> // '8/31/2024, 12:00:00 AM\n```\n\n1. Day, Date 컨벤션 맞추기\n\n![](./assets/date-day.png)\n\n코드리뷰를 해주는 팀원이 day, date의 단어를 혼용해서 사용하고 있는 것 같다는 피드백을 줬다. day를 요일로써도 사용하고 있고, 날짜(숫자)로써도 사용하고 있는 것 같아 코드 리뷰를 하기 어렵다는 피드백이었다. day, date 도메인 용어에 대한 의미를 정하고 가면 좋을 것 같아서 정리를 한 후 팀원들에게 공유했다.\n\n![alt text](./assets/share-date-day.png)\n\n- date\n  - 오늘 날짜를 의미합니다.\n  - 2024-08-15이면, 15를 의미합니다.\n- day\n  - 요일을 의미합니다. (목)\n- fullDate\n  - 2024-08-15와 같은 전체 날짜를 의미합니다.\n  - 사용자가 약속 후보 날짜들을 담을 때, fullDate를 사용합니다.\n\n코드 리뷰를 할 때에도 모든 팀원이 도메인 용어에 대해 전제가 깔려있으면 리뷰를 하기 편하겠구나,,,하는 생각이 들었다. PR description을 더 상세하게, 잘 작성해야겠다고 느꼈다.\n\n## 남은 개선 사항들\n\n- [ ] 일요일 뿐만 아니라, 실제 공휴일도 표시하기\n- [ ] 드래그로 날짜들을 선택할 수 있도록 하기\n\n![](./assets/momo-feedback.png)\n\n기간이 긴 약속을 잡아야할 때는, 날짜를 일일이 하나씩 누르기 힘드므로 드래그를 활용해서 날짜를 선택할 수 있으면 좋을 것 같다는 피드백을 받았다. 이 피드백 반영은 `to be continued…`로 남겨둔다\n"},{"excerpt":"모모 프론트엔드 배포 자동화 도전! 6주 동안 모모 서비스 개발을 진행하면서, 프론트엔드 작업이 배포가 되어야 하는 상황에 매번 aws에 로그인을 하고, s3 버킷에 새로운 리소스들을 업로드하고, cloudfront의 캐싱을 무효화 하는 작업을 수동으로 했었다. 더이상 이럴 수 없다는 생각이 들어 페드로와 함께 프론트엔드 배포 자동화를 진행했다. 아래는 …","fields":{"slug":"til-frontend-deploy"},"frontmatter":{"date":"August 12, 2024","title":"[TIL] aws s3, cloudfront 배포 자동화 해보기","tags":["TIL","우아한테크코스"]},"rawMarkdownBody":"\n## 모모 프론트엔드 배포 자동화 도전!\n\n6주 동안 모모 서비스 개발을 진행하면서, 프론트엔드 작업이 배포가 되어야 하는 상황에 매번 aws에 로그인을 하고, s3 버킷에 새로운 리소스들을 업로드하고, cloudfront의 캐싱을 무효화 하는 작업을 수동으로 했었다. 더이상 이럴 수 없다는 생각이 들어 페드로와 함께 프론트엔드 배포 자동화를 진행했다. 아래는 배포를 자동화하기 위한 yml 파일을 설정하면서 배운 내용들이다!\n\n### 프론트엔드 배포 yml 파일에서 사용되는 키워드\n\n- github actions\n- self-hosted\n- aws s3, cloudfront\n\n### on\n\ndevelop 브랜치에서 시작해서\n\n- 새로운 기능(feature)를 구현하고,\n- develop 브랜치로 PR(Pull Request)를 생성하고,\n- 코드 리뷰를 주고 받다가 develop 브랜치로 머지가 될 때 Frontend CD workflow를 실행한다.\n\n깃허브 이벤트에는 merge가 존재하지 않으므로, develop 브랜치에 push가 되었을 때 워크 플로우를 실행한다.\n\n```shell\nname: Frontend CD\n\non:\n  push:\n    branches: [\"develop\"]\n\npermissions:\n  checks: write\n```\n\n## jobs\n\n### 1) detect-changes\n\n```shell\ndetect-changes:\n  runs-on: ubuntu-latest\n  permissions:\n    pull-requests: read\n  outputs:\n    backend: ${{ steps.filter.outputs.backend }}\n    frontend: ${{ steps.filter.outputs.frontend }}\n  steps:\n    - uses: actions/checkout@v4 # Push 이벤트이기 때문에 checkout 해야 함\n      with:\n        ref: develop\n    - uses: dorny/paths-filter@v3\n      id: filter\n      with:\n        base: \"develop\" # 해당 브랜치의 last commit과 변경점 비교\n        filters: |\n          backend:\n            - 'backend/**'\n          frontend:\n            - 'frontend/**'\n```\n\n백엔드의 PR이 머지되어 develop 브랜치에 push 이벤트가 발생할 경우에는 프론트엔드 CD 워크플로우가 실행될 필요가 없기 때문에, `detect-changes` job을 활용한다. `detect-change`는 `develop` 브랜치의 last commit과 PR에서의 backend, frontend 폴더 내부의 commit들과 비교해서 비교 결과를 outputs의 frontend, backend에 각각 담는 작업을 수행하는 job이다.\n\n### 2) fe-build\n\n```shell\nfe-build:\n  needs: detect-changes # jobs들은 병렬로 실행됨, needs 키워드를 사용해서 특정 job이 완료(성공)면 실행하도록 설정\n  if: ${{ needs.detect-changes.outputs.frontend == 'true' }}\n  runs-on: ubuntu-latest\n  defaults:\n    run:\n      shell: bash\n      working-directory: ./frontend\n\n  steps:\n  - name: 모모 레파지토리의 코드를 가져와요 :)\n    uses: actions/checkout@v4\n\n  - name: 노드 버젼을 설정해요 :)\n    uses: actions/setup-node@v4\n    with:\n      node-version: \"lts/*\"\n\n  - name: 이전 의존성을 저장해둔게 있나~? 확인해요 :)\n    id: cache\n    uses: actions/cache@v4\n    with:\n      path: \"frontend/node_modules\"\n      key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}\n      restore-keys: |\n        ${{ runner.os }}-node-\n        ${{ runner.os }}\n\n  - name: package-lock.json을 활용해서 의존성을 깨끗하게 설치해요 :)\n    if: steps.cache.outputs.cache-hit != 'true'\n    run: npm ci\n\n  - name: .env 파일을 생성해요 :)\n    run: |\n      echo \"${{ secrets.MOMO_FE_ENV }}\" >> .env\n\n  - name: 프론트엔드 리소스를 빌드해요 :)\n    run: npm run build\n\n  - name: 프론트엔드 리소스 결과물을 깃허브 레파지토리 artifacts로 업로드해요\n    uses: actions/upload-artifact@v4\n    with:\n      name: momoResources\n      path: frontend/dist\n```\n\n**1) needs**\n\n**깃허브 워크플로우에서 각 job들은 병렬로(동시에) 실행**되기 때문에, 만약 A job이 B job의 결과에 영향을 받는다면 A job에서 `needs`를 활용해서 B job이 끝나기를 기다려야 한다는 것을 명시한다. fe-build는 detect-change의 결과에 따라서 실행을 할지 말지 결정되기 때문에 needs에 detect-change를 추가한다. detect-change job의 결과물에서 frontend에 변경사항이 있으면, 프론트엔드 리소스들을 빌드하기 위한 job을 수행한다.\n\n**2) working-directory: ./frontend**\n\nworkding-directory가 ./frontend라는 것은 워크플로우를 실행하는 깃허브 서버에서 `cd frontend` 명령어를 입력하는 것과 같다. npm ci, npm run build와 같은 명령어를 실행하려면 frontend 경로 내부에서 실행해야 하기 때문에 ./frontend경로로 이동해서 작업들을 수행할 것을 명시한다.\n\n**3) actions/checkout@v4**\n\ncheckout은 깃허브 서버에 모모 레파지토리 코드를 가져오는 역할을 한다. 즉, 깃허브 서버에 git clone 명령어를 입력하는 것과 같다. checkout을 하면 워크플로우를 실행하는 깃허브 서버의 한 디렉터리에 모모 레파지토리 코드들이 다운로드된다. 100% 확실하지는 않은 경로지만 대략적으로 아래와 같이 디렉터리들이 만들어진다.\n\n- `/home/runner/work/2024-momo/frontend-cd/frontend`\n- `/home/runner/work/2024-momo/frontend-cd/backend`\n\n**4) upload-artifact**\n\nworking-directory가 ./frontend이기 때문에 모모 레파지토리에 있는 frontend 디렉터리로 이동해서, 의존성(package.json)들을 설치하고, env 파일을 설정하고 npm run build를 실행한다. 빌드까지 완료되면 위에서 언급한 대략적인 디렉터리에 즉, `/home/runner/work/2024-momo/frontend-cd/frontend/dist` 해당 디렉터리에 빌드 결과물들이 생긴다. 이제 `artifacts`에 `frontend/dist` 경로에 있는 결과물을 임시저장한다. 깃허브 `artifacts`는 워크플로우 실행 중에 생성된 파일이나 결과물을 임시로 저장하고, 다른 워크플로우 단계에서 다운로드해서 사용할 수 있는 임시 저장소 역할을 한다.\n\n### 3) deploy\n\n```shell\ndeploy:\n  needs: fe-build\n  runs-on: self-hosted\n  env:\n    CLOUD_FRONT_DISTRIBUTION_ID: ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID}}\n  steps:\n    - name: 모모 깃허브 레파지토리 artifacts로 부터 빌드 결과물을 다운받아요 :)\n      uses: actions/download-artifact@v4\n      with:\n        name: momoResources\n        path: ./frontend/dist\n    - name: aws에 배포하고 cloudfront 캐싱을 무효화해요\n      working-directory: ./frontend/dist/\n      run: |\n        aws s3 sync ./ s3://techcourse-project-2024/momo --delete\n        aws cloudfront create-invalidation --distribution-id \"$CLOUD_FRONT_DISTRIBUTION_ID\" --paths \"/*\"\n```\n\n**1) self-hosted**\n\n깃허브 서버(ubunt-lastes)를 사용하는 것이 아니라, self-hosted를 사용하는 이유는 깃허브 서버에서 우아한테크코스 aws에 접근할 수 있는 방법이 없기 때문이다. IAM 키를 발급받을 수 없는 환경이기 때문에, 우아한테크코스 aws에서 생성한 EC2 인스턴스에서 deploy job을 실행해야 한다.\n\n`aws s3 sync`, `aws cloudfront …` 와 같은 aws 명령어를 실행하기 위해서는 EC2 인스턴스에 `aws cli`가 설치되어 있어야 한다.\n\n**2) download-artifact**\n\n깃허브 artifacts에 저장한 momoResource를 EC2 인스턴스의 ./frontend/dist 경로에 다운로드 받는다. 깃허브 artifacts는 upload 할 때, 사용했던 name기준으로 찾는다.\n\n> **\\*Downloading files**: You can only download artifacts that were uploaded during the same workflow run. When you download a file, you can reference it by name.\n> 파일 다운로드: 동일한 워크플로 실행 중에 업로드된 아티팩트만 다운로드할 수 있습니다. 파일을 다운로드할 때 이름으로 파일을 참조할 수 있습니다.\\*\n\n[참고](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/storing-workflow-data-as-artifacts#about-workflow-artifacts)\n\n**3) aws s3 sync**\n\naws s3 sync는 자동으로 변경을 감지하여 변경 사항이 있는 파일들만 s3 버킷과 동기화 한다. 즉, 현재 s3 버킷에 저장되어 있는 리소스들과, 새롭게 빌드된 리소스들을 비교를 해서 변경 사항이 있는 파일들만 동기화 하는 작업을 수행한다.\n\n**4) aws cloudfront create-invalidation**\n\ncloudfront의 역할 중에는 s3 버킷에 저장된 리소스들을 캐싱하는 역할도 있다. 만약 s3 버킷에는 새로운 리소스들이 업로드 되어 있지만, cloudfront는 여전히 예전 리소스들을 캐싱하고 있다면 새로운 버젼이 릴리즈되었음에도 불구하고 사용자에게 이전 버젼의 서비스를 제공할 수도 있는 문제가 발생한다. 이 문제가 발생하지 않도록 하기 위해서 create-invalidation 명령어를 통해서 cloudfront의 캐싱을 무효화한다. 리액트 쿼리의 `queryClient.invalidateQueries` 와 비슷하다.\n\n아래는 전체 yml 파일 구성이다.\n\n```shell\nname: 모모 프론트엔드 배포 자동화 워크플로우\n\non:\n  push:\n    branches: [\"develop\"]\n\npermissions:\n  checks: write\n\njobs:\n  detect-changes:\n    runs-on: ubuntu-latest\n    permissions:\n      pull-requests: read\n    outputs:\n      backend: ${{ steps.filter.outputs.backend }}\n      frontend: ${{ steps.filter.outputs.frontend }}\n    steps:\n      - uses: actions/checkout@v4 # Push 이벤트이기 때문에 checkout 해야 함\n        with:\n          ref: develop\n      - uses: dorny/paths-filter@v3\n        id: filter\n        with:\n          base: \"develop\" # 해당 브랜치의 last commit과 변경점 비교\n          filters: |\n            backend:\n              - 'backend/**'\n            frontend:\n              - 'frontend/**'\n\n  fe-build:\n    needs: detect-changes # jobs들은 병렬로 실행됨, needs 키워드를 사용해서 특정 job이 완료(성공)면 실행하도록 설정\n    if: ${{ needs.detect-changes.outputs.frontend == 'true' }}\n    runs-on: ubuntu-latest\n    defaults:\n      run:\n        shell: bash\n        working-directory: ./frontend\n\n    steps:\n      - name: 모모 레파지토리의 코드를 가져와요 :)\n        uses: actions/checkout@v4\n\n      - name: 노드 버젼을 설정해요 :)\n        uses: actions/setup-node@v4\n        with:\n          node-version: \"lts/*\"\n\n      - name: 이전 의존성을 저장해둔게 있나~? 확인해요 :)\n        id: cache\n        uses: actions/cache@v4\n        with:\n          path: \"frontend/node_modules\"\n          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}\n          restore-keys: |\n            ${{ runner.os }}-node-\n            ${{ runner.os }}\n\n      - name: package-lock.json을 활용해서 의존성을 깨끗하게 설치해요 :)\n        if: steps.cache.outputs.cache-hit != 'true'\n        run: npm ci\n\n      - name: .env 파일을 생성해요 :)\n        run: |\n          echo \"${{ secrets.MOMO_FE_ENV }}\" >> .env\n\n      - name: 프론트엔드 리소스를 빌드해요 :)\n        run: npm run build\n\n      - name: 프론트엔드 리소스 결과물을 깃허브 레파지토리 artifacts로 업로드해요\n        uses: actions/upload-artifact@v4\n        with:\n          name: momoResources\n          path: frontend/dist\n\n  deploy:\n    needs: fe-build\n    runs-on: self-hosted\n    env:\n      CLOUD_FRONT_DISTRIBUTION_ID: ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID}}\n    steps:\n      - name: 모모 깃허브 레파지토리 artifacts로 부터 빌드 결과물을 다운받아요 :)\n        uses: actions/download-artifact@v4\n        with:\n          name: momoResources\n          path: ./frontend/dist\n      - name: aws에 배포하고 cloudfront 캐싱을 무효화해요\n        working-directory: ./frontend/dist/\n        run: |\n          aws s3 sync ./ s3://techcourse-project-2024/momo --delete\n          aws cloudfront create-invalidation --distribution-id \"$CLOUD_FRONT_DISTRIBUTION_ID\" --paths \"/*\"\n```\n\n## 느낀점\n\n이전에 `aws amplify`를 사용해서 배포를 했었을 때는, aws에서 알려주는대로 버튼만 클릭하면 알아서 모든 것을 해줬다. 심지어 yml 파일을 만들 필요도 없었다. 하지만 이번에 배포 자동화를 위한 yml 파일을 직접 만들면서 초반에는 이해하기 힘들었지만, 각 job들을 수행하기 위한 명령어들을 평소에 내가 자주 사용하는 명령어로 비유해서 이해를 시도하니 쉽게 이해할 수 있었다. (cd frontend, git clone과 같은…)\n\n이제 merge 버튼만 클릭하면 프론트엔드 배포가 알아서 된다니… 너무 편하게 개발할 수 있을 것 같다!\n\n- PR 링크 : https://github.com/woowacourse-teams/2024-momo/pull/212\n"},{"excerpt":"학습 배경 모모 서비스 로그인 방식이 변경되면서 CORS에 대해서 이해해야 할 필요성이 생겼다.\n기존 로그인 방식은 다음과 같았다. 약속에 참여하고자 하는 사용자가 처음 로그인을 하면 응답 바디에 토큰을 넣어서 전달 토큰을 쿠키에 저장  라이브러리를 활용해서 쿠키에 저장된 토큰을 사용 위 코드에서도 확인할 수 있듯, 쿠키에 저장된 사용자의 토큰을 자바스크…","fields":{"slug":"til-cors"},"frontmatter":{"date":"August 06, 2024","title":"[TIL] CORS에 대해 간단하게 알아보자","tags":["TIL","우아한테크코스"]},"rawMarkdownBody":"\n## 학습 배경\n\n모모 서비스 로그인 방식이 변경되면서 CORS에 대해서 이해해야 할 필요성이 생겼다.\n기존 로그인 방식은 다음과 같았다.\n\n1. 약속에 참여하고자 하는 사용자가 처음 로그인을 하면 응답 바디에 토큰을 넣어서 전달\n2. 토큰을 쿠키에 저장\n3. `react-cookie` 라이브러리를 활용해서 쿠키에 저장된 토큰을 사용\n\n```jsx\nexport default function getHeaders(): HeadersInit {\n  const headers = { \"Content-type\": \"application/json\" }\n  const token = getCookie(COOKIE_KEYS.token)\n\n  if (token) {\n    return { ...headers, Authorization: `Bearer ${token}` }\n  }\n\n  return headers\n}\n```\n\n위 코드에서도 확인할 수 있듯, **쿠키에 저장된 사용자의 토큰을 자바스크립트로 접근해서 요청 헤더에 담아서 보냈었다.** 하지만, 해당 로그인 방식을 사용하다가 로그인과 관련된 보안을 강화하게 되면서 로그인 방식도 자연스럽게 변경되었다. 아래는 강화된 보안 내용을 간단하게 정리한 것이다.\n\n## HttpOnly\n\nhttpOnly는 이름에서 확인할 수 있듯 **쿠키를 오직 http 프로토콜을 사용한 통신에서만 접근할 수 있도록 하는 설정**이며, 쿠키 자체에 설정한다. httpOnly를 설정하지 않으면 `react-cookie`나 `document.cookie`등 자바스크립트로 쿠키에 접근을 할 수 있기에 xss 공격에 취약해진다는 단점이 있다.\n\n![](./assets/momo-set-cookie.png)\n\n그래서 서버측에서 응답 헤더에 HttpOnly 설정을 하고 자바스크립트로는 쿠키에 접근할 수 없도록 했다.\n\n## sameSite\n\n이제, 자바스크립트로는 쿠키에 접근할 수 없기 때문에 서버에 인증/인가가 필요한 요청을 할 때 브라우저의 쿠키를 직접 서버에 전달해주는 것으로 변경되었다.\n\n```tsx\nconst createFetchClient = (baseUrl: string) => {\n  return async <T>({ path, method, body, isAuthRequire }: FetchOption): Promise<T> => {\n\t\t//...\n    const response = await fetch(url, {\n      method,\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: body ? JSON.stringify(body) : null,\n      credentials: isAuthRequire ? 'include' : 'omit',\n    });\n\t  //...\n};\n```\n\nfetch 함수를 호출할 때, `credentials : ‘include’` 설정을 해주면 요청 시 브라우저의 쿠키를 함께 전달해줄 수 있다. 하지만, 클라이언트와 서버가 쿠키를 주고 받음으로써 통신할 때 CSRF 공격을 받을 수 있는 문제가 있다고 한다.\n\n[ProtSwagger](https://portswigger.net/web-security/csrf)에서는 CSRF에 대해서 다음과 같이 설명한다.\n\n> _Cross-site request forgery (also known as CSRF) is a web security vulnerability that allows an attacker to induce users to perform actions that they do not intend to perform. It allows an attacker to partly circumvent the same origin policy, which is designed to prevent different websites from interfering with each other._\n>\n> _크로스 사이트 요청 위조(CSRF라고도 함)는 공격자가 사용자가 의도하지 않은 작업을 수행하도록 유도할 수 있는 웹 보안 취약점입니다. 이를 통해 공격자는 서로 다른 웹사이트가 서로 간섭하지 못하도록 설계된 동일한 출처 정책을 부분적으로 우회할 수 있습니다._\n\n정리하자면, 웹 사이트 사용자 자신의 의지와는 무관한 행동을 하도록 유도하는 공격을 말한다.\n\n![](./assets/csrf.png)\n\n해커가 스크립트가 심어진 페이지를 사용자에게 방문하도록 유도한 후, 방문하면 비밀번호 변경이나 송금을 요청한다. 이 때, 사용자 브라우저의 쿠키에는 로그인을 한 후 받은 토큰이 저장되어 있기 때문에 서버는 사용자의 요청이라고 간주하고 해당 요청을 실행한다. **이로써 해커가 의도한 행동을 마치 사용자가 한 것 처럼 꾸미는 공격이 가능**해진다.\n\n해당 공격이 가능한 이유는 도메인이 다른 클라이언트라도 서버에 특정 요청을 할 때, 쿠키를 보내는 것이 가능하기 때문이다.\n\n```html\n<form action=\"https://www.example.com/change-password\" method=\"POST\">\n  <input type=\"hidden\" name=\"new-password\" value=\"newpassword123\" />\n</form>\n<script>\n  document.forms[0].submit()\n</script>\n```\n\n위 악성 코드가 심어진 공격자의 도메인에 방문한 사용자는 쿠키와 함께 서버에 요청을 보내게 되어 비밀번호가 공격자의 의도대로 변경된다.\n\n이 문제를 해결하기 위해서 same-site 설정이 등장했고, 모모도 적용해 보기로 했다. 서버에서 설정할 수 있는 same-site 옵션은 다음과 같다.\n\n1. **None**: 브라우저가 **모든 출처**에 쿠키를 전송할 수 있도록 허용. 이 설정은 `SameSite` 속성이 없는 것과 같습다. 단, `None`을 사용할 때는 쿠키에 `Secure` 속성을 반드시 포함해야 하며, 그렇지 않으면 대부분의 브라우저에서 쿠키가 차단된다.\n2. **Lax**: 일부 안전한 요청(GET, HEAD 등)에 대해서만 쿠키를 보낸다. 즉, **안전한 요청**에서 쿠키가 전송되며, 사용자 상호작용이 발생한 링크 클릭 또는 폼 제출과 같은 경우에만 `SameSite`가 적용된다. 단, `POST` 요청 등 **안전하지 않은** 메서드에서는 쿠키가 전송되지 않는다.\n3. **Strict**: **동일한 사이트 내에서 발생하는 요청**에 대해서만 쿠키를 전송하도록 한다. **Cross-site** 요청에는 쿠키를 전송하지 않는다. Cross-site의 정의는 기본 도메인(eTLD+1) 비교에 기반한다.\n\n![[이미지 출처](https://jfhr.me/what-is-an-etld-+-1/)](./assets/etld.png)\n\n- TLD : 최상위 도메인(top-level-domain), 해당 이미지에서 uk\n- eTLD : 유효 최상위 도메인(effective-top-level-domain), 해당 이미지에서 co.uk\n- eTLD + 1 : **eTLD+1**은 eTLD와 도메인 이름의 다음 부분을 의미. google.co.uk\n\neTLD + 1에 기반한 클라이언트 요청 origin, 응답 origin 비교를 통해서 같을 경우에만 쿠키를 보내도록 한다.\n\n모모 서비스를 예시로 들자면 다음과 같다.\n\n- `https://www.naver.com`\n\n- `https://momonow.kr`, `https://api.momonow.kr`은 둘 다 eTLD + 1이 momonow.kr 이므로 same-site라고 판단되어 요청에 쿠키를 함께 전달한다.\n- 반면 `http://뭐시기저시기.kr`, `https://api.momonow.kr`은 eTLD + 1 비교에 의해서 cross-site라고 판단되어 요청에 쿠키를 함께 전달하지 않는다.\n\n여기까지 정리하면서 추가적인 궁금증이 생겼다.\n\n🤔 도메인이 다르다는 것이 어떤 의미인지?  \n🤔 쿠키를 주고 받으면서 요청/응답을 할 때, 클라이언트 영역이 더 알면 좋은 지식이 있는지?\n\n해당 궁금증들을 해결하기 위해서 CORS 개념에 대해서 간단하게 학습해 보는 시간을 가졌다.\n\n## 브라우저는 기본적으로 SOP\n\n브라우저는 기본적으로 SOP 정책을 사용한다고 한다. MDN에서는 SOP에 대해서 다음과 같이 설명한다.\n\n> _The same-origin policy is a critical security mechanism that restricts how a document or script loaded by one origin can interact with a resource from another origin._\n>\n> _It helps isolate potentially malicious documents, reducing possible attack vectors. For example, it prevents a malicious website on the Internet from running JS in a browser to read data from a third-party webmail service (which the user is signed into) or a company intranet (which is protected from direct access by the attacker by not having a public IP address) and relaying that data to the attacker._\n>\n> _동일 출처 정책은 한 출처에서 로드된 문서 또는 스크립트가 **다른 출처의 리소스**와 상호 작용하는 방식을 제한하는 중요한 보안 메커니즘입니다._\n>\n> _잠재적으로 악의적인 문서를 격리하여 가능한 공격 경로를 줄이는 데 도움이 됩니다. 예를 들어, 인터넷의 악성 웹사이트가 브라우저에서 JS를 실행하여 사용자가 로그인한 타사 웹메일 서비스 또는 회사 인트라넷(공용 IP 주소가 없어 공격자가 직접 액세스할 수 없도록 보호됨)에서 데이터를 읽고 해당 데이터를 공격자에게 전달하는 것을 방지할 수 있습니다._\n\n해당 내용을 정리해 보자면, 보안상의 이유로 브라우저가 사용하는 정책인 SOP는 출처가 다른 요청을 제한한다 즉, 출처가 다른 요청은 잘못된 요청이라고 판단하고 요청을 허가하지 않는 정책이라고 할 수 있다.\n\n그렇다면, 어떤 경우에 출처가 다르다고 판단하는 것일까?\n\n## 출처(origin) 비교하기\n\n출처(origin)이 무엇인지 알아보기 위해서 아래 URL이 있다고 가정해 보고, 해당 URL을 분석해 보자.\n\n```text\nhttps://momonow.kr:8080/meeting/schedules?attendeeName='해리'\n```\n\n- scheme(protocol) : http 또는 https\n- host : hostname과 port를 합친 것을 말한다.\n  - hostname : momonow.kr\n  - port : 8080\n- pathname : /meeting/schedules\n- search : attendeeName=’해리’\n\n여기서 출처(origin)는 scheme와 host(hostname + port)를 합친 것을 말하며, **구성 중 하나라도 다르면 cross-origin이라고 판단한다.**\n\n만약 현재 사용자의 웹 사이트 방문 URL 다음과 같다고 가정해 보자.\n\n```text\nhttps://momonow.kr\n```\n\n그렇다면, 다음과 같은 경우에 cross-origin이라고 할 수 있다.\n\n1. http로 요청을 보내는 경우\n2. `http://something.momonow.kr`로 요청을 보내는 경우\n\n→ 해당 요청은 서브 도메인으로 요청을 보내지만 서브 도메인이 다른 경우에도 다른 호스트라고 판단하기 때문에 cross-origin이라고 판단한다.\n\n3. 포트번호 80으로 요청을 보내는 경우 (https 기본 포트 번호는 443)\n\n브라우저는 위 3가지 요청에 대해서 **모두 출처가 다른 요청이라고 판단**하기 때문에 요청을 허가하지 않는다.\n\n## CORS\n\n![](./assets/momo-f12.png)\n\n현재 모모 서비스는 `https://momonow.kr` → `https://api.momonow.kr/api/v1/meetings`로 보내는 요청인 corss-origin 요청인 경우에도 클라이언트 & 서버가 응답/요청을 주고 받을 수 있다. 그 이유는 서버 측에서 `Access-Control-Allow-Origin` 설정에 `https://momonow.kr`을 추가해줬기 때문이다. 해당 설정은 브라우저에게 해당 origin에서 오는 요청은 유효한 요청이라는 것을 알려주기 위한 설정이다. 브라우저는 기본적으로 특정 사이트에 요청을 보내도 되는지 확인할 방법이 없기 때문에 요청을 받아서 처리하는 서버 측에서 직접 정책에 따른 설정을 해줘야 한다. 해당 설정이 CORS 개념을 이용한 것이다.\n\nMDN에서는 CORS에 대해 다음과 같이 설명한다.\n\n> _**Cross-Origin Resource Sharing** ([CORS](https://developer.mozilla.org/en-US/docs/Glossary/CORS)) is an [HTTP](https://developer.mozilla.org/en-US/docs/Glossary/HTTP)-header based mechanism that allows a server to indicate any [origins](https://developer.mozilla.org/en-US/docs/Glossary/Origin) (domain, scheme, or port) other than its own from which a browser should permit loading resources. CORS also relies on a mechanism by which browsers make a \"preflight\" request to the server hosting the cross-origin resource, in order to check that the server will permit the actual request. In that preflight, the browser sends headers that indicate the HTTP method and headers that will be used in the actual request._\n>\n> _**교차 출처 리소스 공유**(Cross-Origin Resource Sharing, [CORS](https://developer.mozilla.org/ko/docs/Glossary/CORS))는 브라우저가 자신의 출처가 아닌 다른 어떤 [출처](https://developer.mozilla.org/ko/docs/Glossary/Origin)(도메인, 스킴 혹은 포트)로부터 자원을 로딩하는 것을 허용하도록 서버가 허가 해주는 [HTTP](https://developer.mozilla.org/ko/docs/Glossary/HTTP) 헤더 기반 메커니즘입니다. 또한 CORS 는 교차 출처 리소스를 호스팅하는 서버가 실제 요청을 허가할 것인지 확인하기 위해 브라우저가 보내는 \"사전 요청(프리플라이트, Preflight)\" 메커니즘에 의존합니다. 이 사전 요청에서 브라우저는 실제 요청에서 사용할 HTTP 메서드와 헤더들에 대한 정보가 표시된 헤더에 담아 보냅니다._\n\n정리하자면, CORS는 서버가 자원 공유를 **부분적으로 허용할 출처를 결정하는 정책 및 설정이다.**\n\nCORS를 사용하기 위해서는 서버 측에서 아래 두 설정을 해줘야 한다.\n\n1. ACAO - access control allow origin\n2. ACOM - access control allow method\n\n```java\nregistry.addMapping(\"/api/**\")\n        .allowedOriginPatterns(corsProperties.getAllowOrigins())\n        .allowedMethods(\"GET\", \"POST\", \"HEAD\", \"PATCH\", \"PUT\", \"DELETE\")\n        .allowCredentials(true);\n```\n\n코드로 나타내면 다음과 같고, 클라이언트 측과 쿠키를 주고 받기위해 `allowCredentials` 설정까지 해줬다.\n\n## 느낀 점\n\n글 제목은 간단하게 알아보기였지만, 글을 다 작성하니 전혀 간단하지 않은 것 같다…ㅎ\n\n브라우저는 보안을 위해서 기본적으로 SOP 정책을 사용하지만 동일 서비스에서 클라이언트 & 서버의 도메인이 다를 경우 서버의 자원을 부분적으로 허용하기 위해서 CORS를 사용할 수 있다는 것을 배웠다. 브라우저는 특정 경로에 요청을 보내도 되는 것인지 판단할 수 없기 때문에 CORS 설정으로 알려줘야한다고 정리하니 이해가 정말 잘 됐다.\n\n그리고, xss, CSRF 공격이 실제로 발생한 것을 눈으로 확인해 보지는 않았지만 해당 공격이 발생할 경우 어떻게 대처할 수 있을지를 깊게는 아니지만 어느 정도 배울 수 있었다.\n\n“쿠키를 직접 주고 받는 방식으로 로그인 방법 변경” 이 한 문장을 완성하기 위해서 정말 많은 개념이 필요했다. 위에서 정리한 내용 정도면 프론트엔드 영역을 개발하는 사람으로서 쿠키 기반 로그인에 대해 충분히 이해했다고 볼 수 있을 것 같다(~~아니면 뭐…더 공부해야겠지만~~)\n"},{"excerpt":"배경 모모에서 사용하는 헤더 컴포넌트의  속성을 로 변경했다가 예상치 못한 UI 관련 문제를 겪고, 이를 해결하는 과정에서 fixed, sticky의 차이를 학습하게 되었다. 어떤 차이가 있는지 학습한 내용을 기록해 본다 :) 현재 모모 앱의 글로벌 레이아웃 컴포넌트는 다음과 같다. 헤더 아래에 있는 요소들의 공통 레이아웃 스타일을 정의하는 s_conte…","fields":{"slug":"til-css-position"},"frontmatter":{"date":"August 04, 2024","title":"[TIL] css position fixed, sticky 속성의 차이","tags":["TIL","우아한테크코스"]},"rawMarkdownBody":"\n## 배경\n\n모모에서 사용하는 헤더 컴포넌트의 `position` 속성을 `fixed`로 변경했다가 예상치 못한 UI 관련 문제를 겪고, 이를 해결하는 과정에서 fixed, sticky의 차이를 학습하게 되었다. 어떤 차이가 있는지 학습한 내용을 기록해 본다 :)\n\n현재 모모 앱의 글로벌 레이아웃 컴포넌트는 다음과 같다.\n\n```tsx\nexport default function GlobalLayout() {\n  return (\n    <div css={s_globalContainer}>\n      <Header />\n      <div css={s_content}>\n        <Outlet />\n      </div>\n    </div>\n  )\n}\n```\n\n```tsx\nexport const s_content = css`\n  overflow-y: scroll;\n  height: calc(100vh - 8.4rem); // 8.4rem : 헤더의 높이\n  padding: 0 1.6rem;\n`\n```\n\n헤더 아래에 있는 요소들의 공통 레이아웃 스타일을 정의하는 s_content 스타일은 위와 같이 정이되어 있다. 높이가 고정되어 있고, overflow-y : scroll이 되어있기 때문에 모바일 환경에서 툴팁을 보게되면 스크롤과 관련해서 사용자 경험에 좋지 못한 문제가 생겼다.\n\n![클릭한 셀과 툴팁이 떨어지면 안되는데...](./assets/bad-ux-tooltip.png)\n\n가장 짙은 색의 셀을 클릭하면 툴팁이 나오게 되고, 이 상태에서 스크롤을 하게 되면 셀과 툴팁이 떨어져버리는 문제가 발생했다. 높이가 고정되어 있고 `overflow-y : scroll` 속성에 의해서 스크롤이 되는 것이기 때문에 툴팁은 처음 렌더링 된 위치에 가만히 있고 툴팁 뒤의 셀만 움직이기 때문에 발생한 현상이었다.\n\n이 문제를 해결하기 위해서 높이를 고정하지 않고, `overflow-y : scroll` 속성을 삭제했다.\n\n```tsx\nexport const s_content = css`\n  padding: 0 1.6rem;\n`\n```\n\n![그래 이거야!](./assets/good-ux-tooltip.png)\n\n이제 스크롤을 해도 셀과 툴팁은 떨어지지 않게 되었다. 하지만, 이미지에서 확인할 수 있는 것 처럼, 헤더에 position 속성이 없기 때문에 스크롤을 하면 헤더도 함께 올라가서 눈에 보이지 않는 문제가 발생했다. 스크롤을 하다가 중간에 메뉴 바를 클릭하거나 홈으로 이동하고 싶은 사용자들을 위해서 헤더는 고정되었으면 좋겠다 생각해서. `position : fixed` 속성을 추가했다. 그러나…\n\n![](./assets/header-fixed.png)\n\n`fixed` 속성은 부모의 css 속성을 무시하고, 뷰포트 기준으로 크기, 위치를 결정하기 때문에 글로벌 레이아웃 스타일을 무시하는 문제가 생겼다. `sticky` 속성 사용으로 해결했지만, 두 속성에 어떤 차이가 있는지 궁금했다.\n\n## 1) fixed\n\nMDN에서는 fixed 속성에 대해서 다음과 같이 설명한다.\n\n> _The element is removed from the normal document flow, and no space is created for the element in the page layout. The element is positioned relative to its initial [containing block](https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block), which is the viewport in the case of visual media. Its final position is determined by the values of `top`, `right`, `bottom`, and `left`.\n> This value always creates a new [stacking context](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_positioned_layout/Understanding_z-index/Stacking_context). In printed documents, the element is placed in the same position on every page._\n>\n> _요소는 일반 문서 흐름에서 제거되며 페이지 레이아웃에서 요소에 대한 공간이 생성되지 않습니다. 요소는 초기 포함 블록(시각적 미디어의 경우 뷰포트)을 기준으로 배치됩니다. 최종 위치는 위쪽, 오른쪽, 아래쪽, 왼쪽 값에 의해 결정됩니다._\n>\n> _이 값은 항상 새로운 스태킹 컨텍스트를 생성합니다. 인쇄된 문서에서 요소는 모든 페이지에서 동일한 위치에 배치됩니다_\n\n여기서 일반 문서 흐름이란 html로 마크업을 할 때, 위에서부터 아래로 내려오는 순서를 말한다.\n\n```tsx\n<div>1</div>\n<div>2</div>\n<div>3</div>\n```\n\n해당 마크업 구조에서 1, 2, 3이 위에서부터 아래로 순서대로 나타날 것임을 예상할 수 있다. 이는, html 태그들의 position 속성이 기본적으로 `static` 이기 때문이다. MDN에서는 staitc을 다음과 같이 설명한다.\n\n> \\*The element is positioned according to the Normal Flow of the document. The top, right, bottom, left, and z-index properties have no effect. This is the default value.\n\n요소는 문서의 일반 흐름에 따라 배치됩니다. 위쪽, 오른쪽, 아래쪽, 왼쪽 및 z-인덱스 속성은 영향을 미치지 않습니다. 이것이 기본값입니다.\\*\n\n>\n\n```tsx\n<div>1</div>\n<div>1</div>\n<div>1</div>\n<FixedHeader />\n```\n\n만약 position 속성이 fixed인 FixedHeader를 위와 같은 구조로 마크업을 하면,\n\n![](./assets/header-ignore-sequence.png)\n\n위와 같이 문서 일반 흐름을 무시해서 배치된다.\n\n일반 문서 흐름에서 벗어나기 때문에, `GlobalLayout` 컴포넌트에서 `width`, `max-width`를 설정해도 부모-자식 관계가 형성되지 않아 속성을 무시하게 되는 것이었다.\n\n## 2) sticky\n\nMDN에서는 sticky 속성에 대해서 다음과 같이 설명한다.\n\n> \\*The element is positioned according to the normal flow of the document, and then offset relative to its nearest scrolling ancestor and containing block (nearest block-level ancestor), including table-related elements, based on the values of top, right, bottom, and left. The offset does not affect the position of any other elements.\n\n요소는 문서의 일반적인 흐름에 따라 배치된 다음 위, 오른쪽, 아래, 왼쪽 값을 기준으로 테이블 관련 요소를 포함하여 가장 가까운 스크롤 조상 및 포함 블록(가장 가까운 블록 수준 조상)을 기준으로 오프셋됩니다. 오프셋은 다른 요소의 위치에는 영향을 주지 않습니다.\\*\n\n> _이 값은 항상 새로운 스태킹 컨텍스트를 생성합니다. 고정 요소는 '스크롤 메커니즘'(오버플로, 스크롤, 자동 또는 오버레이가 숨겨진 경우 생성됨)이 있는 가장 가까운 조상이 실제로 가장 가까운 스크롤 조상이 아니더라도 그 조상에 \"고정\"됩니다._\n\nsticky 속성을 가지면 기본적으로 일반 문서 흐름에 따라 배치되지만, `top` `right` `bottom` `left` 속성에 할당한 값만큼 해당 요소에 닿으면 그 후 fixed 처럼 동작하게 된다. 글로만 설명하니 이해하기 어려운 것 같다. 예시를 보자.\n\n```tsx\n<div>1</div>\n<div>2</div>\n<div>3</div>\n<StickyHeader />\n```\n\n마크업 구조가 다음과 같이 되어있고, StickyHeader의 스타일이\n\n```tsx\nposition: sticky\ntop: 0\n```\n\n위와 같다면 우선 기본적으로 일반 문서 흐름에 따라 1, 2, 3 아래에 StickyHeader가 위치한다.\n\n![](./assets/header-follow-sequence.png)\n\n스크롤을 통해서 `top : 0` 에 즉, 헤더의 가장 윗 부분에 스크롤이 닿는다면 그 후 fixed처럼 동작하게 된다. 기본적으로 일반 문서 흐름에 맞게 배치되기 때문에 부모 - 자시 관계도 형성할 수 있어, `GlobalLayout` 컴포넌트에서 설정한 width 설정을 사용할 수 있게 되었다!\n"},{"excerpt":"디자인을 하자 1차 스프린트와 해커톤이 끝난 후, 본격적으로 개발을 시작하기 전 1차 스프린트에서 해야했던 설정 중 남아 있던 설정들을 했다. 테스트 환경 설정(RTL, Storybook) 폴더구조 절대경로 설정 웹팩(webpack) 환경에서 이미지(asset)들을 사용할 수 있도록 설정 서비스에서 사용 할 폰트 설정 프론트엔드 팀 코드 리뷰 문화 결정 …","fields":{"slug":"woowacourse-level-3-3th-sprint-retrospect"},"frontmatter":{"date":"July 28, 2024","title":"우아한테크코스 레벨 3 2차 스프린트 회고","tags":["회고","우아한테크코스"]},"rawMarkdownBody":"\n## 디자인을 하자\n\n1차 스프린트와 해커톤이 끝난 후, 본격적으로 개발을 시작하기 전 1차 스프린트에서 해야했던 설정 중 남아 있던 설정들을 했다.\n\n- 테스트 환경 설정(RTL, Storybook)\n- 폴더구조 절대경로 설정\n- 웹팩(webpack) 환경에서 이미지(asset)들을 사용할 수 있도록 설정\n- 서비스에서 사용 할 폰트 설정\n- 프론트엔드 팀 코드 리뷰 문화 결정\n\n위 작업들을 모두 하니, 어느새 한 주가 모두 끝나버렸다. (~~큰일이야...~~) 우테코 미션은 대부분 `package.json` 설정이 되어 있는 상태였기 때문에 프로젝트 환경 설정에 신경을 쓰기 보다는 미션에서 주어지는 문제를 '잘' 해결하는 것에 신경을 써야했다. 하지만 레벨 3 프로젝트를 진행하면서 부터는 아예 비어있는 폴더, 파일들을 채워가야 했다. `npm init` 부터, 프로젝트를 진행하기 위한 의존성들을 추가하고 동작을 확인하는 것 까지 모든 것에 신경을 써야했다. 설정을 하고 동작을 확인하고 다음으로 넘어가는 것이 아닌, 설정을 하는 과정에서 설정 파일의 특정 속성이 왜 필요하고, 어떤 역할을 하는 것인지 의문을 가지고 그 의문을 해결하기 위해 이것저것 알아보니 시간이 정말 많이 지났다. 설정의 모든 속성을 이해하는 것이 문제 해결을 잘 하고, 서비스를 잘 만드는 것이라고는 할 수 없겠지만 처음부터 설정을 하다보니 중간중간 궁금증이 생겼고 속성들을 알아가는 것이 재밌어서 계속 알아보려고 했따. 팀원들도 나와 비슷한 성향이라서 모든 속성들을 다 함께 탐구하느라 1차 스프린트에 프로젝트 환경 설정을 마쳐야 했는데, 모든 설정을 끝내니 어느새 2차 스프린트의 첫 주가 지나버렸다. (~~공원이 차라리 대학원에 가는 것이 어떻냐고도 했었다...ㅋㅋ~~)\n\n2차 스프린트에서는 사용자에게 다음과 같은 경험들을 제공하기로 했다.\n\n### 약속 주최자는 약속을 생성할 수 있다.\n\n약속 주최자는 약속을 생성한 후, 약속 참여자들을 해당 약속에 초대할 수 있는 경험을 제공하기로 했다. 약속을 생성할 때는\n\n- 약속 이름\n- 약속 주최자의 정보 (닉네임, 비밀번호)\n- 약속 날짜의 범위 ex) 07/22 ~ 07/26\n- 약속 시간의 범위 ex) 오전 10시 ~ 오후 6시\n\n위 정보들을 받기로 했으며, 약속 정보들을 입력하고 약속을 생성하면 참여자들을 초대할 수 있는 링크를 생성해주기로 했다.\n\n### 약속 주최자, 참여자 모두 약속 시간 현황을 조회할 수 있다.\n\n약속 주최자와 초대 링크를 받은 참여자들이 약속 시간 현황을 조회할 수 있는 경험을 제공하기로 했다. 해커톤에서는 약속에 참여하는 사람을 1명으로 가정하고, 참여할 수 있는 시간을 표시, 수정, 공유할 수 있도록 했다면 이번 스프린트에서는 약속에 참여하는 n명의 사람들 모두에게 참여할 수 있는 시간을 표시, 수정, 공유할 수 있도록 해줘야 했다.\n\n### 약속 주최자, 참여자들은 1명에 대한 시간만 조회할 수 있다.\n\n우리 서비스의 핵심, 해결하려고 하는 문제에 대해서 다시 한 번 언급하자면, '실제로 만남을 갖기 전 결정해야 하는 요소들을 빠르게 결정할 수 있도록 돕는 것'이다. 만남을 갖기 전 결정해야 하는 요소를 시간, 장소 크게 두 가지로 다시 나눴고 현재는 시간과 관련된 의사 결정 문제를 해결하고 있다. '빠르게 결정할 수 있도록 돕는 것'이 핵심이기 때문에, 어떻게 하면(HOW?) 더 빠르게 결정할 수 있도록 도와줄 수 있을까에 대해서 회의에서 이야기를 한 결과, 약속에 참여하는 전체 n명 중 특정 1명이 선택한 시간을 보여준다면 도움을 줄 수 있을 것 같다는 이야기가 나왔다. 링크를 전달받은 사용자 입장에서 생각해 보면, 약속에 참여하는 사람 중 유독 심리적으로 가까운 사람이 있을 것이고 전체 현황이 다 궁금하기 보다는 그 사람이 선택한 시간을 우선적으로 궁금해할 수도 있을 것이라는 생각에서 출발한 아이디어였다. 그래서 1명에 대한 시간만 필터링해서 보여줄 수 있는 기능이 있다면, 의사 결정을 더 빠르게 할 수 있도록 도와줄 수 있을 것이라고 결론을 내리고 기능을 추가하기로 했다.\n\n이제 프로젝트를 위한 환결 설정이 다 끝났고, 2차 스프린트에서 무엇을 해야 할 지도 결정이 났는데... 피그마가 백지였다. 머릿속으로는 어떤 기능들을 개발해야 할지에 대한 그림은 그려졌는데, 막상 눈 앞에 보이는 것이 아무것도 없으니 개발을 시작하기가 어려웠다. 마침 공원이 열어준 휘뚜루마뚜루 디자인 수업에서 피그마 활용법에 대해서 어느 정도 알게 되어서 그 날 밤 프론트 팀원들과 함께 2차 스프린트 개발에 필요한 만큼만 디자인을 했다.\n\n![휘뚜루마뚜루 피그마 디자인 시안](./assets/momo-design.png)\n\n2차 스프린트에서 제공해줘야 하는 경험 목록들을 바탕으로 약속 생성 페이지, 약속 조회 페이지를 만들었고 특정 약속 참여자들 필터링하기 위한 버튼도 추가했다. 디자인이 끝난 다음 날, 백엔드 팀원들과 전체 회의를 했고 디자인을 바탕으로 API 엔드포인트, 데이터 스키마(생김새)등등 기능을 만들어가기 위한 이야기를 나눴다. 이 때, 프론트든 백엔드든 상관없이 눈에 보이는 무언가라도 있어야 이야기가 좀 통한다고 느꼈다. 흰 화면에서 서로의 머릿속에 있는 페이지나 컴포넌트들을 이야기했을 때만 해도, 상대방이 어떤 이야기를 하는 것인지 이해가 되지 않을때가 있었는데 완벽하지는 않지만 어느 정도 디자인이 된 화면을 손으로 가르키면서 의견을 말하니 확실히 이해가 잘 되었다. 백엔드 팀원들도 눈에 보이는 화면이 어느 정도는 있어야 API 설계를 할 때 도움이 된다고 말하기도 했었다.\n\n## 달력을 만들자\n\n만들어진 피그마 디자인 시안을 바탕으로 낙타, 빙봉과 어떤 페이지, 컴포넌트를 개발해야 할 지에 대해 이야기를 나눴고,\n\n- 컴포넌트\n\n  - 약속을 생성하는데 필요한 입력 필드 컴포넌트\n  - 날짜를 입력하는데 필요한 달력(DatePicker) 컴포넌트\n  - 약속 생성, 수정, 등록에 사용되는 버튼 컴포넌트\n  - 약속 시간 조회 페이지에서 특정 참여자를 필터링 할 수 있는 탭 버튼 컴포넌트\n\n- 페이지\n  - 약속 생성 페이지\n  - 약속 시간 조회 페이지\n\n위와 같이 나눌 수 있었다. 나는 우선 달력 컴포넌트 개발을 맡았다. 달력 컴포넌트를 개발할 때, '달력 컴포넌트를 만드는 것'을 문제로 정의하고 레벨 2에서 배운 핵심 사고 방식인 '결국 내가 뭘 하려고 하는 것인가?'를 적용했다. 아래는 달력을 만들어 갈 때 과정을 정리한 내용이다 :)\n\n### 이 이슈에서 결국 내가 하려고 하는 것?\n\n여러 날짜가 선택 가능한 달력 UI를 구성하기.\n\n### 핵심을 1줄로 정리하기\n\n사용자는 달력 UI에서 선택하고 싶은 여러 날짜를 선택할 수 있다.\n\n달력 UI 요구 사항 더 세밀하게 분석해봤을 때, 다음과 같이 정리할 수 있다.\n\n### 달(Month)\n\n![](./assets/calendar-month.png)\n\n달(Month) UI는 다음과 같은 역할을 수행해야 한다.\n\n- 사용자가 선택한 현재 달(month)을 `YYYY년 MM월로` 표시한다.\n\n  - 년(year) 정보는 4자리 숫자로, 월(month) 정보에서 1의 자리 숫자 앞에 `0` prefix를 사용하지 않는다.\n\n- `<`, `>` 버튼을 클릭하여 현재 달을 변경할 수 있다.\n\n  - `momo` 에서 사용하는 달력에서는 과거의 달(month)로 이동할 수 없도록 한다.\n\n- 현재 달(month)의 상태에 따라서 날짜(Day) 정보가 변경되어야 한다.\n\n### 날짜(Day)\n\n![](./assets/calendar-day.png)\n\n날짜(Day) UI는 다음과 같은 역할을 수행해야 한다.\n\n- 자바스크립트의 `Date` 객체를 사용하여 해당 달(Month) 정보에 맞는 날짜 정보들을 표시해야 한다.\n\n  - 요일을 표현하는 UI를 구현한다.\n\n- 일요일과 공휴일은 빨간색으로 표시해야 한다. 아래와 같은 형태로 구성해야할 듯 하다.\n\n```tsx\n<Day isHoliday={true or false} />\n```\n\n### 클릭 이벤트 처리\n\n![](./assets/calendar-click-event.png)\n\n- 사용자가 날짜를 클릭하면 해당 날짜의 배경 색을 accentColor로 변경한다.\n\n```jsx\n<Calendar accentColor=\"#123456\" />\n```\n\n- 달력 UI를 사용하는 측에서 관리하는 클라이언트 상태에 해당 날짜를 포함시킨다.\n\n```jsx\nconst selectedDates = [\"2024-07-23\", \"2024-07-24\", , , ,]\n```\n\n위와 같이 정리를 하니 내가 무엇을 해야 하는지 확실히 정의를 내리고 작업을 시작할 수 있었다. 달(month)를 변경시키는 작업은 꽤 난이도가 있다고 생각해, '현재 `momo` 달력은 7월 밖에 보여주지 않는다'라고 가정한 후 7월 달력이라도 동작하는 것을 확인하기로 했다. 동작을 확인한 후 다음, 이전 달로 넘어가는 기능을 추가했다. 7월의 시작일이 1일이라서 1일이 시작일이 아닌 달에 대한 예외 처리를 생각하지 않았었는데, 8월로 넘기자마자 실제 달력과 내 달력이 다른 문제가 발생했었다...ㅠ\n\n이 문제를 해결하기 위해서 자바스크립트의 Date 객체를 활용해서 달(month)의 첫 번째 요일에 해당하는 인덱스 + 달의 마지막 날짜를 더한 만큼 슬롯을 생성하고 해당 슬롯의 갯수 만큼 반복문을 돌면서 인덱스가 첫 번째 요일에 해당하는 인덱스보다 작으면 빈 칸을 출력하고 그렇지 않으면 날짜를 출력하도록 했다. 처음에는 빈 칸도 `button` 태그를 사용하고 내용만 채우지 않는 방식을 사용했는데 낙타의 코드 리뷰를 통해서, 웹 접근성을 높이기 위해서는 실제로 클릭할 수 없는 요소에만 `button` 태그를 사용하는 것이 좋다는 것을 알게되었다!\n\n![낙타 짱](./assets/nakta-review.png)\n\n```jsx\nreturn isDate ? (\n  <button key={dateString} onClick={() => onDateClick(dateString)} css={s_daySlotButton}>\n    <span css={[s_daySlot(isHoliday), s_selectedDaySlot(isSelectedDate)]}>{date}</span>\n  </button>\n) : (\n  <div key={dateString} css={s_daySlotButton}></div>\n```\n\n그래서 날짜를 표시해야 하는 경우에만 `button` 태그를 사용하도록 했다. [PR](https://github.com/woowacourse-teams/2024-momo/pull/68)\n\n## 시간 조회, 수정 페이지 구현\n\n해커톤에서 약속 참여자를 1명이라고 가정했다면, 2차 스프린트에서는 n명 참여자들의 약속 현황을 조회하고 특정 참여자의 시간만 조회할 수 있도록 해야했다. 시간을 조회, 공유, 수정하는 기능은 해커톤에서 정의한 우리 서비스의 가장 핵심이 되는 기능이었고 어느 정도 구현이 되어있는 기능이었기 때문에 1명에서 n명으로 달라진 상황에 대해서만 처리해주면 됐다. 사용자가 전체 참여자들을 조회하는 경우와 특정 참여자를 필터링해서 조회하는 경우, 데이터를 다른 형태로 전달받기로 백엔드 팀원들과 결론을 내렸다.\n\n- 전체 참여자\n\n```\n{\n  \"data\": {\n    \"schedules\": [\n      {\n        \"date\": \"2024-07-24\",\n        \"time\": \"13:00\",\n        \"attendeeNames\": [\"해리\", \"낙타\", \"빙봉\"]\n      },\n      {\n        \"date\": \"2024-07-24\",\n        \"time\": \"14:00\",\n        \"attendeeNames\": [\"낙타\", \"빙봉\"]\n      },\n      ,,,\n    ]\n  }\n}\n```\n\n전체 참여자를 조회하는 경우에는 특정 시간을 선택한 참여자들의 이름을 배열로 전달해주기로 했다. 이렇게 배열로 전달해준 이유는, 3차 스프린트에서 특정 시간을 클릭하면 해당 시간을 선택한 사용자들을 툴팁 UI 형태로 보여주기로 했기 때문이다.\n\n![](./assets/tooltip.png)\n\n- 특정 1명의 참여자\n\n```\n{\n  \"data\": {\n    \"attendeeName\": \"해리\",\n    \"schedules\": [\n      {\n        \"date\": \"2024-07-25\",\n        \"times\": [\"12:00\", \"13:00\", \"14:00\"]\n      },\n      ,,,\n    ]\n  }\n}\n```\n\n특정 1명의 참여자를 조회하는 경우에는 참여자 이름과, 해당 참여자가 선택한 시간을 배열로 담아서 전달받기로 했다.\n\n해당 기능을 구현하기 위해서,\n\n- 약속 참여자들의 이름을 하나의 탭 버튼으로 만들고 해당 버튼을 클릭할 때마다 현재 참여자를 변경\n- 참여자가 달라질 때마다 서버에 해당 참여자의 시간 정보를 가져오는 API를 요청\n\n위 사고 흐름을 거쳤다.\n\n```tsx\n<section css={s_attendeesContainer} aria-label=\"약속 참가자들 정보\">\n  <button css={s_tabButton(selectedAttendee === '')} onClick={() => handleAttendeeChange('')}>\n    전체\n  </button>\n  {meetingAttendees.map((attendee) => (\n    <button\n      key={attendee}\n      css={s_tabButton(selectedAttendee === attendee)}\n      onClick={() => handleAttendeeChange(attendee)}\n    >\n      {attendee}\n    </button>\n  ))}\n</section>\n\n->\n\nconst { data: meetingSchedules } = useQuery({\n  queryKey: [QUERY_KEY.meetingSchedules, selectedAttendee],\n  queryFn: () => handleGetMeetingSchedules({ uuid, attendeeName: selectedAttendee }),\n  staleTime: 0,\n});\n```\n\n전체 코드는 아니지만, 로직의 핵심만 코드로 나타내 보자면 위와 같다.\n\n![잘 된다!](./assets/meeting-filter.gif)\n\n## 2차 데모데이 준비...해치웠나?\n\n지금까지 2차 데모데이를 준비하면서 어떤 일(WHAT?)을 했는지 나열했다. 이 일들이 과연 척척 잘 되었는가에 대해서 이야기 해보자면 **전혀 그렇지 않았다**라고 할 수 있다.\n\n### 잠을 잡시다!\n\n![.....](./assets/2th-retrospect.png)\n\n2차 데모데이가 끝나고 KPT 회고를 했는데, 내용의 절반이 수면에 관한 이야기이다. (~~좀 처참하다...ㅋㅋ~~) 회고 제일 첫 부분에 1차 스프린트에서 다 하지 못한 프로젝트 설정을 하느라 2차 스프린트의 첫 주를 써버렸다고 했었다. 매 스프린트마다 2주가 주어지는데 설정에 1주일을 더 썼다는 것은 위에서 언급한 기능 구현들을 1주일 아니 5일만에 했다는 뜻이 된다. 디자인에 1일을 썼고, 금요일 데모데이는 사실 상 개발을 하는 날이 아니니 실제로 2주동안 개발을 한 날은 화, 수, 목 3일이었다. 3일 안에 낙타, 빙봉 그리고 나는\n<br/>\n\n- 약속 생성 페이지 구현\n- 약속 링크 공유 페이지 구현\n- 약속에 참여하지 위한 로그인 기능 구현\n- 약속 조회 페이지 생성 및 특정 참여자 약속 참여 시간 필터링 기능 구현\n- 위 모든 기능에 대한 API 연결\n\n회고를 하는 지금에도 어떻게 해냈는지...\n코치님들께서는 구현적인 부분, 기술적인 부분에 대해서 칭찬을 해주셨는데 3일동안 3-4시간을 자면서 구현했다고 말씀 드리면 칭찬을 다시 회수하시지 않을까...생각했다. 3일안에 다 구현을 못할 것 같아, 낙타, 빙봉은 여기서 걷어낼 수 있는 부분은 걷어내자고 했지만 나는 생각보다 어렵지 않은 기능들이라 충분히 할 수 있다고 의견을 냈다. 2차 스프린트에서 구현하기로 한 기능들이라 해야할 것 같다는 생각으로부터 비롯된 의견이었다. 레벨 2에서는 개발과 일상을 구분하고 일상을 잘 느끼기 위한 노력들을 했는데, 마감 기한이 다가오니 레벨 2에서 연습한 유연함이 사라져버렸다. 결국 내 의견을 수용해줘서 위 모든 기능들을 구현하기로 했고, 막상 해보니 3일안에 해내기에는 벅찬 기능들이었다. 그래서 수면을 줄여가며, 퇴근을 해도 게더에 모여서 함께 개발을 진행했다. 피로가 누적되다 보니 데모데이 당일에 낙타, 빙봉의 컨디션이 정말 좋지 않았고 괜히 나 때문에 그렇게 된 것 같아 정말 미안했다...😭 적당한 열정이 장기적인 관점에서는 더 좋다고 느꼈다.\n\n### 백로그를 활용해 봅시다!\n\n나를 포함한 팀원들 모두가 바빠지면, 각자의 작업에 집중하느라 자연스럽게 다른 팀원들이 현재 어떤 작업을 집중해서 하고 있는지 잘 알기가 힘들다는 생각이 들었다. 그래서 2차 스프린트 1주차 주말에 팀원들 모두가 백로그를 잘 활용해보면, 서로의 작업에 대해서 빠르게 파악을 할 수 있을 것 같다는 생각을 했다. 2주차 월요일에 백로그 템플릿을 만들어서 팀원들에게 공유했고, 한 번 사용해보자는 제안을 했다. 팀원들이 흔쾌히 나의 의견을 수용해줘서 고마웠다!\n\n![](./assets/backlog.png)\n\n내가 제안한 백로그 템플릿은 위와 같다.\n\n- 에픽 : 에픽은 여러개의 스토리로 나뉠 수 있는 대규모 작업이다. 추상화 단계가 가장 높게 표현된다.\n- 스토리 : 사용자 관점에서 표현한 기능에 대한 설명이다.\n- 태스크 : 사용자에게 특정 스토리를 제공해주기 위해서 어떤 작업(WHAT?)을 해야하는지 세분화해서 작성한다. 추상화 단계가 가장 낮게 표현된다.\n\n내가 제안한 백로그 템플릿은 프론트엔드, 백엔드 구분 없이 전체 팀 단위로 작성하는 것이었고 사용자에게 특정 경험을 제공해주기 위해서 우리 팀 전체가 어떤 노력을 하고 있는지를 빠르게 파악할 수 있다는 장점이 느껴졌다. 물론 단점도 있었다. 1개의 작업을 시작하면, 이슈를 파고 작업이 끝나면 PR Description도 작성하는데 백로그까지 작성한다면 글 작성에 너무 많은 시간을 사용하게 된다는 것이다. 하지만, 백로그에는 특정 작업(태스크)를 어떻게 진행했는지에 대해 기록하거나 트러블 슈팅을 기록하는 연습장으로 활용할 수 있기 때문에 다른 사람들이 어떻게 작업을 진행했는지 자세히 알고 싶다면 해당 백로그 페이지를 방문하면 소통이 더 쉬워질 수 있다고 생각했다. 앞으로 남은 스프린트 기간에도 적극적으로 활용해 봐야겠다.\n\n### 업무 알람 자동화를 해봅시다!\n\n![](./assets/kakao-alarm.png)\n\n2차 스프린트를 준비하면서 특정 작업이 마무리 되어 PR을 날리거나, 코드 리뷰(Changes Request)를 하면 카톡으로 연락을 주고 받았다. 매 번 이렇게 연락을 주고 받는 것이 너무 불편하다고 생각해, 다음 스프린트부터는 슬랙 or 디스코드의 웹 훅(Web Hook)을 활용해서 특정 작업에 대해 알람이 오도록 해야겠다고 느꼈다. (~~내 카톡을 불태울 수 없다...~~)\n\n## 2차 스프린트를 진행하면서...\n\n2차 스프린트를 진행한 2주동안 꽤 많은 것을 느꼈다.\n\n- 팀원 전체가 문제를 해결하는 방법들에 대해 의견이 정리 되었고, 기능이 도출되면, 다음 이야기를 하기 위해서 가장 작은 버젼의 디자인이라도 필요하다는 것. 즉, 눈에 보이는 것도 소통에 많은 영향을 준다는 것\n\n- 급박한 상황이 오면 유연함이 점점 없어진다는 것. 이건 개발에만 해당되는 내용이 아니라 앞으로 살아가면서 정말 많이 느낄 것 같다.\n\n- 장기전에는 적당한 열정이 필요하다는 것\n\n- 나를 제외한 7명의 팀원들이 현재 무엇을 하고 있는지 모두 파악하기는 힘들지만, 필요할 때 빠르게 찾아볼 수 있는 방법을 고민해본 것\n\n- 업부 알람 자동화가 정말 필요하다는 것\n\n그냥 '음... 이런 것 느꼈군!'하고 넘기지 않고 개선하기 위해 의식적으로 노력하며 3차 스프린트를 맞이해 봐야겠다 :)\n"},{"excerpt":"해커톤을 한다구요…?  레벨 3 프로젝트 1차 스프린트에 대한 데모데이가 종료되고, 팀원들과 1차 스프린트에 대한 회고를 하는 중 슬랙에 포비가 다음 주 월요일에 우테코만의 해커톤을 진행한다는 공지를 올리셨다. ‘엥…? 갑자기 해커톤? 띠용…’ 했지만 대수롭지 않게 생각하고 스프린트 회고를 진행했다. 우테코를 시작하기 전 GDSC 동아리에서 주최한 해커톤…","fields":{"slug":"woowacourse-level-3-hackathon-retrospect"},"frontmatter":{"date":"July 18, 2024","title":"우아한테크코스 레벨 3 해커톤 회고","tags":["회고","우아한테크코스"]},"rawMarkdownBody":"\n## 해커톤을 한다구요…?\n\n![](./assets/announce.png)\n\n레벨 3 프로젝트 1차 스프린트에 대한 데모데이가 종료되고, 팀원들과 1차 스프린트에 대한 회고를 하는 중 슬랙에 포비가 다음 주 월요일에 우테코만의 해커톤을 진행한다는 공지를 올리셨다.\n\n‘엥…? 갑자기 해커톤? 띠용…’ 했지만 대수롭지 않게 생각하고 스프린트 회고를 진행했다. 우테코를 시작하기 전 GDSC 동아리에서 주최한 해커톤에 참여했을 때 밤을 새면서 코딩을 한 후 체력적으로 너무 지쳐서 앞으로 특별한 일이 없는 한 해커톤에 참여하지 않겠다고 다짐했었다. 그렇기에 월요일에 진행하는 해커톤에서도 밤은 절대로 새지 않을 것이라고 생각했고, 밤 새기 싫다고도 말했다.\n\n??? : 해커톤 참여는 필수인데, 밤 새는건 필수 아니라는데? ‘에이…설마 또 밤 새겠어?’ 나 집 일찍가서 잘건데?\n\n하지만 정말 큰 플래그를 세워버렸다. 다시는 밤을 새지 않겠다는 다짐과 선언들이 이번 해커톤에서 전혀 소용이 없었다.\n\n지금 이 회고 글도 캠퍼스에서 2시간 잠시 눈을 붙인 것을 제외하고는 밤을 꼴딱 샌 직후 작성하고 있다…\n\n![](./assets/kakaotalk.png)\n\n혹시 몰라서 팀원들에게 밤을 샐 의향이 있는지 물었는데, 아무 말 없이 슬픈 이모지가 달렸다. 이것도 플래그 였을까? 우리 팀의 절반이 거의 해가 뜰 때까지 캠퍼스에 남아있었고, 먼저 집으로 귀가한 팀원들도 게더에서 열심히 새벽까지 해커톤에 참여했다.\n\n(’앞으로 밤을 절대 새지 않을 것이다’와 같은 단언은 하지 말아야겠다.)\n\n## 해커톤 OT : 요구사항 소개\n\n![wow...!](./assets/ot.png)\n\n해커톤 첫 날 오후 2시 해커톤의 목표와 함께 요구사항이 소개되었다.\n\n> _레벨 3에서 만들 우리 서비스의 모습을 팀원들과 함께 그려보고 가장 핵심이 되는 기능 1개를 선정해 24시간 안에 개발, 시연한다._\n\n요구사항을 보자마자 ‘또 우리를 극한의 야생으로 던지는구나…’라고 생각했고 가방을 싸고 그대로 다시 집으로 가고 싶었다. 밤을 새는 것은 필수가 아니라고 했지만, 뭔가 밤을 샐 것 같다는 느낌이 왔고 그 느낌은 정확이 들어맞았다.\n\n![요구사항을 보자마자 노션 페이지에 적었던 말…](./assets/diary.png)\n\n1차 스프린트 데모데이에서 코치분들에게 소개한 우리 팀 프로젝트의 핵심 중의 핵심은 **약속에 참여하는 사람들이 자신의 시간을 공유하고 다른 사람들의 시간을 확인할 수 있도록 하는 것**이었다. 테이블 UI를 활용해서 시간을 드래그해서 표시할 수 있도록 하고, 시간 데이터를 포매팅해서 서버에 보낼 수 있도록 해야 했는데, 1차 스프린트에서 디자인 작업을 전혀 하지 않았어서 디자인과 드래그 기능을 24시간 안에 구현해야 했다. 심지어 드래그 기능은 이전에 한 번도 구현해 본 적이 없어 너무나도 막연했다. 이런 막연함이 자연스럽게 ‘아…나 밤 새겠다’라는 생각으로 이어졌다.\n\nOT가 끝난 후, 어차피 밤을 샐 것 같으니 이 때부터 즐기자는 마인드로 해커톤에 임했다.\n\n![](./assets/snack.png)\n\n간식들도 많이 챙겨 주셨고, 이 날이 초복이라서 치킨과 피자도 시켜주신다고 하셨다! 맛있는거 먹으면서 즐겁게 해커톤 해보자~ 라고 생각했다.\n\n## 핵심을 구현해 봅시다, 핵심!\n\n우리 팀 프로젝트의 핵심 기능인 “**약속에 참여하는 사람들이 자신의 시간을 공유하고 다른 사람들의 시간을 확인할 수 있도록 하는 것”**을 24시간 안에 구현하기 위해서 제한 시간내에 구현할 수 있는 가장 작은 버전에 대해서 이야기를 나누었다.\n\n팀원들과 이야기를 많이 나누면서 약속을 생성하는 것, 약속에 참여하는 사람들이 같은 페이지에서 시간을 표시하도록 하기 위해서 공유 링크를 생성하는 것, 가장 많은 인원이 만날 수 있는 약속 시간 추천 등과 같은 기능들은 있으면 좋은 기능이긴 하나 **진짜 핵심**은 아니라고 판단했다. 진짜 핵심은 시간 표시, 수정, 공유라고 생각했기에\n\n- 홈페이지가 약속에 참여할 수 있는 시간을 표시하고 수정할 수 있는 페이지라고 가정한다.\n- 약속에 참여하는 참여자는 `momo` 1명이라고 가정한다.\n- 시간을 확인해야 하는 날짜의 범위는 일주일이라고 가정한다.\n\n위와 같은 가정들을 세우고 핵심을 포함하는 가장 작은 버젼을 이번 해커톤에서 구현하기로 결정했다.\n\n레벨 2에서 가장 많이 강조됐던 사고 방식인 ‘결국 우리가 무엇을 하려고 하는 것인가?, 내가 제공해주려고 하는 가치가 핵심을 포함한다고 가정했을 때 동작이 가능한 가장 작은 버젼은 뭐지?’가 이번 해커톤에서 핵심을 포함하는 기능을 뽑아내는데 많은 도움이 되었다.\n\n([해커톤을 위한 이슈](https://github.com/woowacourse-teams/2024-momo/issues/6))\n\n내가 속한 프론트 팀에서는\n\n1. 시간을 표시할 수 있는 페이지, UI를 구성한다.\n2. 약속에 참여할 수 있는 시간을 표시, 수정할 수 있는 기능 제공한다.\n3. 서버가 사용자가 가능한 시간을 저장할 수 있도록 한다.\n\n위 3가지 태스크를 수행해야 했다.\n\n### 1) 시간을 표시할 수 있는 페이지, UI를 구성!\n\n![](./assets/design.png)\n\n1차 스프린트를 준비했던 2주 동안, 디자인 작업을 전혀 하지 않았어서 피그마를 급하게 만들고 호다닥 디자인을 마무리 했다. 30분 단위로 시간을 표시할 수 있도록 해주려고 했지만, 이 방법을 사용할 경우 시간을 선택할 수 있는 박스들이 너무 많아져서 해커톤에서는 1시간 단위로 표시할 수 있도록 했다.\n\n우리 팀 이름은 ‘모두 모여’를 줄여서 ‘모모’이고, 모모가 일본어로 복숭아를 뜻하는 단어여서 메인 컬러를 분홍색으로 잡았고, 강조해야 하는 영역에 메인 컬러를 사용하기로 했다.\n\n(~~다 만들고 한 생각 ‘오…잘 만들었는데?’ 집에 일찍 가겠는데?~~)\n\n![또 먹고싶네...🤤](./assets/chicken-pizza.png)\n\n디자인을 완성한 후, 치킨 & 피자를 먹을 때만 해도 행복했다…\n\n??? : 먹고 빠르게 기능 쳐내고 집 ㄱ?\n\n??? : 오 좋은데, 빨리 끝나면 롤 ㄱ?\n\n라는 대화도 오갔다.\n\n### 2) 약속에 참여할 수 있는 시간을 표시, 수정할 수 있는 기능 제공!\n\n급하게 완성된 디자인 시안을 바탕으로 컴포넌트를 구성하고 드래그로 시간을 표시하는 기능을 추가해야 했다.\n\n우리가 제공해줘야 하는 기능을 세세하게 분석해 봤을 때 다음과 같았다.\n\n<details>\n<summary>요구 사항 분석 보기</summary>\n<div markdown=\"1\">\n\n## 큰 틀에서 요구 사항 분석하기\n\n1. 클릭, 드래그 이벤트를 모두 지원할 수 있어야 한다.\n\n⇒ 브라우저의 경우 MouseEvent, 모바일의 경우 TouchEvent를 사용한다.\n\n2. value의 타입은 아직 미정이지만 현재 구현은, `boolean[][]` 이어야 한다.\n\n⇒ `boolean[][]` 자료구조를 사용할 지, 날짜 데이터가 담긴 자료구조를 사용할 지는 미정이다.\n\n### 클릭 기능 요구 사항\n\n1. false → click → true 안\n\n2. true → click → false\n\n⇒ 클릭은 이벤트 시작 셀과 종료 셀이 같다.\n\n### 드래그 기능 요구 사항\n\n1. 테이블 내부에 존재하는 임의의 한 셀이 출발 셀이라고 가정했을 때, **사용자가 드래그를 종료하는 마지막 셀** 까지 다음의 동작을 만족해야 한다.\n\n⇒ 출발 셀 값을 x라고 가정했을 때, 출발지 → 목적지 좌표 사이에 존재하는 모든 셀의 값은 !x가 되어야 한다.\n\n⇒ 선택된 시간을 취소할 때, 취소하고자 하는 영역을 벗어나서 새로운 시간을 추가 할 수는 없다.\n\n2. 드래그를 시작하고, 드래그를 하면서 지나온 영역을 다시 되돌아 갔을 때 시간 선택도 되돌릴 수 있어야 한다.\n\n</div>\n</details>\n<br/>\n\n요구사항을 차분히 분석 한 후, 진짜 어려운 문제를 해결하고 있다는 것을 깨달았다. 아무래도\n\n전체 기획 ⇒ 스프린트 단위로 기능 나누기 ⇒ 나눈 기능 가운데에서도 핵심\n\n이 순서대로 해커톤에서 구현해야 하는 기능이 결정되었다 보니, 핵심중에 핵심을 뽑게 되었고, 자연스럽게 구현해야 하는 기능의 난이도가 올라갔다. 해커톤에서 만들어야 하는 요구사항을 제대로 분석했을 때는 이미 캠퍼스를 나갈 수 있는 시간인 11시를 벗어났었고, 집중할 수 있는 체력도 거의 다 써버려서 ‘이거 24시간안에 해결할 수 있는 문제가 맞았나?’하는 의심을 하기 시작했다.\n\n하지만 집에 가지 않기로 마음 먹은 이상, 어떻게든 동작하는 쓰레기라도 만들어보자는 생각을 했다! 가보자고!\n\n![텅...](./assets/room.png)\n\n우리와 비슷한 기능을 구현하셨던 분들이 정리해주신 여러 블로그를 참고해서, `useRef` 훅을 활용해서 테이블 정보를 저장하고 2차원 배열을 순회하면서 시간을 표시 하는 방식으로 구현했다!\n\n![](./assets/draggable-timatable.gif)\n\n수정하기 버튼을 누를 때만 드래그를 통해서 시간을 표시 할 수 있도록 하는 기능도 추가했다!\n\n### 3) 서버가 사용자가 가능한 시간을 저장할 수 있도록!\n\n사용자가 약속에 참여할 수 있는 시간을 표시하면, 저장할 수 있도록 서버에 데이터를 전송해줘야 하는 일이 남았다.\n\n서버 상태를 관리하기 위한 방법에 대해서 빙봉, 낙타와 얘기를 한 후 빠르게 리액트 쿼리를 사용하기로 결정했다. 모두가 레벨 2 리액트 과정에서 이미 사용해본 적이 있는 라이브러리라서 해커톤에서 정의한 문제를 해결하기 위한 기술로써 도입하기 위해 크게 문제가 되지 않을 것이라 판단했고, 나중에 시간 뿐만이 아닌 날짜 상태도 관리해야 할 때가 오면 어차피 사용하게 될 라이브러리라는 맥락으로 좁혀져 빠르게 `npm install` 했다 ㅋㅋ!\n\n서버에서는 약속에 대한 데이터를\n\n```\n{\n  \"data\": {\n    \"availableDates\": [\"2024-07-16\", \"2024-07-17\", \"2024-07-18\"],\n    \"meetingName\": \"약속 이름\",\n    \"startTime\": \"00:00\",\n    \"endTime\": \"24:00\",\n    \"schedules\": [\n      {\n        \"date\": \"2024-07-16\",\n        \"times\": [\"18:30\", \"19:30\", \"20:30\"]\n      },\n      {\n        \"date\": \"2024-07-17\",\n        \"times\": [\"18:30\", \"19:30\", \"20:30\"]\n      },\n      {\n        \"date\": \"2024-07-18\",\n        \"times\": [\"18:30\", \"19:30\", \"20:30\"]\n      },\n    ]\n```\n\n위와 같은 형태로 넘겨줬다.\n\n약속에 대한 정보가 클라이언트 측으로 넘어오면\n\n- `startTime` ~ `endTime` 만큼을 열, `schedules` 배열의 길이 만큼을 행으로 크기를 가지는 2차원 테이블을 만들어 UI를 구성하고,\n- 가능한 시간이면 즉, `schedules` 배열에 포함된 시간이면 true 그렇지 않으면 false로 채워진 `boolean[][]` 형태의 2차원 배열을 만들어서 상태로 관리\n\n하는 두 가지 작업을 수행했다. 그리고, 사용자가 가능한 시간을 수정하고 `등록하기` 버튼을 클릭하면 `boolean[][]` 2차원 배열을 다시 날짜와 시간 데이터를 포함하고 있는 `schedules` 와 같은 형태로 포매팅을 한 후 서버에 POST 요청을 보내주었다. 서버에서 가져올 때, 서버에 데이터를 전송할 때 모두 데이터를 포매팅하는 과정이 있어서 이 작업에 대한 오버헤드가 크다고 생각했었다… 자바스크립트의 `includes` 메서드를 사용해서 상태를 관리할 수 있었지만 매번 includes를 사용해서 배열을 순회하는 것과 데이터의 형태를 바꾸는 것의 오버헤드의 차이가 그렇게 크지는 않을 것이라고 생각했고, 남은 시간 동안 더 깔끔하고 좋은 방법을 떠올릴 수 없을 것 같아서 기존 방법을 유지하기로 했다.\n\n~~(더 좋은 방법에 대한 고민을 했을 때의 시간은 아마 오전 10시였을 것이다…)~~\n\n서버와의 연결을 확인한 후, 시연 순서를 기다렸고 우리 팀은 마지막 순서였다. 대부분의 팀이 시연자와 시연자를 도와주는 크루가 짝을 이뤄서 발표를 하러 나왔지만, 내가 우리 팀 이름 모모(모두 모여)니까 모두 나가자~ 라고 제안했고 흔쾌히 내 제안을 수락해줘서 모두가 나갔다…ㅋ\n\n어찌저찌 성공적으로 발표를 마무리 하고 램수면 상태로 집에 갔다. 팀 모모 고생했다!!! 👏🍀😊\n\n## 왜 해커톤을 한 것일까?\n\n모든 팀의 시연 발표가 마무리 된 후, 해커톤에 대해 회고하는 시간을 가졌다.\n\n> _왜 해커톤을 한 것일까요? 아무 이유 없이 했을까요?_\n\n회고 시간을 담당하셨던 코치께서 위와 같은 질문을 던지셨고, 우리는 다 같이 생각해보는 시간을 가졌다.\n\n![](./assets/my-answer.png)\n\n나는 위와 같이 대답했다. 24시간 이라는 제한된 시간 내에 우리가 구현해야 하는 핵심을 구현해야 하는 것은 말 그대로 정말 야생 그 자체였다. 해커톤의 요구사항도 미리 공개된 것이 아닌 해커톤 OT를 할 때 공개 되었고, 밤을 새지 않을 것이라 생각하고 아무런 준비도 하지 않고 캠퍼스에 출근한 결국 밤을 샜다.\n\n코치께서는 위와 같은 질문을 던지시면서 다음과 같은 말도 같이 해주셨다.\n\n> _지금까지 우테코에서 프로젝트를 진행했을 때, 핵심 가치와 벗어난 기능에 집중해서 시간과 체력을 많이 쓰는 것 같아 아쉬웠다. 예를 들어 로그인에 너무 힘을 쓰는 것.\n> 그래서 핵심은? 우리는 사용자에게 어떤 가치를? 이라는 질문에 대해서 24시간 동안 팀원들과 찐~하게 고민해보고 구현해보는 시간을 초반에 가지는 것이 좋다고 생각했다._\n\n확실히 제한된 시간 내에 핵심을 구현해야 한다는 요구사항이 있으니, 나와 우리 팀의 사고가 자연스럽게 **진짜 핵심**으로 동기화가 잘 된 것 같았다. 진짜 핵심을 정의하고 정의한 문제를 빠르게 해결하기 위해서 자연스럽게 팀원들과 정말 많은 대화를 나누고 소통한 것 같다. 우리 팀 전체가 정말 적극적이었던 24 시간이었다고 생각했다!\n\n그리고 또 이런 말씀도 해주셨다.\n\n> _일부러 우테코에서는 적절한 스트레스 상황을 만들고, 스스로의 자연스러운 진짜 모습을 팀원들에게 공개함으로써 팀원들과 빠르게 가까워지고 편해질 수 있도록 의도했다. 적절한 스트레스 상황이 없으면, 자연스럽게 가면을 쓰게 된다. 가면을 쓰는 동안 곪다가 레벨 4 마지막 쯤 터지게 되는 경우도 많이 봤다.\n> …\n> 실제 현업에서는 이런 일들이 당연히 생길 수 있다. 오늘은 이거 해야 했는데 당장 내일 갈아엎고 새로운 작업을 시작해야 할 수도 있다. 그런 상황에 적응하는 능력을 키우는 것도 중요하다._\n\n그렇다면 24 시간 동안 드러난 나의 진짜 모습 혹은 나도 몰랐던 새로운 모습이 있었을까?\n\n다른 팀원들은 어떻게 생각했을지 잘 모르겠지만, 딱히 다르거나 몰랐던 모습이 나오지는 않았던 것 같다. 평소에 시간에 대한 강박과 압박이 조금 있는 편이라, ‘제한 시간 내에 구현하지 못하면 어떡하지?’라는 생각을 중간중간 하긴 했지만, 뭔가 할 수 있을 것 같다는 느낌도 있었고, ‘못하면 뭐 어쩔 수 있나? 해커톤 끝나고 구현하면 되지~’라는 생각을 더 많이 한 것 같다. 그래서 평소처럼 노래 틀어 놓고, 중간중간 헛소리도 좀 하고, 다른 팀원들이랑 스몰 토크도 하면서 24시간을 보냈다.\n\n1차 스프린트를 준비했던 2주 동안의 팀 전체의 모습과, 해커에서의 팀 모습도 크게 다르진 않았던 것 같지만 확실히 평소보다 대화를 정말 많이 했고 소통이 더 잘 된다고도 느꼈다. (~~중간중간 텐션 스파이크 이슈로 멍을 때리긴 했지만…~~)\n\n## 우커톤(우테코 해커톤)은 나에게 어떤 의미가 있었나?\n\n해커톤이 끝나고 가장 많이 한 생각은 집에 가면서 말로도 뱉었지만, ‘이게 되네…’ 였다. 정말 핵심이라서 난이도가 높은데 24시간 안에 구현이 완료된 것을 보면서 ‘이게 진짜 24 시간내에 되는 것이었네…? ~~왜 되지…?’~~라고도 생각했다.\n\n진짜 왜 되었는지를 생각해보면, 코드 퀄리티에 대한 생각은 잠시 넣어두고 **일단 동작이라도 하도록 하는 것에 초점을 맞추었기 때문**이었다. 코드를 작성하는 중간중간 매직 넘버나, 별로인 것 같은 로직이나, 중복되는 로직 등등… 리팩터링을 하고 싶은 욕구가 정말 많았지만 그 때마다 팀원들끼리 나중에 생각해!를 외치며 일단 눈 앞에 제대로 동작이라도 하는 것에 집중했기 때문에 제한 시간 내에 가능한 것 같다. 만약, 코드 퀄리티나 기타 부수적인 것들에 집중하느라 시연을 할 때 아무것도 보여주지 못했다면 밤을 샜는데도 불구하고 구현을 하지 못했다는 생각에 오히려 더 지쳐 팀 전체의 사기도 떨어질 수 있었을 것 같다고 생각하기도 했다.\n\n해커톤이 끝나면 좋지 못한 코드들, 스스로 생각했을 때 만족하지 못한 코드들에 대해서 리팩터링을 진행해야 할 것이지만, 당장 핵심은 구현했기 때문에 해커톤이 끝나고 우리 팀의 분위기도 좋았다. **핵심을 계속해서 강조하는 이유를 이제는 진짜 알 것 같다.**\n\n![](./assets/mail.png)\n\n집에 가면서 우테코 최종 코딩 테스트 메일에 포함된 위 내용을 떠올렸다.\n\n> \\*한편으로는 소프트웨어가 제대로 작동하지 않는 경우 위의 모든 사항이 의미가 있을까요? **결국 우리가 프리코스에서 배운 것들은 소프트웨어가 제대로 작동할 때 의미가 있지 않을까요?\\***\n\n코드 퀄리티에 집중하는 것 보다, 당장 눈 앞에 주어진 문제를 해결하는 것에 집중하며 사용자에게 정말 작은 가치라도 전달할 수 있을 것 같은 가능성을 발견하는 것이 훨씬 중요하다. 우테코 생활을 하면서, ‘점진적으로 발전시켜 나간다’라는 문장이나 요구사항들을 많이 본 것 같은데 이 말이 무슨 의미인지도 해커톤이 끝나고 크게 와닿았다.\n\n**‘당장은 맘에 들지 않는 코드더라도 점진적으로 발전 시켜나가면 된다.’**\n\n**‘가장 작은 것 부터 시작해서 차근차근 쌓아가면 된다.’**\n\n와 같은 의미가 담긴 문장이 아니었을까 생각한다.\n\n또, 해커톤이 끝나고 내 모습을 너무 단정 짓지 말자고도 생각했다. 해커톤 공지가 올라왔을 때만 해도, ‘밤을 절대 새지 않을 것이다’ 라고 말했던 것도 ‘나는 밤을 새지 않는 사람이다’ 라고 단정짓는 것에 익숙했기 때문일 것이다. 스스로의 모습을 단정지으면서 살아도 갑작스러운 상황이 생기면 그 모습을 잠시 내려놓아야 하는데, 굳이 미리 단정지으면서 살아가기 보다는 그 갑작스러운 상황에 빠르게 적응하기 위해서 어떤 모습이 필요한지를 먼저 생각해 보자!\n\n해커톤 끗!\n"},{"excerpt":"🚨 아직 미완성... 🚨 0부터 시작해야 했던 프로젝트 세팅 1차 스프린트 (번외) 사혼의 구슬 스터디 : 나만의 디자인 시스템 만들어 보기 레벨 3을 대할 앞으로의 마음가짐","fields":{"slug":"woowacourse-level-3-1th-sprint-retrospect-2"},"frontmatter":{"date":"July 15, 2024","title":"우아한테크코스 레벨 3 1차 스프린트 회고 - 2","tags":["회고","우아한테크코스"]},"rawMarkdownBody":"\n🚨 아직 미완성... 🚨\n\n## 0부터 시작해야 했던 프로젝트 세팅\n\n## 1차 스프린트\n\n## (번외) 사혼의 구슬 스터디 : 나만의 디자인 시스템 만들어 보기\n\n## 레벨 3을 대할 앞으로의 마음가짐\n\n```js\nconst a = 10\n```\n"},{"excerpt":"🚨 아직 미완성... 🚨 레벨 2 방학 동안 많이 놀았어요 🤩 리액트를 학습하는 레벨 2 과정이 끝난 후, 2주 동안의 방학 동안 레벨 3을 위한 체력을 비축했다기 보다는 '레벨 3이 시작되면 다시 바빠질 텐데 언제 마음 편하게 놀 수 있을까?'라고 생각하며 정말 많이 놀았다. (노는 것도 체력이 굉장히 많이 필요하더라...) 방학 1주차에는 고향인 부산…","fields":{"slug":"woowacourse-level-3-1th-sprint-retrospect-1"},"frontmatter":{"date":"July 14, 2024","title":"우아한테크코스 레벨 3 1차 스프린트 회고 - 1","tags":["회고","우아한테크코스"]},"rawMarkdownBody":"\n🚨 아직 미완성... 🚨\n\n## 레벨 2 방학 동안 많이 놀았어요 🤩\n\n리액트를 학습하는 레벨 2 과정이 끝난 후, 2주 동안의 방학 동안 레벨 3을 위한 체력을 비축했다기 보다는 '레벨 3이 시작되면 다시 바빠질 텐데 언제 마음 편하게 놀 수 있을까?'라고 생각하며 정말 많이 놀았다. (~~노는 것도 체력이 굉장히 많이 필요하더라...~~)\n\n방학 1주차에는 고향인 부산에 내려가서 오랜만에 고향 친구들도 만나고, 부모님과 친척들도 보고, 몇몇 프론트엔드 크루들과 부산 이곳저곳을 다니며 힐링도 많이 했다! 2주차에는 다시 서울에 올라와서 내가 좋아하는 곳인 3호선 라인(경복궁, 서촌, 안국)들도 많이 다니고 4, 5기 선배님들의 프로젝트인 맛집 프로젝트 개선 작업에도 참여했다.\n\n<몇몇 사진 뽑아서 올리기>\n\n2주간의 방학을 보내고 레벨 3이 시작되었다!\n\n## 레벨 3 OT\n\n레벨 3 시작 첫 날에는 `슬기로운 레벨 3 생활`을 주제로 OT를 진행했다.\n\n![](<Screenshot 2024-07-14 at 23.05.29.png>)\n![](<Screenshot 2024-07-14 at 23.26.26.png>)\n\n우테코는 레벨 3 부터 팀 프로젝트를 시작한다. 레벨 5 까지 진행되는 우테코 전체 과정에서 레벨 3 부터 팀 활동을 시작하는게 이르다고 느껴질 수 있다. 이에 대해서 포비는 다음과 같이 말씀해 주셨다.\n\n> _팀 프로젝트를 레벨 3부터 시작하는 이유가 있다. 팀 프로젝트를 잘 하기 위해서는 시간이 꽤 오래 걸린다. 긴 시간 동안 찐~한 협업 경험을 했으면 좋겠는 마음에 레벨 3부터 팀 프로젝트를 시작하는 것으로 결정했다. 앞으로 남은 기간 동안 찐~한 협업 경험을 할 수 있는 의미있는 시간이 되었으면 한다._\n\n> _새로 만난 팀원들과 활동을 시작하면서 너무 내 모습을 숨기지 말고, 너무 다른 사람에게 맞춰주려고 하지 말고, 나의 진짜 모습 있는 그대로의 모습을 보여주려고 노력하면 더 많이 성장할 수 있을 것이다. 사회에 나가서 나의 진짜 모습을 찾으려고 하기 보다, 사회에 나가기 전 우테코에서 협업을 할 때 발견할 수 있는 자신의 진짜 모습을 반견할 수 있었으면 좋겠다._\n\n레벨 1이 끝난 후, 일주일의 방학 동안 `함께 자라기` 책을 읽으면서 책이 전달해주려고 하는 메시지에 어느 정도 공감했었고 **분업 보다는 협업**이 중요하다는 사실도 깨달았다. 그리고, **분업이 아닌 협업을 하는 개발자**가 되고 싶다는 생각도 했다.\n\n하지만, 단순히 분업이 아닌 협업을 하고 싶다는 생각만으로는 책에서 말하는 협업에 다가가기 힘들 것이고, 눈 앞에 어떤 현실을 마주하게 될지도 모르기 때문에 내가 진짜 협업을 할 수 있을까에 대한 의구심도 들었었다. 더군다나 지금까지 학습이나 프로젝트를 하면서 찐~한 협업 경험을 해본적은 없기 때문에, 추상적으로 느껴지는 찐~한 협업이라는 것을 내가 팀 프로젝트를 하는 레벨 3, 4 동안 할 수 있을지에 대한 막연함도 생겼다.\n\n포비께서 추가로 해주신 말씀을 듣고, 내가 과연 찐~한 협업을 할 수 있을지에 대한 의심에 대해서 너무 복잡하거나 깊게 생각하지 않기로 했다.\n\n> _실전은 아니니까 얼마든 실수해도 괜찮다._\n\n실수하는 것을 두려워 하기 보다는, 언제든 실수는 할 수 있는 것이라 생각하고 실수를 통해 하나라도 배울 점을 찾는 팀원이 되기를!\n\n![](<Screenshot 2024-07-14 at 23.12.30-1.png>)\n\n레벨 3, 4에서 우리의 모습은 현장 재직자의 모습과 굉장히 비슷할 것이라고도 말씀해 주셨다.\n\n> _근무 시간(팀 활동 시간)에는 지금까지 쌓아온 나의 역량을 발휘하고, 근무 시간이 아닐 때는 개인의 성장을 위한 학습을 하는 시간을 갖는 싸이클일 것이다. 근무 외 시간에 나의 개인적인 성장을 위한 준비를 해야한다. 시간 관리 연습도 해봤으면 한다._\n\n포비의 말씀을 듣고 시간 관리 연습을 해보고 싶다는 생각이 들어 매주 월요일 진행하는 유강스(유연성 강화 스터디)의 목표를 **개인의 성장을 위한 시간과, 팀의 성장을 위한 시간 ‘잘’ 구분하기**로 정했다! ([유강스 목표를 정하려다가 개인 회고를 하게 되었다.](https://hwinkr.github.io/2024-07-08/))\n\n그리고 팀 프로젝트를 진행하면서 의외로 문제가 많이 발생할 수 있는 영역에 대해서도 조언을 해주셨다.\n\n![역할과 책임이 명확하지 않은 영역들](<Screenshot 2024-07-14 at 23.42.42.png>)\n\n위 이미지에서도 확인할 수 있듯, 요구사항 분석, 화면 설계서 작성, 디자인, 개발, 테스트는 같은 문제를 해결해 가는 팀원 모두가 **해야 하는 일**임을 모두가 알고있다. 그래서 해당 일들을 진행하면서는 문제가 발생할 확률이 적다.\n\n> _하지만 애매한 영역 즉, '이게 우리에게 꼭 필요한 것일까?', '내가 아닌 누군가가 하지 않을까?'와 같은 생각이 드는 영역에서 의외로 문제가 많이 발생한다.  \n> 예를 들어 회고 & 피드백과 같은 팀의 문화를 만들어 가거나, 의견 전달과 조율을 더 잘 할 수 있도록 하는 소프트적인 영역을 챙긴다거나 하는 사소한 영역인 것 같으면서도 중요한 영역같아서 애매하다는 생각이 드는 영역들. 해당 영역들에서 오히려 문제가 더 많이 발생한다._\n\n포비의 말씀을 들으면서 이사를 하는 상황이 떠올랐다. 이사를 할 때 보증금/월세 같은 경우는 **지출해야 하는 영역**인 것을 알고 있기 때문에, 해당 돈을 내고 나면 쉽게 잊혀진다. 하지만, 빈 방을 채우기 위해서 다이소에서 물품들을 사거나 쿠팡으로 생활용품등을 주문하는 것들이 오히려 더 큰 지출로 느껴진다.\n\n필요없을 줄 알았는데 너무나 필요한 것들이여서 장바구니에 담다보면 큰 지출로 느껴지는 것 처럼, 애매한 영역이라 크게 신경쓰지 않아도 될 줄 알았는데 해당 영역에서 문제가 많이 발생하는...\n\n시간적인 여유가 된다면 애매한 영역을 챙겨서 팀의 분위기나 사기를 더 좋게 만드는 팀원이 되어보고 싶다 :D 팀 프로젝트의 주인이라는 마음가짐으로 임하며, 사소하다고 생각할 수 있는 영역도 챙기는 그런 팀원!\n\n![](<Screenshot 2024-07-14 at 23.59.18.png>)\n\n우테코는 많은 책임을 가지면서 이에 따라 많은 성장을 할 수 있는, 철저히 스타트업 분위기를 기대한다고도 말씀해 주셨다. 나와 너가 하는 일의 경계가 없이, 모든 일을 나의 일이다, 내가 사랑하는 일이다 라고 생각하면서 일하는 곳.\n\n![](<Screenshot 2024-07-15 at 00.01.48.png>)\n\n마지막으로 포비가 믿는 세상에 대해서 소개하며 OT의 시작을 마무리 하셨다.\n\n포비가 믿는 세상에 공감하고, 만들어 가려는 사람이 되려면 `심리적 여유`가 필요하다고 생각한다. 잠시 멈춰서 옳은 방향으로 가고 있는 것인지에 대해서 비판적 사고를 할 수 있는 시간적 여유, 서로의 고민이나 생각들에 대해서 공감하고 진심어린 피드백을 주고 받을 수 있는 팀에 속해있다는 심리적 여유 등등.\n\n우테코를 시작하기 전 지금까지의 내 모습을 돌아봤을 때, 경쟁과 속도와 결과를 우선시 했고 실패를 피하려고 했다. 그러다보니 스스로를 채찍질하면서 살아가는 것에 익숙했었으며, 나도 모르게 번아웃이 찾아와 번아웃의 굴레 속에서 허우적대기도 했다. 한 마디로 나에게 `심리적 여유`는 존재하지 않았었다.\n\n하지만, 우테코 활동을 시작한 후 코치들과의 면담, 함께 학습하는 크루들과의 스몰 토크, 유강스 등을 통해 긍정적인 영향을 많이 받았고 나의 일상과 개발이 '함께', '멀리' 갈 수 있는 방법에 대해서 어느 정도 알게되었고 실천도 했다. 다른 크루들에게도 많이 얘기를 하지만 우테코를 시작하고 나서 개발적으로 폭발적인 성장을 한 것인지는 잘 모르겠지만, 오히려 인간적인 성장을 많이 하고 있는 것 같다.  \n([레벨 1 글쓰기 미션](https://github.com/woowacourse/woowa-writing/pull/113), [레벨 2 글쓰기 미션](https://github.com/woowacourse/woowa-writing/pull/253)에서 확인할 수 있다! :D)  \n물론 이 방법들이 항상 적용된 것은 아니다. 당장 레벨 3 첫 주말에만 해도 모든 것을 다 잘하고 싶어 하며 결과를 우선시 하려는 과거의 모습들이 스멀스멀 올라와서 약간의 괴로움이 느껴졌다. 하지만, 우테코 시작 전과 달라진 점은 지금까지의 우테코 활동을 통해서 얻은 인사이트를 사용해서 빠르게 내 문제에 대해서 의식할 수 있게 되었다는 것과, 언제든 열린 자세로 나의 생각에 대해서 피드백을 해 줄 크루들이 있다는 것이다.\n\n현재 10개월 기간동안 진행되는 우테코 활동의 절반 정도가 흘렀고, 슬슬 취업 걱정도 되고 우테코 이후 삶에 대한 생각도 많이 하고 있다. 너무 많은 걱정, 고민, 생각보다는 지금까지의 활동을 통해서 배운 유연함을 활용해서 앞으로 남은 기간 동안 개발과 '함께', '멀리' 가고 싶다!\n\n## 우리 팀이 해결할 도메인\n\n## 팀 빌딩과 팀의 그라운드 룰\n"},{"excerpt":"우테코에서는 각 레벨마다 유연성 강화를 위한 목표를 세우고, 팀원들과 스터디들 한다. 이번 레벨 3에서는 아래에서 확인할 수 있듯 시간을 '유연하게', '잘' 구분한다는 목표를 세웠다. 해당 목표를 정하게 된 이유를 설명하다가 개인 회고도 하게 되었다...ㅋ 나의 유강스 목표 개인의 성장을 위한 시간과, 팀의 성장을 위한 시간 ‘잘’ 구분하기 왜 이 목표…","fields":{"slug":"level-3-flexibility-goal"},"frontmatter":{"date":"July 08, 2024","title":"유강스 목표를 정하려다가 개인 회고를 하게 되었다","tags":["회고"]},"rawMarkdownBody":"\n우테코에서는 각 레벨마다 유연성 강화를 위한 목표를 세우고, 팀원들과 스터디들 한다. 이번 레벨 3에서는 아래에서 확인할 수 있듯 시간을 '유연하게', '잘' 구분한다는 목표를 세웠다. 해당 목표를 정하게 된 이유를 설명하다가 개인 회고도 하게 되었다...ㅋ\n\n## 나의 유강스 목표\n\n---\n\n개인의 성장을 위한 시간과, 팀의 성장을 위한 시간 ‘잘’ 구분하기\n\n## 왜 이 목표를?\n\n---\n\n이유는 정말 간단하다. 구분할 수 있는 능력이 없을 경우, 어떤 상황이 벌어지는지 생각해보면 된다.\n\n만약, 개인과 팀의 시간을 구분하지 못한다면 나의 목표를 향해 개인적으로 해야 하는 일에 집중하지 못하니 나의 개인적인 목표를 향해 조금이라도 나아가고 있다고 전혀 느낄 수 없을 것이다. 반대로, 팀에 속한 팀원으로서 해야 하는 일에 집중하지 못하니 팀의 목표를 향해 나아가는데 차질이 생길 수 있고, 내가 걸림돌이 되고 있다는 생각을 하게 될 것이다.\n\n그래서 on/off는 정말 중요하다. 개인의 일에 집중해야 할 때는 팀에 대해서 잠시 잊고, 팀원으로서 집중해야 할 때는 개인에 대해서 잠시 잊는 것.\n\n내가 집중해야 하는 시간, 집중해야 하는 상황, 나와 함께 집중하고 있는 사람들을 파악하고 온전히 시간을 쏟는 것은 나와 나의 팀의 성장을 가속화할 수 있을 것이다. 반대로 쉬어야 할 때를 알고, 내가 해결해야하는 문제에 대해서 잠시 잊고 일상과 주변을 느끼는 것은 다음 on을 위해 체력을 비축하는 의미있는 시간이 될 것이다.\n\n문장으로 적는 것은 정말 쉽지만, 어떻게 실천해야할지는 감이 잡히지 않는다.\n\n집중해야 하는 시간과 잠시 쉬어도 되는 시간도 잘 구분하지 못해서 맥북을 덮어도 해결하지 못한 문제들을 계속 떠올리는 내가(개인에 대한 on/off도 잘 하지 못하는 내가), 개인의 시간과 팀의 시간까지 구분해낼 수 있을까? on/off를 잘 구분하지 못하고, 계속해서 off인 척 on으로 살아가는 내 모습도 나의 일부이기 때문에 받아들이며 살 수 있겠지만서도 가끔 완전히 off일 때 느낄 수 있는 심리적 편안함의 소중함을 잘 알기 때문에 의식적으로 ‘진짜 off 모드’ 연습을 해야겠다는 필요성을 느낀다.\n\n지금까지 내가 off인 척 계속 on 모드로 살아갔던 것은 아마도 **욕심이 너무 컸기 때문일 것이다.**\n\n> 잘하고 싶어, 다 알고 싶어!\n\n(이것도 알고 싶고, 저것도 알고 싶고, 내 앞에 놓인 모든 것을 잘하고 싶은 마음.)\n\n바로 어제(07/07)도\n\n- 디자인 시스템을 만들고 싶어서 디자인 공부도 해보려다가 (~~디자인 토큰 개념도 잘 모름.~~)\n- 스타일링 라이브러리를 뭐 쓸지 비교해보려다가\n- 우리 팀(우테코 레벨 3)의 서비스와 유사한 서비스의 흐름과 장단점을 비교 분석해보려다가\n- 웹팩에 대해서 알아보려다가\n\n결국 내가 해야 하는 일에 압도되어 뭐 하나 제대로 했다고 할 수 없는 하루를 보냈다. 개인에게 필요한 학습과 팀에서 필요한 학습을 구분하지 못하고 모든 것을 잘 하려고 하는 마음에서 비롯된 하루를 보냈다.\n\n문제를 발견했으니 차근차근 해결해보자.\n\n‘잘 한다’는 단어 자체가 굉장히 추상적이고, 저마다의 기준도 다르니 나만의 기준을 세우는 것.  \n너무 ‘잘 하려’고 하지 말고 하나를 하더라도, 그 경험을 통해서 ‘자라려’고 하는 것\n\non/off를 잘하기 위해서는 결국 스스로에 대해서 잘 알아야 한다고 생각한다.\n\n- 내가 ‘현재’, ‘지금’ 시간에 잘 집중하고 있다면 어떤 모습이 나오는지?\n  - 반대로, 잘 집중하지 못한다면 어떤 모습이 나오는지?\n- 일주일 중 몇 시간 정도 심리적 편안함을 느끼면, 체력을 비축할 수 있는지?\n  - 무엇을 하며 편안함을 느낄 것인지? 뭘 좋아하는지?\n- on모드에서 해야 할 일을 다 끝내지 못했을 때는 어떻게 하면 좋을지?\n\n등등 여러 상황 속에서 내 모습을 잘 알아야하며 그래야만 내가 더 오래, 즐겁게 성장할 수 있을 것이다.\n\n올해만 개발하고 내년에는 다른 일을 할 것인가? 아니지 않나?  \n조금 느리더라도 개발과 내가 ‘멀리’, ‘같이’ 갈 수 있기를!\n"},{"excerpt":"👋🏻 반갑습니다 :) 기록 시작합니다.","fields":{"slug":"hello"},"frontmatter":{"date":"July 07, 2024","title":"Hello","tags":["회고"]},"rawMarkdownBody":"\n## 👋🏻\n\n반갑습니다 :)\n\n기록 시작합니다.\n"},{"excerpt":"🪄 동시성 렌더링? 리액트 18 버젼이 등장하면서, 동시성 기능을 지원하는 여러 훅들이 나왔다. 리액트 공식문서에서는 다음과 같이 말한다. React 18 adds the long-awaited concurrent renderer and updates to Suspense without any major breaking changes. Apps can u…","fields":{"slug":"react-18-concurrent"},"frontmatter":{"date":"June 24, 2024","title":"[React] React 18 - Concurrent Features","tags":["React","우아한테크코스"]},"rawMarkdownBody":"\n## 🪄 동시성 렌더링?\n\n리액트 18 버젼이 등장하면서, 동시성 기능을 지원하는 여러 훅들이 나왔다.\n\n리액트 공식문서에서는 다음과 같이 말한다.\n\n> _React 18 adds the long-awaited concurrent renderer and updates to Suspense without any major breaking changes. Apps can upgrade to React 18 and begin gradually adopting concurrent features with the amount of effort on par with any other major release._\n>\n> _This means there is no concurrent mode, only concurrent features._\n>\n> _React 18은 오랫동안 기다려온 동시 renderer를 추가하고 Suspense를 큰 변경 없이 업데이트했다. 앱을 React 18로 업그레이드하여 다른 주요 출시와 동등한 수준의 노력으로 동시 기능을 점진적으로 도입할 수 있게 되었다. 이는 동시 모드가 없고 동시 기능만 있음을 의미한다._\n\n앱의 전체를 동시성 모드로 결정하고 개발을 해가는 것이 아닌 리액트가 제공해주는 동시성 기능을 가지는 API들 즉, `useTransition`, `useDeferredValue` 훅을 사용해서 앱에 부분적으로 동시성 기능을 사용할 수 있게 되었다는 것을 의미한다.\n\n```tsx\nconst root = ReactDOM.createRoot(document.getElementById(\"root\") as HTMLElement)\n```\n\n조금 만 더 자세하게 들어가 보자면, 리액트 18 버젼부터 `createRoot` 함수를 통해서 전체 컴포넌트 트리를 만들게 되면 **내부적으로 concurrent mode 가 실행된다.** 하지만 concurrent mode 가 실행된다고 해서, 무조건 모든 렌더링에 동시성이 적용되는 것이 아니라 **concurrent features 를 사용하는 경우에만** 부분적으로 동시성 렌더링이 적용된다는 것이다.\n\n(concurrent features 는 `useTransition`, `useDeferredValue` 훅이나 `Suspense`, `streaming SSR` 등을 말한다.)\n\n리액트가 말하는 동시성에 대해서 알아보기 전, 컴퓨터 과학에서 말하는 동시성을 병렬성과 비교해 보면서 알아보자.\n\n## concurrency(동시성)\n\n컴퓨터 과학에서 동시성이란, 독립적으로 실행되는 프로세스들의 조합을 말한다.  \n반면, 동시성과 헷갈리기 쉬운 개념인 병렬성은 연관된 복수의 연산들을 동시에 실행하는 것이다.\n동시성은 여러 일을 한꺼번에 다루는 문제에 관한 것이고, 병렬성은 여러 일을 한꺼번에 실행하는 방법에 관한 것이다.\n\n도서관 사서 예시를 통해서 동시성과 병렬성을 좀 더 이해해보자. 😊\n\n1. 동시성\n\n동시성은, 도서관 사서가 책을 정리하고 있었는데 꼬마 아이가 어떤 책의 위치를 질문하는 상황을 떠올려보면 조금 더 쉽게 이해할 수 있다.\n\n![](./assets/lib-concurrency.png)\n\n사서는 책을 정리하고 있다가(`task 1`), 꼬마 아이의 질문에 답을 해줘야 한다. (`task 2`)\n\n즉, 도서관 사서는 책을 정리하는 논리적 흐름과 질문에 답을 해주는 논리적 흐름을 둘 다 가지게 되며 **사서 한 명이 두 가지 논리적 흐름을 동시에 실행하는 것 처럼 보인다.**\n\n2. 병렬성\n\n![](./assets/lib-parrell.png)\n\n반면, 병렬성은 도서관 사서가 두 명인 경우를 떠올려보면 쉽게 이해할 수 있다. 한 명은 책을 정리하며(`task 1`), 다른 한 명이 꼬마 아이의 질문에 답을 해준다. (`task 2`)  \n각 사서들은 하나의 논리적 흐름을 가지며, **한 명씩 스스로가 수행해야 하는 논리적 흐름을 독립적으로 수행한다.**\n\n다음 이미지를 통해서 한 번 더 정리해 보자.\n\n![](./assets/compare-con-par.png)\n\n- 이미지 출처 : https://tv.naver.com/v/23652451\n\n위 그림에서도 확인할 수 있는 동시성과 병렬성의 차이는 다음과 같다.  \n동시성은 최소 두개의 논리적 흐름(task)가 존재한다. 동시성은 싱글 코어(단일 CPU) 에서도 동작하며, 병렬성은 멀티 코어(다중 CPU) 에서 동작한다.\n\n정리해 보자면, 동시성이란 두 개 이상의 작업을 잘게 나누고 우선순위에 따라서 작업 전환을 빠르게 함으로서 여러개의 작업들이 마치 동시에 실행되는 것 처럼 보이게 프로그램을 구조화 하는 방법이다.\n\n## 리액트에서 동시성(concurrency)\n\n리액트 공식문서에서는 동시성에 대해서 다음과 같이 설명한다.\n\n> _Concurrency is not a feature, per se. It’s a new behind-the-scenes mechanism that enables React to prepare multiple versions of your UI at the same time._\n>\n> _Concurrency 자체는 기능이 아니다. React가 동시에 여러 버전의 UI를 준비할 수 있게 해주는 새로운 비하인드 메커니즘이다._\n\n> _A key property of Concurrent React is that rendering is interruptible. When you first upgrade to React 18, before adding any concurrent features, updates are rendered the same as in previous versions of React — in a single, uninterrupted, synchronous transaction. With synchronous rendering, once an update starts rendering, nothing can interrupt it until the user can see the result on screen._\n>\n> _Concurrent React의 핵심은 렌더링 작업이 중단 가능하다는 것이다. React 18로 처음 업그레이드할 때 concurrent 기능을 추가하기 전 업데이트는 이전 버전의 React와 동일하게 중단되지 않는 단일 동기식 트랜잭션으로 렌더링 되었다. 동기식 렌더링의 경우 한 번 렌더링이 시작되면, 사용자가 화면에서 결과를 볼 수 있을 때까지 그 어떤 것도 렌더링을 방해할 수 없었다._\n\n> _In a concurrent render, this is not always the case. React may start rendering an update, pause in the middle, then continue later. It may even abandon an in-progress render altogether. React guarantees that the UI will appear consistent even if a render is interrupted._\n> …  \n> _With this capability, React can prepare new screens in the background without blocking the main thread. This means the UI can respond immediately to user input even if it’s in the middle of a large rendering task, creating a fluid user experience._\n\n> _Concurrent 렌더링에서는 항상 그렇지는 않다. React는 업데이트된 렌더링을 시작하고 중간에 일시 중지했다가 나중에 계속할 수 있다. 심지어 진행 중인 렌더링을 완전히 중단할 수도 있다. React는 렌더링이 중단되더라도 UI가 일관되게 표시되도록 보장한다._\n>\n> _이 기능을 통해 React는 메인 스레드를 차단하지 않고 백그라운드에서 새 화면을 준비할 수 있다. 즉, UI가 대규모 렌더링 작업 중에도 사용자 입력에 즉시 반응하여 유동적인 사용자 경험을 제공할 수 있다._\n\n공식문서의 내용을 정리해 보자면, 리액트가 말하는 동시성 렌더링이란,\n\n- 동시성 개념을 활용해서 한 번 시작하면 멈출 수 없었던 렌더링 작업을 멈추거나,\n- 우선순위를 정해서 더 우선순위가 높은 렌더링 작업을 수행해 여러 버젼의 UI를 만들고,\n- 그 중 사용자 입력과 같은 인터렉션에 **가장 빠르게 반응할 수 있는 UI를 선택**하는 것을 말한다.\n\n동시성 렌더링의 핵심은 여러 작업을 동시에 실행하는 것 처럼 보이게 해서 **사용자 경험을 향상시키는 것이다.**(핵심은 사용자 경험!)\n\n그렇다면, 어떤 상황에서 동시성 개념이 필요하게 될까? 🤔\n\n## 💭 Blocking Rendering\n\n브라우저의 메인 스레드는 **싱글 스레드라서 한 번에 하나의 작업만 처리**할 수 있다.\n\n![](./assets/critical-render-path.png)\n\n즉 HTML을 파싱, Javascript 파일을 다운로드 하고 실행, 사용자의 행동으로 발생하는 이벤트를 처리, 리페인트, 리플로우 등을 모두 단일 메인 스레드에서 처리한다.그리고, 메인 스레드에서 어떤 작업이 실행되면 그 작업이 끝날 때까지 멈출 수 없었다.\n\n이를 **Blocking Rendering** 이라고 한다.\n\n리액트에서의 렌더링 즉, 화면을 그리는 작업, 재귀적으로 컴포넌트를 렌더링해서 이전 렌더링과 비교해 다르게 보여야 하는 UI를 파악하고(render phase) 그 결과를 브라우저에 커밋해(commit phase) 실제 사용자의 눈에 보이는 작업이 한 번 시작되면 멈출 수 없는 작업이었다.\n\n보통의 상황에서는 한 번 시작되면 멈출 수 없는 리액트의 렌더링 작업이 사용자 경험에 큰 영향을 주지 않는다. 리액트의 변경 비교 알고리즘이 매우 빠르기 때문이다.\n\n하지만, 다음과 같은 특수한 상황을 생각해보자.\n\n```tsx\nimport React, { useState } from \"react\"\n\nfunction App() {\n  const [text, setText] = useState(\"\")\n\n  return (\n    <div className=\"container\">\n      <h1>Blocking ({text.length})</h1>\n      <input\n        type=\"text\"\n        value={text}\n        maxLength={100}\n        onChange={({ target }) => {\n          setText(target.value)\n        }}\n      />\n      <ColorList length={text.length} />\n    </div>\n  )\n}\n```\n\n![](./assets/color-blocking.png)\n\n- 출처 : https://ajaxlab.github.io/deview2021/blocking/\n\ninput 에 입력을 할 때마다, App 컴포넌트가 렌더링 되며 ColorList 또한 렌더링 된다. 여기서, **ColorList는 무거운 연산을 수행**하고 있기 때문에 사용자가 입력한 텍스트가 UI에 바로 반영되지 않아 좋지 못한 사용자 경험을 제공할 수 있다.\n\n`concurrent features`을 사용하지 않는 리액트에서 렌더링은 한 번 시작하면 멈출 수 없는 작업이여서, 사용자가 입력한 텍스트를 UI에 반영해줘야 하는 사용자 경험 기준 높은 우선순위 작업이 ColorList 컴포넌트 렌더링에 의해 밀리게 된다.\n\n이 문제를 리액트 18 버젼부터 사용할 수 있는 concurrent features 를 사용해서 해결할 수 있다.\n\n사용자가 발생시키는 특정 이벤트에 더 빠르게 반응할 수 있는 UI를 우선시하고, 현재 렌더링 작업을 일시적으로 중단할 수 있도록 할 수 있다.\n\n즉, 더 빠르게 반응해야 하는 작업(input UI 표시)이 실행되면, 현재 렌더링(ColorList 렌더링)을 일시 중단하고 우선 작업을 먼저 처리한다.\n\n이제 어떤 concurrent features가 있는지 알아보자.\n\n## ✨ useTransition\n\n공식문서에서 useTransition 훅을 다음과 같이 설명한다.\n\n> _useTransition is a React Hook that lets you update the state without blocking the UI._\n>\n> _useTransition은 UI를 차단하지 않고 상태를 업데이트할 수 있는 리액트 훅이다._\n\n여기서 UI를 차단하지 않는다는 것은, 사용자의 인터렉션을 즉각적으로 UI에 반영해야 할 때 이전 하고 있던 무거운 렌더링 작업이 다음 UI 렌더링을 차단하지 않아야 한다는 뜻이다. 렌더링 작업이 언제 수행되고 있든, 더 급한 상태 업데이트로 인해서 중단될 수 있음을 의미한다.\n\n```tsx\nconst [isPending, startTransition] = useTransition()\n```\n\n`useTransition` 훅에서 제공하는 `startTransition` 함수를 사용하여 상태 업데이트가 긴급하지 않다는 것을 표시할 수 있다. 빠른 UI 업데이트, 반응을 방해할 수 있는 상태 업데이트가 긴급하지 않다는 것을 상태 업데이트를 “트랜지션”으로 표시해서 리액트에게 알려 의도적으로 우선순위를 조정할 수 있다.\n\n(a 상태 업데이트? 급하지 않습니다! 해당 상태 업데이트보다 더 중요한 작업이 있다면 그것부터 해주세요~ 와 같은 요청)\n\n즉, 상태 업데이트가 동시성 기능을 사용하지 않고 동기적으로 렌더링 될 경우 잠재적으로 사용자의 경험에 나쁜 영향을 미칠 수 있다고 리액트에게 알리는 것이다.\n\n![](./assets/ux-compare.png)\n\n위 `Input` , `ColorList` 컴포넌트 예시를 다시 생각해보면 사용자가 현재 어떤 값을 입력해 줬는지를 UI에 표시해주는 작업이 더 우선순위가 높은 작업이라고 할 수 있다.\n`startTransition API`를 사용해서 상태 업데이트를 긴급하지 않은 것으로 간주해서 무거운 렌더링 작업인 **ColorList 컴포넌트 렌더링 작업을 뒤로 미뤄보자.**\n\n```tsx\nimport React, { useState, useTransition } from \"react\"\n\nfunction TextInput({ onChange }) {\n  const [text, setText] = useState(\"\")\n  return (\n    <input\n      type=\"text\"\n      value={text}\n      onChange={({ target }) => {\n        setText(target.value)\n        onChange(target.value)\n      }}\n    />\n  )\n}\n\nfunction App() {\n  const [size, setSize] = useState(0)\n  const [isPending, startTransition] = useTransition()\n\n  function handleChange(text) {\n    startTransition(() => {\n      setSize(text.length)\n    })\n  }\n\n  return (\n    <div className=\"container\">\n      <h1>Concurrent ({size})</h1>\n      <TextInput onChange={handleChange} />\n      <div className={isPending ? \"pending\" : \"\"}>\n        <ColorList length={size} />\n      </div>\n    </div>\n  )\n}\n\nexport default App\n```\n\n![](./assets/color-non-blocking.png)\n\n`ColorList` 컴포넌트가 props로 받는 size 상태를 따로 분리하고 해당 상태 업데이트가 우선순위가 낮은 상태 업데이트라는 것을 리액트에게 알린다.\n\n> _React can prepare new screens in the background without blocking the main thread._\n>\n> _React는 메인 스레드를 차단하지 않고 백그라운드에서 새 화면을 준비할 수 있다._\n>\n> 출처 : 리액트 공식문서\n\n리액트는 이제 `size` 상태 업데이트가 무거운 렌더링을 유발하는 것임을 알기 때문에, 업데이트를 즉시 반영하는 대신 백그라운드에서 새로운 상태를 준비하면서 현재의 UI를 인터랙티브하게 유지한다.\n\n`useTransition` 훅이 제공하는 isPending 불리언 값을 사용해서 긴급하지 않은 상태 업데이트의 진행 상태를 알 수 있고, 이를 사용해 사용자에게 loading feedback 또한 제공할 수 있게 된다.\n\n```jsx\n<div className={isPending ? \"pending\" : \"\"}>\n  {isPending && <h1>loading...</h1>}\n  <ColorList length={size} />\n</div>\n```\n\n## ✨ useDeferredValue\n\n공식문서에서 `useDeferredValue` 훅을 다음과 같이 설명한다.\n\n> _useDeferredValue is a React Hook that lets you defer updating a part of the UI._\n>\n> _useDeferredValue는 UI 일부 업데이트를 지연시킬 수 있는 React Hook이다._\n\n`useTransition` 훅이 제공하는 `startTransition` 은 상태를 업데이트하는 함수를 래핑해서 해당 작업의 우선순위가 낮다는 것을 리액트에게 알리지만, `useDeferredValue` 훅은 인자로 들어오는 값 업데이트의 우선순위가 낮다는 것을 알린다.\n\n```tsx\nconst deferredValue = useDeferredValue(value)\n```\n\n만약 값의 변경으로 인해서 무거운 렌더링 작업이 수행된다면, 해당 훅으로 감싼 후 무거운 렌더링을 지연시킬 수 있게 된다.\n\n이번에는 위 예시를 useDeferredValue 훅을 사용해서 개선해보자.\n\n```tsx\nimport React, { useState, useDeferredValue } from \"react\"\n\nfunction TextInput({ onChange }) {\n  const [text, setText] = useState(\"\")\n  return (\n    <input\n      type=\"text\"\n      value={text}\n      onChange={({ target }) => {\n        setText(target.value)\n        onChange(target.value)\n      }}\n    />\n  )\n}\n\nfunction App() {\n  const [size, setSize] = useState(0)\n  const deferredSize = useDeferredValue(size)\n\n  function handleChange(text) {\n    setSize(text.length)\n  }\n\n  return (\n    <div className=\"container\">\n      <h1>Concurrent ({size})</h1>\n      <TextInput onChange={handleChange} />\n      <div className={deferredSize !== size ? \"pending\" : \"\"}>\n        <ColorList length={deferredSize} />\n      </div>\n    </div>\n  )\n}\n\nexport default App\n```\n\n무거운 렌더링을 유발하는 값인 `size` 업데이트의 우선순위를 낮춰서 UI를 인터랙티브하게 유지될 수 있게 한다.\n\n(결과는 useTransition과 같다.)\n\nuseDeferredValue 훅은 지연해야 하는 값 업데이트 직접 제어할 수 없고, props로 전달받을 때 유용하게 사용할 수 있다.\n\n```tsx\nfunction SomeComponent({ value }) {\n  const deferredValue = useDeferredValue(size)\n\n  // heavy work using deferredValue\n\n  return <JSX />\n}\n```\n\n## 🧚 정리\n\n- 리액트는 동시성 기능을 도입해서, 시작하면 멈출 수 없었던 렌더링 과정을 일시 중지했다가 나중에 다시 시작하거나 중단할 수 있게 되었다. 이는 무거운 렌더링 작업이 진행되고 있더라도 사용자 입력과 같은 더 빠른 반응을 해야 하는 상황에 대해 UI가 즉각적으로 반응해 사용자 경험을 향상시킬 수 있게 되었다는 것을 의미한다.\n\n- 리액트는 앱 전체 동시성 모드는 존재하지 않고, concurrent features 를 통해 부분적으로 동시성 기능을 활용할 수 있으며, 어떤 상황에 어디에 적용할지는 개발자인 우리가 결정해야 한다.\n\n- 상태를 업데이트 하는 작업(size 상태 업데이트), 렌더링 작업(<ColorList /> 컴포넌트 렌더링)을 잘게 나누고 우선순위를 정한 후 빠른 Context Switching을 통해서 마치 두 작업이 동시에 실행되는 것 처럼 보이게 한다.\n\n- useTransition 훅은 ‘특정 상태 업데이트’를 지연시켜서 무거운 렌더링 작업을 뒤로 미룰 수 있도록 한다.\n\n- useDeferredValue 훅은 ‘값’ 업데이트를 지연시켜서 무거운 렌더링 작업을 뒤로 미룰 수 있도록 한다.\n\n- ✨ 리액트 동시성 렌더링의 핵심은 사용자 경험 향상이다!\n\n## 🔗 Ref\n\n- https://velog.io/@jay/Concurrent-React\n\n- https://velog.io/@sehyunny/how-react-18-improves-app-perf\n\n- https://tecoble.techcourse.co.kr/post/2023-07-09-concurrent_rendering/\n\n- https://tv.naver.com/v/23652451\n\n- https://ko.react.dev/blog/2022/03/29/react-v18#what-is-concurrent-react\n"},{"excerpt":"반갑습니다~ 🍀🧚 안녕하세요, 우아한테크코스 6기 FE 해리라고 합니다. 저의 레벨 2 유연성 강화 목표는 \"현재 내가 처한 상황에 적응하는 능력 키우기\" 입니다. 지금까지의 저는 낯설고 새로운 환경이나 상황에 놓였을 때, 이에 적응하는 데까지 꽤 많은 시간이 필요했고, 적응해가는 과정을 힘들어했었던 것 같아요. 그래서 환경이 변할 때마다 몸의 색을 바꿔…","fields":{"slug":"woowacourse-level-2-writing"},"frontmatter":{"date":"June 05, 2024","title":"우아한테크코스 레벨2 글쓰기 미션","tags":["회고","우아한테크코스"]},"rawMarkdownBody":"\n## 반갑습니다~ 🍀🧚\n\n안녕하세요, 우아한테크코스 6기 FE 해리라고 합니다. 저의 레벨 2 유연성 강화 목표는 **\"현재 내가 처한 상황에 적응하는 능력 키우기\"** 입니다. 지금까지의 저는 낯설고 새로운 환경이나 상황에 놓였을 때, 이에 적응하는 데까지 꽤 많은 시간이 필요했고, 적응해가는 과정을 힘들어했었던 것 같아요.\n\n그래서 **환경이 변할 때마다 몸의 색을 바꿔가며 유연하게 환경에 적응해가는 카멜레온처럼**, 저도 새로운 환경, 상황에 유연하게 적응해가는 사람이 되고 싶어 위와 같은 유연성 강화 목표를 정하게 되었습니다.\n\n편하게 읽어주세요 ㅎㅎ 😊\n\n(참고차, 레벨 1 글쓰기도 같이 링크 첨부해 봅니다.)\n\n[레벨 1 글쓰기 미션](https://github.com/hwinkr/woowa-writing/blob/level1/README.md)  \n[레벨 1 전체 회고(개인 블로그)](https://hwinkr.tistory.com/4)\n\n그럼 이야기를 시작해 보겠습니다.\n\n## 결국 적응한다, 해낸다. 어떻게든\n\n이 글은, \"우아한테크코스\"라는 경험해 보지 못했던 새로운 환경에 놓인 제가 어떻게 적응해갔는지에 대한 기록에 가깝습니다. 우테코가 끝나고 앞으로 살아가면서 또 다른 새로운 환경에 놓이게 될 제가, 적응하느라 힘들어하고 있다면 이 글로 돌아와서 **\"결국 적응한다, 해낸다. 어떻게든\"** 이라는 메시지와 힘을 얻어 가면 좋겠다는 생각으로 써봅니다. 또 저 뿐만이 아닌, 저의 글을 리뷰해 주실 분들, 우연히 지나가다 제 글을 읽으실 분들 모두 **'결국 적응한다, 해낸다. 어떻게든'** 이라는 말과 함께 힘을 얻어 가셨으면 좋겠습니다.\n\n### 레벨 1 기억 더듬어보기\n\n우테코를 시작한 지 얼마 되지 않았던, 2~3월은 우테코라는 낯선 환경에 적응해 보기 위해서 허우적댔던 기억이 대단히 많습니다. 어느 정도 적응하기 전, 삐걱(?)댔던 제 모습을 몇 가지 기록해 봅니다..ㅋㅋㅋ\n\n#### 1) 뭘 먹어도 소화가 안 돼요\n\n지금은 주로 도시락을 싸다니지만, 연극을 준비하던 온보딩 기간에는 연극조, 데일리 조와 함께 밖에서 밥을 먹었습니다. 우테코라는 새로운 환경도 낯설고, 선릉도 낯설고, 처음 본 크루들도 낯설고,,,그러다보니 뭘 먹든 소화가 잘되지 않았습니다. 평소 밀가루, 유제품류 같은 음식들은 잘 소화하지 못해서 웬만하면 잘 먹지 않으려고 하는 편이었는데 이런 음식들을 먹는 날이면... 하루 종일 가스가 차고 속이 더부룩하고 난리가 나더군요.\n\n예민한 피부를 타고나서, 하루는 피부가 엄청나게 뒤집어졌던 기억도 있네요.\n\n하지만, 이 문제는 레벨 2에 와서 말끔히 해결됩니다! 어떤 음식을 먹느냐보다, **편안함 속에서 밥을 먹을 수 있냐 없냐**가 더 중요하더라고요. 우테코에서 어느 정도 적응하고, 편안해졌다는 것을 느낀 뒤로 무엇을 먹든 대부분 소화를 잘하는 제 모습을 발견했습니다~! 😊\n\n#### 2) 해리...집 갈 때 인사해도 돼?\n\n레벨 1 데일리 미팅을 하던 중, 실제로 제가 받았던 질문입니다... ㅎ 평소 캠퍼스에서 노이즈 캔슬링 헤드셋을 끼고 있어, 집중해서 코딩하고 있다면 옆에서 누가 지나가는지 잘 모르겠더라구요. 거기다가 레벨 1 초반에는 우테코에 잘 적응하지 못해서 허우적대기도 했고, 크루들과 어색하고 서먹하던 시기라서 인사를 잘 하지 않았던 것 같습니다. (제가 극 I라 죄송...ㅎ) 저에게 인사를 하고 싶었던 한 크루가 제가 너무 집중하는 것 같아서 전날 인사를 못했는지, 다음 날 혹시 집 갈 때 인사해도 되겠냐고 질문을 하더군요. 그런 질문을 받아본 적은 처음이라 질문을 받고 되게 당황스러웠던 기억이 나네요.\n\n레벨 1 담당 코치였던 공원이, 장난으로 \"두 분 뭔 일 있나요? 데일리 미팅 끝나면 저한테 오세요..ㅋㅋㅋ\" 했던 기억이 납니다. 지금은 인사해도 되겠냐고 질문을 했던 크루 분과 아주 밝게 인사를 주고받으면서 잘 지내고 있습니다. 😊  \n(혹시나 이 글을 읽는다면 그렇다고 해주세요~)\n\n#### 3) 해리가 생각하는 우테코 생활은 어떤 거죠? ㅋㅋ\n\n레벨 1 생활을 하면서, 가장 많이 했던 말이 있습니다.\n\n> '이건 제가 생각했던 우테코 생활이 아니에요...'\n\n이런 말을 할 때마다, 공원은\n\n> '그럼 해리가 생각하는 우테코 생활은 어떤 거죠? ㅋㅋ\n\n라며 질문해 주셨고, 저는\n\n> '일단 이건 아닙니다...'\n\n라고 대답했던 기억이 납니다.너무나도 자유롭고 편안한 분위기 속에서, 또 한편으로는 야생 같은 환경 속에서 학습과 성장을 해가는 우테코에 잘 적응하지 못했었기 때문에 레벨 1 때는 저 말을 많이 하지 않았나 싶습니다. 레벨 2에서는 저 말을 한 번도 한 적이 없습니다~ ㅎㅎ 😊\n\n## 나의 레벨 2 적응기\n\n레벨 1 환경에 적응하기 위해서 때로는 허우적대며, 또 때로는 삐걱(?)대기도 했던 제가 레벨 2 환경에 어떻게 적응해 갔는지 이야기를 시작해 볼까 합니다.\n\n### 서울 지옥철 돌파구 찾기\n\n아침 8시 30분부터 9시 사이에 2호선 지하철을 탔을 때, 놀라지 않았던 적이 없습니다.\n\n> \"사람이 왜 이렇게 많은 거지?\"\n>\n> \"부산 지하철보다 분명히 훨씬 더 넓은데, 저 넓은 공간을 어떻게 다 채우는 거지?\"\n\n라는 생각을 하며 사람들 속에 끼여 힘들게 출근했던 기억이 나네요. 특히, 지하철이 도착하고 문이 열렸음에도 공간이 가득 차서 들어가지 못하고 눈앞의 지하철에 타지 못하고 보내야 했던 순간은 정말 충격이었습니다. 저는 이 상황에 적응해 보고자 했습니다. 아시는 분은 아시겠지만, 레벨 1에서 저는 11시까지 남아있던 **왔다 감 고정 멤버** 였습니다.\n(참고 : [왔다감 고정 멤버입니다만...?](https://github.com/hwinkr/woowa-writing/blob/level1/README.md#%EC%99%94%EB%8B%A4%EA%B0%90-%EA%B3%A0%EC%A0%95-%EB%A9%A4%EB%B2%84%EC%9E%85%EB%8B%88%EB%8B%A4%EB%A7%8C))\n\n하지만, '곧 여름이라서 굉장히 더워질테고, 나는 몸에 열도 굉장히 많은 편이고, 출근할 때 편하게 오고 싶은데... 어떻게 할 수 있을까?'라는 생각을 했고, 그럼 **레벨 2는 새벽러가 돼서 왔다 감의 \"왔\"을 담당해 보자!** 라는 결론을 내리게 되었어요. 이 생각을 하기 전, 저는 대부분 새벽 1 - 2시 사이에 잠들었었기 때문에 평소에 유지했던 수면 패턴을 바꾸기 위해서 특별한 트리거(?)가 필요했습니다. 그래서 저는, 레벨 1 방학이 끝날 무렵 갔던, MT를 이용해 보기로 했습니다! 😎😎😎\n\n> 'MT에 가서는 마음 편하게 밤새워 놀고, **밤을 새운 다음에도 잠을 자지 않고 쌓아둔 다음 일찍 잠에 들고 새벽에 일어나보자!**'\n\n라고 생각했고, 실제로 적용했습니다. 그래서, 레벨 2부터는 8시에서 8시 20분 사이에 도착하는 것을 목표로 하고 \"왔\"을 담당하며 생활하고 있습니다!\n\n![](./assets/come-1.jpeg)\n\n제가 생각한 목표 시간에 도착하려면 적어도 6시 30분에는 일어나야 해서 달라진 수면 패턴에 적응하느라 캠퍼스에 도착하고 나서도 졸기도 하고 아예 자기도 했어요. 이럴 때마다, '다시 \"감\"을 담당하고 원래 자던 데로 잘까...'하며 흔들리기도 했지만 '지옥철만은 피하겠어!🔥 나는 적응할 수 있다, 나를 믿어보자'하며 졸더라도, 자더라도 이 수면 패턴을 유지해 보고자 했어요.\n\n지금은 어느 정도 적응을 한 것 같아서 알람 없이도 6시 30, 40분 사이에 눈을 뜨고 있네요 하하 😊\n\n### 우테코 야생에 적응하기 (Feat. TDD)\n\n레벨 2에 와서, 이유는 잘 모르겠지만 정말 '붕~ 떠 있는 것 같다'라는 생각을 많이 했습니다. 💭💭💭 선릉 캠퍼스를 떠다니는 공기처럼, 붕~ 떠다니면서 오늘 하루해야 하는 일에 집중도 잘 못하고, 외면하고 있는 제 모습을 발견했습니다. 최근에서야 그 이유를 알게 되었는데 '제가 생각했던 레벨 2의 학습 방향과 실제 학습 방향이 일치하지 않아서' 이 부분에서 약간의 괴리감을 느끼고 있어서였습니다. 레벨 1은 자바스크립트를 '깊이 있게' 학습하고 다뤄보는 것이 학습 목표였기 때문에, 레벨 2는 리액트를 '깊이 있게' 학습하고 다루는 것이 학습 목표이지 않을까 생각하며 레벨 2를 맞이했지만 실제로는 **리액트와 TDD 사고방식을 활용해서 주어진 문제를 \"잘\" 해결하는 것이 목표**안 듯했습니다.\n\n'문제를 잘 정의하고, 문제를 해결해 가기 위한 작업 순서를 정하고, 테스팅 도구를 사용해서 **빠른 피드백**을 받는다...?' 도대체 이게 무슨 말인가 싶었습니다. 레벨 1에도 TDD 수업이 있었는데, **'실패하는 테스트 코드를 먼저 작성한다'** 는 것이 너무나도 어색하고 와닿지 않아서 외면했던 기억도 함께 떠올랐습니다. TDD가 주제였던 미션에서 페어에게 \"왜 실패하는 코드를 먼저 짜야 할까요...?\"라는 반란군과도 같은 질문을 하기도 했습니다... ㅎ\n\n너무 어렵게 느껴지고, 추상적으로 느껴지고, 학습 목표에 다가가기 위해서 어떻게 해야 할지 전혀 감이 잡히지 않아서 적응하지 못하고 붕~ 떠 있는 것만 같다고 생각하게 되더군요. 어느 날, '레벨 2가 끝날 때까지, 계속 붕 떠 있을 수만은 없다...!'고 생각하게 되었습니다.\n\n![](./assets/eo-70-20-10.png)\n![](./assets/eo-failed.png)\n\n[출처](https://www.youtube.com/watch?v=3-1kfqoUcpo&t=2s)\n\n**6기-잡담** 채널에 솔라께서 공유해주신 영상을 보고 나서 TDD에 도전해보기로 마음 먹었습니다.\n\n> 학습의 70%는 그냥 나가서 해보는 거예요.\n>\n> 실패하는 것을 받아들일 준비가 되어 있어야 해요.\n\n해당 문장을 보고 용기를 얻어 장바구니 미션 스텝 2에서 TDD에 도전해 보기로 했습니다. 단, 저의 방식대로...! TDD와 관련된 블로그 글, TDD 책, 유튜브 영상을 보지 않고 **제가 생각하는 TDD를 직접 미션에 적용해 보기로 했습니다.** 레벨 1을 진행하면서 크루, 리뷰어 분들과 **미션이 끝날 때마다**, **피드백 요청과 응답이 끝날 때마다** 피드백을 주고받으면서 피드백의 중요성에 대해서 알게 되었습니다. 또, 레벨 1 방학 때 \"함께 자라기\" 책을 읽으면서 **빠른 피드백**의 중요성에 대해서도 알게 되었습니다. 그래서 TDD의 T를 TEST로 바라보기보다는 피드백으로 바라보기로 했습니다...!\n\nTDD를 '실패하는 테스트 코드를 먼저 작성하고, 통과하기 위해서 코드를 구현해 가는 것'이라고 생각하지 않고, '문제를 해결하기 위한 사고 과정과 그 결과인 코드에 대해서 **빠르게 피드백**을 받는 것'이라고 생각하기로 했습니다.\n\n```text\n장바구니 미션 스텝 2 기능 요구 사항 중\n\n다음과 같은 4가지 유형의 쿠폰을 사용할 수 있어야 한다,\n각 쿠폰의 특성을 잘 이해하고, 해당 쿠폰을 적용했을 때의 할인 효과를 정확히 계산할 수 있도록 구현한다.\n...\n```\n\n위와 같은 핵심 기능 요구 사항을 구현해 가기 위해서, 쿠폰이 딱 하나만 있다고 스스로 가정하고 하나의 쿠폰 로직 작성이 끝나면 테스팅 도구를 활용해서, 빠르게 피드백을 받는 방식으로 구현했습니다. 이런 방식으로 미션을 진행하니 **적어도 하나의 기능은 사용자에게 안전하게 제공해 줄 수 있겠다**는 생각이 들어 안도감이 느껴졌고, 하나의 기능과 그 기능에 대한 테스트 한 세트를 완료해 갈 때마다 끝을 향해서 조금씩 나아가고 있다는 느낌도 받았습니다.\n\n이렇게 미션을 끝내고 PR을 제출한 후, 처음 한 생각은 '아 TDD 사고방식, 무슨 느낌인 줄 알겠다! 왜 그렇게 강조하시는지 알겠다!'였습니다. 이 생각이 든 후부터는, 붕~ 떠다니던 감정들이 많이 가라앉았고 다시 제가 해야 하는 일에 집중을 잘하는 제 모습을 발견할 수 있었어요.\n\n해당 미션의 PR도 같이 첨부해 봅니다. ㅎ ([장바구니 미션 스텝 2 미션 PR](https://github.com/woowacourse/react-shopping-cart/pull/296))\n\n### 달라진 내 모습에 적응하기\n\n레벨 2에 들어와서 스스로 가장 많이 했던 생각이 있습니다. 바로 '우테코 생활하면서 가장 많은 시간을 함께 보내는 크루들이랑 어떻게 하면 더 의미 있게 시간을 보낼 수 있을까?' 입니다. 내년에 우테코 생활을 다시 돌아봤을 때, '~해볼걸', '~아 이건 왜 하지 않았지?' 이라는 생각이 조금이라도 덜 들려면(우테코 생활을 어떻게 하든 후회는 남겠지만요) 내가 뭘 할 수 있을까에 대한 생각을 했을 때, 크루들이랑 더 의미 있게 시간을 보내보자!라는 나름대로 결론을 내렸었습니다.\n\n즐겁게 학습해 가는 우테코에서의 하루하루가 너무나도 소중하게 느껴지더라고요.\n그래서 뭘 했냐면,,, 바로 회고와 피드백을 할 수 있는 질문지들을 만들어보고 그 질문에 답을 같이하고, 답을 공유해보는 시간을 마련했습니다!\n\n솔직히 레벨 1때에만 해도, 너무 많은 회고와 피드백에 갇혀서 적응하느라 힘들었습니다. 하지만 회고와 피드백 사이클에 적응을 하고, 장점을 깨달은 후 이를 더 '잘'할 수 있는 방법에 대해서 고민해 보는 시간을 가졌어요. 그 고민의 결과로, 질문지들을 만들고 '이거 같이 해보실래요~?'라며 권유해 보는 '회고와 피드백 문화'를 만들기 위한 시도를 했습니다!\n\n같이 해보자고 말하기에는 '아, 거절당하면 어떡하지?', '안 그래도 바쁜 크루들에게 할 일을 더 쥐여주는 건 아닐까?'라는 생각이 들어서 망설여졌지만, 의외로 지금 같이 하고 있는 크루들이 긍정적인 반응을 해주셔서 너무 뿌듯했습니다.\n\n![피드백...](/assets/level-1-retrospect.png)\n\n레벨 1 전체 회고 글에서도 확인할 수 있듯이, 회고와 피드백 문화에 대해서 잘 적응하지 못해서 허우적댔지만 적응을 한 후, 문화를 만들어가고자 했던 제 모습에 놀라서 오히려 이런 제 모습에 적응해야 했습니다..ㅎ 😊\n\n### 즐거움과 일상을 잘 느끼고 싶어요\n\n우테코를 시작하기 전, 저는 굉장히 번아웃을 자주 느끼며 살아가던 사람이었습니다. 이와 관련해서, 레벨 1 방학식 날 공원과 면담을 했고\n\n> _즐거움을 느껴야, 학습이든 무엇이든 오래 지속할 수 있을 것 같아요._\n>\n> _일상을 잘 느끼면서 살아가는 것도 중요합니다._\n\n위와 같은 말씀을 해주셨고, 레벨 2에 적용해 보고자 했습니다. 어떻게 하면 '자연스럽게', '잘' 저의 레벨 2 생활에 적용할 수 있을까를 고민하다가 스스로 즐거움이 느껴지는지, 일상이 잘 느껴지는지에 대한 질문을 하고 답변을 해가면 쉽게 적용할 수 있을 것 같았습니다. 그리고, **달라진 내 모습에 적응하기** 문단에서 말한 것처럼, 우테코 생활을 같이하는 크루들에게 같이 이 질문에 답을 해보자고 제안 했습니다.\n\n혼자 질문에 답을 하고, 기록해 가는 것이 아니라 같이 해보자고 제안했던 것도 어쩌면 '크루들과 함께 시간을 보내는 제 일상'을 더 잘 느껴보기 위한 작은 시도가 아니었나 하는 생각을 해봅니다. 레벨 2에서 진행했던 스터디, 유강스 시간에 아래와 같은 질문들에 답을 해가며 즐거움과 일상을 잘 느끼려고 했던 것 같습니다.\n\n#### 1) 대성리(대성공 리액트 딥다이브 스터디)\n\n```\n1. 대성리 스터디원으로써 스스로의 모습에 만족하고 있는가?\n2. 현재 대성리 스터디가 나에게 도움이 되고 있는가, 스터디를 하기 위해 오는 길이 즐거운가?\n3. 대성리 스터디를 더 의미있게 진행할 수 있다면 어떤 방법이 있을까?\n```\n\n#### 2) 유강스 - '미션을 의미있게 진행해 보기 위한 질문지들'\n\n```\n미션 시작 전\n\n1. 이번 미션에서 가장 이루고 싶은게 무엇인가요?\n2. 학습 목표 중에서 이것 만큼은 꼭 가져가고 싶다고 생각한게 있나요? (이유도 함께 적어주면 좋아요!)\n3. 코치분들이 해당 미션을 만든 의도는 무엇일까요, 어떤 메시지를 저희한테 전달해주고 싶었을까요?\n\n미션 중간중간\n\n1. 혹시 지금 미션이 재미가 없나요? 만약, 재미가 없다면 왜 그런 감정이 느껴지는 것 같나요?\"\n\n2. 혹시 미션하다가 지금 막혔나요? 어디서 막혔나요? 공유해봐요!\n\n미션을 제출한 후\n\n1. 페어 프로그래밍을 하면서 개발적인 부분이 아니더라도 재밌었던 순간을 공유해봐요!\n\nex) 시모와 해리의 페어프로그래밍\n시모 : 해리 저번 리뷰어 누구였어요?\n해리 : 저 피터요\n시모 : 피터지게 리뷰 주고 받았겠네요\n해리 : 🤣🤣🤣🤣🤣🤣\n\n2. 이번 미션을 진행한 후, 본인에게 점수를 준다면 몇 점을 주고 싶나요? 점수 옆에 간단한 이유를 공유해봐요!\n\n5점: (내가 생각했을 때, 내 기준에 의한)완벽에 가까운 미션을 했다.\n4점: 나름 만족할만한 미션을 진행했다.\n3점: 보통이다.\n2점: 뭔가 씁....아쉽다.\n1점: 너무 아쉽다! 미션 다시 하고싶다.\"\n```\n\n스터디원들과 질문들에 답해보는 시간을 가지고, 그 답을 공유하면서 많은 의견을 나눌 수 있었고 확실히 혼자 하는 것보다 같이 하니 더 즐거웠고 일상도 더 잘 느껴졌던 것 같습니다.  \n(안 그래도 바쁜 레벨 2 생활에서 저의 권유에 흔쾌히 응해준 스터디원들에게 감사드립니다. 😊)\n\n## 결국 적응한다, 해낸다. 어떻게든\n\n인간은 **적응의 동물**이라고 합니다. 사람마다 다르겠지만, 충분한 시간이 주어진다면 어느 환경에 속하든 결국 적응은 할 수 있지 않을까 하는 생각이 들기도 합니다. 그런데도, 레벨 1, 2에서 발견한 제 모습은 '적응하기 위해서 의식적으로 노력하는 모습'이었기 때문에 '적응'을 주제로 기록해 보고자 하는 마음이 컸던 것 같습니다. 유강스 시간에 진행했던, 유수타(유연한 수다 타임)에서 저희 조의 주제는 '왜 유연해야 할까요?' 였고, 이에 대한 제 답은 **'일상을 더 잘 느끼기 위해서' 였습니다.**\n\n위에서 언급한 내용 이외에도, 매일 산책을 다니려고 시간을 내서 **제가 좋아하는 초록색 나무들과 꽃**을 보려고 하기도 하고, 매일 작성하는 일기에도 **한 줄로 오늘 하루를 요약하고 요약 문장에 어울리는 이모티콘을 붙여보는** 등 일상을 더 잘 느껴보기 위한 의식적인 노력을 하고 있어요. 사진을 잘 찍지는 못하지만, 산책하러 다니며 찍었던 사진들도 공유해 봅니다. 😊\n\n![](./assets/forest-3.jpg)\n![](./assets/forest-6.jpg)\n\n레벨 2의 끝자락인 지금, 제가 유강스 조원들이나 다른 크루들에게 자주 하는 말이 있습니다.\n\n> _\"개발이 나의 일상 자체가 되는 것이 아니라, 일상 속에 개발이 있었으면 합니다.\"_\n\n이 글을 읽어주고 계신 여러분들은 일상을 잘 느끼고 계신가요~? 일상을 보내면서 잘 먹고, 이쁜 풍경도 많이 보고, 주변 사람들과 재미있는 대화도 많이 하고, 많이 웃고, 푹 잘 잤으면 좋겠습니다. 긴 글 읽어주셔서 감사합니다.\n"},{"excerpt":"🖌️ 서론 자바스크립트는 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어다. 이번 글에서는 프로토타입에 초점을 맞추어 프로토타입이 무엇이고, 자바스크립트에서 프로토타입이 어떻게 이용되는지를 간단하게 알아보고자 한다. 추가로 배열 리터럴로 생성한 arr 이 어떻게 sort 와 같은 메서드를 사용할 수 있는지도 프…","fields":{"slug":"javascript-prototype"},"frontmatter":{"date":"April 12, 2024","title":"[Javascript] Javascript Prototype","tags":["Javascript","우아한테크코스"]},"rawMarkdownBody":"\n## 🖌️ 서론\n\n자바스크립트는 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어다.  \n이번 글에서는 프로토타입에 초점을 맞추어 프로토타입이 무엇이고, 자바스크립트에서 프로토타입이 어떻게 이용되는지를 간단하게 알아보고자 한다.\n\n```js\nconst arr = [1, 2, 3]\n\narr.sort((a, b) => a - b)\n```\n\n추가로 배열 리터럴로 생성한 arr 이 어떻게 sort 와 같은 메서드를 사용할 수 있는지도 프로토타입 관점에서 알아보고자 한다. 프로토타입에 대해서 이해하려면, 자바스크립트가 객체를 어떻게 바라보는지를 이해할 필요가 있다.  \n**자바스크립트는 클래스 기반 객체지향 언어인 Java, C++ 과 객체를 바라보는 시선이 약간 다르다.**\n\n## 💭 자바스크립트가 객체를 바라보는 시선\n\n우선 클래스 기반 객체지향 언어인 Java, C++이 객체를 어떻게 바라보는지를 알아보자. 클래스 기반 객체지향 언어는 이름에서도 알 수 있듯이 분류(Classification)를 통해 객체를 구분한다. 속성이 동일한 개체들이 있는 경우, 해당 개체들을 같은 범주로 묶을 수 있다고 본다. 여기서 속성은 프로그래밍 관점에서 봤을 때, 클래스(클래스로 생성된 인스턴스)의 프로퍼티가 된다. 프로퍼티가 유사한 객체가 있다면, 일반화 과정을 통해서 클래스로 추상화된다.\n\n이는 세상을 이분법적으로 나누어서 보았던, 서양철학과 연결된다. (영혼 / 육체, 추상 / 구체, 사물 / 본질)\n\n> _눈 앞에 실제로 존재하는 사물이 있다면 반드시 그 사물의 본질이 존재한다. - 플라톤_\n\n자전거를 예로 들자면 네발, 세발, 두발, 한발 자전거가 있을 것이며 이 때 반드시 본질적이고 추상적인 자전거가 존재한다고 본다.\n\n```js\nclass Cycle {\n...\n}\n\nCycle harryCycle = new Cycle();\n```\n\n추상적으로 존재하는 자전거(Cycle)가 new 연산자를 사용해서 현실세계에 구체적으로 존재(harryCycle)하게 된다고 본다.  \n하지만, [프로토타입 이론](https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85_%EC%9D%B4%EB%A1%A0)에서는 객체는 정의를 통해서 분류(Classification)되는 것이 아니라 가장 좋은 보기로 부터 범주화 되는 것이라고 본다.\n\n![](./assets//birds.png)\n\n- 이미지 출처 : https://laurabecker.gitlab.io/classes/as/08-semantics.pdf\n\n예를 들어, 인간이 새를 분류한다고 할 때 자연스럽게 가장 유사성이 높은 순새대로 등급을 매긴다고 본다.\n이렇게 분류했을 때, 가장 높은 등급이 나오는 새를 새의 원형(Prototype)으로 보는게 프로토타입 이론이다.\n\n즉, ‘가장 새 다운 것, 새스러운 것’을 새의 원형(Prototype) 이라고 본다. 위 예시에서는 참새가 새의 범주를 대표할만한 전형적인 새로 본다. 프로토타입 이론에는 객체를 유사성을 기준으로 바라보는 것 이외에 또 한 가지 중요한 것이 있다. 바로 같은 단어라고 할지라도 누가 어떤 상황(context)에서 사용했냐, 접했냐에 따라서 의미가 달라진다고 보는 것이다.\n\n예를 들어, 나(해리)가 생각했을 때는 새의 범주에 ‘오리’가 속할 수 있지만 지니가 생각했을 때는 새의 범주에 ‘오리’가 속하지 않을 수도 있다. 같은 단어(새)라도 어떤 상황(나 or 지니)에서 접했느냐에 따라서 범주(의미)가 크게 달라진다고 본다.\n\n이는 단어의 진정한 본래의 의미(전통적인 서양철학에서의 본질)은 존재하지 않고 단어의 의미는 사용하는 상황과 맥락에 의해 결정된다고 본 [비트켄슈타인의 의미 사용 이론](https://ko.wikipedia.org/wiki/%EC%96%B8%EC%96%B4%EB%86%80%EC%9D%B4)을 기반으로 한다.\n\n> _세계에 미리 내재되어서 대상과 언어를 완전히 규정하는 어떤 언어란 존재하지 않는다. — 비트겐슈타인_\n\n정리하자면 프로토타입 이론에서는\n\n- 가장 좋은 본보기를 원형으로 선택한다.\n- 특정 상황(문맥, 컨텍스트)에 따라서 특정 단어의 범주(의미)가 달라진다.\n\n고 본다.\n\n따라서, 프토토타입 기반 언어인 자바스크립트에서 객체에는 원형이 있다고 봤고, 새로운 객체를 만들 때 그 원형을 복제(참조)해서 만드는 방법을 사용했다.\n\n선언되는 위치(환경)에 따라 스코프(실행 컨텍스트 내 환경 레코드)가 결정되고, 사용되는 상황(문맥)에 따라서 this가 결정되는 자바스크립트의 특징이 떠오르지 않는가? 😊\n\n## 💭 자바스크립트에서 프로토타입\n\n위 내용에서 프로토타입은 어떤 범주에서 가장 좋은 보기, 원형이라고 했었다.  \n그렇다면, 자바스크립트에서 프로토타입은 어떻게 사용될까?  \n자바스크립트에서는 원시 타입의 값(String, Number, Boolean…)을 제외한 나머지 값(Array, Function,,,)들은 모두 객체이다. 객체는 다른 객체들과 메시지를 주고 받거나 데이터를 처리할 수도 있고, 다른 객체의 상태 데이터나 동작을 상속받아서 사용할 수도 있다. 이 때, 프로토타입이 상속을 위해서 사용된다.  \n자바스크립트에서는 어떤 객체를 원형(Prototype)으로 삼고 이를 복제함으로써 상속과 비슷한 효과를 내도록 한다.\n\n### prototype 객체\n\n프로토타입 객체는 상위 객체의 역할을 하는 객체로써, 다른 객체에 공유 프로퍼티를 제공할 수 있다. 프로토타입을 상속받은 하위 객체는 상위 객체의 프로퍼티를 자신의 프로퍼티처럼 자유롭게 사용할 수 있다.\n\n모든 객체는 [[Prototype]] 이라는 내부 슬롯을 가지며, 이 내부 슬롯의 값은 프로토타입(원형)에 대한 참조이다. 즉 [[Prototype]] 내부 슬롯은 해당 객체의 원형을 가르킨다(참조한다). [[Prototype]]이 참조하는 프로토타입 객체(상위 객체, 원형)는 객체 생성 방식에 따라서 결정된다.\n\n모든 객체는 하나의 프로토타입을 가지며 즉, 원형을 가지며 모든 프토토타입은 해당 객체를 생성한 생성자 함수와 연결되어 있다. 쉽게 말하자면, 생성자 함수의 프로퍼티에 프로토타입 객체가 있다.\n\n```js\nconst arr = [1, 2, 3]\n\narr.sort((a, b) => a - b)\n```\n\n배열 리터럴로 배열을 생성한 후, sort 메서드를 사용했던 위 예시를 다시 한번 살펴보자. 배열 리터럴로 생성된 배열도, Array 생성자 함수를 통해서 생성된 배열 객체로 볼 수 있으며 생성된 배열 객체 arr 의 [[Prototype]] 내부 슬롯은 Array 생성자 함수의 프로토타입 객체를 가르킨다.\n\n![](./assets/arr-array.png)\n\n![](./assets/arr-prototype.png)\n\n위 이미지에서도 확인할 수 있듯이, 배열 리터럴 방식으로 생성된 배열 객체의 [[Prototype]]은 Array 생성자 함수의 프로토타입 객체를 가르킨다.\n\n정리하자면, Array 생성자 함수를 통해 생성된 배열 객체는 생성자 함수의 프로토타입(원형)을 복제함으로써 생성되고 프로토타입 객체를 상속 받아서 자유롭게 사용할 수 있다.\n\n이로 인해서 extends 키워드를 사용하는 것과 같은 명시적인 상속 없이, 상위 객체의 메서드들을 사용할 수 있게 되는 것이다. 한가지 짚고 넘어가야할 점은, Array 생성자 함수의 프로토타입 내부에 있지 않은 from, of, isArray는 생성된 배열 객체에서 사용할 수 없다는 것이다. 오직 생성자 함수의 프로토타입 내부에 있는 프로퍼티나 메서드들을 상속 받아서 사용할 수 있다.  \nfrom, of, isArray와 같은 메서드들은 생성자 함수에서 직접 접근해야 실행이 가능하다. 이 메서드들을 스태틱 또는 정적 메서드라고 한다.\n\n```js\nconst arr = [1, 2, 3]\n\nconsole.log(Array.isArray(arr)) // true\n\nconsole.log(arr.isArray(arr)) // TypeError : arr.isArray is not a function\n```\n\n생성된 배열 객체에서 `isArray` 메서드를 호출하려고 하면 TypeError가 발생한다.\n\n### `__proto__` 프로퍼티\n\n모든 객체는 `__proto__` 접근자 프로퍼티를 가지며, 해당 프로퍼티를 통해서 자신의 프로토타입(원형) 즉, [[Prototype]] 내부 슬롯에 간접적으로 접근할 수 있다.\n\n자바스크립트는 원칙적으로 [[Prototype]]과 같은 내부 슬롯에 직접 접근하는 방법을 제공하지 않기 때문에, 간접적으로 프로토타입 객체를 참조할 수 있는 방법인 `__proto__` 접근자 프로퍼터를 제공한다. 자바스크립트 엔진은 객체의 프로퍼티에 접근하려고 할 때, 해당 객체에 접근하려는 프로퍼티가 없다면 `__proto__` 접근자 프로퍼티가 가리키는 참조를 따라서 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다.\n\n위 배열 예시에서도, 생성된 배열 객체(arr)에는 sort 메서드가 존재하지 않기 때문에 `__proto__` 접근자 프로퍼티를 사용해서 배열 객체의 프로토타입인 Array 생성자 함수의 프로토타입에서 sort 메서드를 검색한 후 사용한 것이다.\n\n![](./assets/circle-prototype.png)\n\n```js\nconst arr = [1, 2, 3]\n\nconsole.log(arr.__proto__ === Array.prototype) // true\n\nconsole.log(arr.hasOwnProperty(\"__proto__\")) // false\n\nconsole.log(Object.prototype.hasOwnProperty(\"__proto__\")) // true\n```\n\n한가지 짚고 넘어가야할 점은, 위 이미지처럼 `__proto__` 접근자 프로퍼티는 생성된 객체가 직접 소유하는 숨겨진 프로퍼티가 아니라 자바스크립트의 최상위 객체인 `Object.prototype`의 프로퍼티이다.\n\n모든 객체는 Object.prototype의 상속을 통해서 `Object.prototype.__proto__` 를 사용할 수 있다.\n\n### 🤔 복제한다는 것의 의미\n\n프로토타입에 대해서 학습하면서,\n\n> _어떤 객체를 원형(Prototype)으로 삼고 이를 복제함으로써 상속과 비슷한 효과를 내도록 한다._\n\n이 문장이 개인적으로 잘 와닿지 않았었다. 특히 “복제”한다는 것이 제일 와닿지 않았는데 간단한 예시를 통해서 어느 정도 이해할 수 있었다.\n\n```js\nconst arr = [1, 2, 3]\nconst brr = [4, 5, 6]\nconsole.log(arr.__proto__ === brr.__proto__)\n```\n\n`console.log(arr.sort === brr.sort);`\n위 코드에서 각각 콘솔에는 무엇이 출력될까?  \n모두 true 가 출력된다.\n\n![](./assets/circle-prototype-2.png)\n\n위 이미지에서 확인할 수 있듯, 생성된 배열 객체의 프로토타입은 모두 Array 생성자 함수의 프로토타입을 가르키고 있다.  \nArray 생성자 함수의 프로토타입을 원형으로 삼고, 이를 복제하여 배열 객체를 생성한 것이며 생성된 배열 객체들이 **proto** 프로퍼티를 통해서 참조하게되는 프로토타입은 모두 같은 프로토타입이다.  \n`프로토타입(원형)을 복제한다 === 생성된 배열 객체들이 모두 같은 프로토타입을 참조한다` 로 해석할 수 있다.\n\n## 💭 프로토타입 체인\n\n자바스크립트는 객체의 프로퍼티에 접근하려고 할 때, 해당 객체에 접근하려는 프로퍼티가 없다면 `__proto__` 접근자 프로퍼티를 통해서 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다고 했었다.\n\n이를 프로토타입 체인이라고 하며, 프로토타입 체인은 상속과 프로퍼티 검색을 위한 매커니즘이라고 할 수 있다.\n\n```js\nconst arr = [1, 2, 3]\n\narr.name = \"harry\"\n\nconsole.log(arr.hasOwnProperty(\"name\")) // true\n```\n\n배열 객체에 특정 프로퍼티를 추가하는 경우는 흔하지 않지만, 프로토타입 체인 과정을 이해해보기 위해서 위 코드와 같은 배열 객체가 있다고 가정해보자.\n\n![](./assets/circle-prototype-3.png)\n\n`hasOwnProperty` 메서드를 호출하면, 다음과 같은 과정을 거쳐서 메서드를 검색한다.\n\n1. Array.prototype\n\n우선, 해당 메서드를 호출한 arr 배열 객체에서 `hasOwnProperty`를 검색한다.\n\n메서드가 존재하지 않으므로 프로토타입 체인을 따라서 즉, [[Prototype]] 내부 슬롯에 바인딩되어 있는 프토로타입(원형)으로 이동하여 hasOwnProperty를 검색한다.\n\n2. Object.prototype\n\nArray.prototype에도 hasOwnProperty가 존재하지 않는다.\n\n따라서, 다시 프로토타입 체인을 따라서 즉, Array.prototype 객체의 [[Prototype]] 내부 슬롯에 바인딩되어 있는 프토토타입(원형)인 Object.prototype으로 이동하여 hasOwnProperty를 검색한다.  \n(자바스크립트에서 프로토타입의 프로토타입은 언제나 최상위 객체인 Object.prototype이다.)\n\n프로토타입 체인의 최상위에 위치하는 객체는 언제나 Object.prototype이다. 따라서 모든 객체는 Object.prototype을 상속받는다.  \n즉, 자바스크립트에서는 가장 객체 다운 것, 객체스러운 것을 Object.prototype(원형)으로 봤으며 이 원형을 복제해서 새로운 객체를 만들도록 했다.\n\n반면, 객체의 프로퍼티가 아닌 식별자는 스코프 체인에서 검색한다. 자바스크립트 엔진은 함수들의 중첩 관계로 이루어진 스코프의 계층적 구조에서 식별자를 검색 식별자를 검색한다.\n따라서, 스코프 체인은 식별자 검색을 위한 매커니즘이라고 할 수 있다.\n\n## 📚 정리\n\n- 프로토타입은 어떤 범주에서 가장 좋은 보기, 원형이다.\n- 자바스크립트에서 어떤 객체를 원형(Prototype)으로 삼고 이를 복제함으로써 상속과 비슷한 효과를 낸다.\n- 자바스크립트에서 모든 객체는 하나의 프로토타입을 가지며 즉, 원형을 가지며 모든 프토토타입은 해당 객체를 생성한 생성자 함수와 연결되어 있다.\n- 프로토타입 체인은 상속과 프로퍼티 검색을 위한 매커니즘이다.\n\n## 🔗 참고\n\n- https://medium.com/@limsungmook/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%99%9C-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%84-%EC%84%A0%ED%83%9D%ED%96%88%EC%9D%84%EA%B9%8C-997f985adb42\n"},{"excerpt":"레벨 1을 마무리 하고, 방학을 시작한지 5일 정도가 되었다.\n레벨 1에서 내가 주로 느꼈던 감정들과 생각들을 지금이라도 기록하고자 한다...! 남이 뭘 하든, 남이 뭐라하든 말든 마인드 항상 '그랬구나, 그럴 수도 있겠구나...' 마인드를 가지고 살아왔다.\n친구들과 얘기를 나누는 와중에 생각이 다르면 '저 친구는 저렇게 생각하구나...'라며 넘겼고, 친…","fields":{"slug":"woowacourse-level-1-retrospect"},"frontmatter":{"date":"April 10, 2024","title":"우아한테크코스 레벨1을 돌아보며","tags":["회고","우아한테크코스"]},"rawMarkdownBody":"\n레벨 1을 마무리 하고, 방학을 시작한지 5일 정도가 되었다.\n레벨 1에서 내가 주로 느꼈던 감정들과 생각들을 지금이라도 기록하고자 한다...!\n\n## 남이 뭘 하든, 남이 뭐라하든 말든 마인드\n\n항상 '그랬구나, 그럴 수도 있겠구나...' 마인드를 가지고 살아왔다.\n친구들과 얘기를 나누는 와중에 생각이 다르면 '저 친구는 저렇게 생각하구나...'라며 넘겼고, 친구들이 들려주는 다른 친구들과의 에피소드들을 들어도 '아하...저런 일이 있었구나'라며 넘겼다.\n\n공감을 잘 하지 않았고, 공감을 하려고 시도하지도 않았다. 억지로 해주는 공감은 안하느니 못하다고 생각했고, '알아서 잘 하겠지?'라는 생각과, '내가 조언이나 충고를 해준다고 해서 달라지는게 있을까?'라는 의심이 있었다. 그저 옆에서 들어주고 \"응.. 응..? 응..!\" 해주는게 다였다. 현실적으로 도움이 될만한 해결책을 몇가지 제시해주는 정도...? (~~어차피 우린 다르니까!~~)\n\n이런 마인드를 가지고 살아가다 보니, 다른 사람들의 행동을 주의 깊게 관찰하거나, 다른 사람들의 생각에 대해서 깊게 고민해 본 경험이 거의 없었다. 그냥 다른 사람들의 행동과 생각들을 눈에 보이는 있는 그대로 받아들였고, 받아들이는 것 이상의 무언가를 해보려는 시도를 하지 않았다.\n\n![일단 듣기는 하는데...](./assets/level-1-1.jpeg)\n\n우테코를 시작한 지 얼마 지나지 않아 지금까지 가지고 있던 마인드를 고쳐야 한다는 필요성을 느꼈다. 피드백을 주고받는 상황이 생각보다 정말 많았기 때문이다.\n\n페어 프로그래밍이 끝나자마자 각 미션의 페어는 서로를 피드백하고, 리뷰어들과도 서로를 피드백한다. 그리고 코치님들의 수업이 끝나자마자 피드백을 전달해 드려야 하며, 매주 진행하는 유연성 강화 스터디에서도 연극 조끼리 서로 피드백 해야 했다. 글쓰기 미션을 진행할 때도 같은 조 크루들의 글에 대해서도 피드백을 전달해 줘야 한다.\n\n처음에는 정말 힘들었다. '이렇게까지 서로가 서로를 피드백 한다고?', '난 누구를 피드백 해본 적이 거의 없는걸... 도대체 피드백은 어떻게 하는 거야?'라는 생각이 나를 너무 힘들게 했다. 특히 지금까지 내가 살아오면서 가졌던 마인드 셋은 다른 사람들에게 피드백을 전달해 주기 너무 힘든 마인드 셋이었다.\n\n## 조금 달라져볼까?\n\n각 미션이 끝나면 페어가 해준 피드백과 리뷰어가 해준 피드백 내용을 확인할 수 있다. **피드백 내용을 읽으면서 내가 지금까지 몰랐던 나의 모습을 정말 많이 발견할 수 있었다.** 해당 내용이 설탕같이 달고 듣기 좋든, 채찍같이 조금 아프든 '다른 사람들 눈에는 내가 이렇게 보일 수도 있겠구나'를 많이 느꼈다. 그리고 해당 내용들을 통해 앞으로 우테코 생활을 어떻게 해갈지에 대한 방향도 잡을 수 있어서 나에게 정말 많은 도움이 되었다.\n\n우테코에 오기 전 내 모습과 내 주변 상황들을 다시 떠올려보면, 난 다른 사람들의 행동과 생각에 대해 피드백을 해본 경험이 거의 없지만, 반대로 **내가 다른 사람들에게 내 행동과 생각에 대해 피드백을 받아본 경험도 거의 없었다.**\n\n너무나도 새로운 환경이었다. 거의 매일매일 피드백 속에서 생활해야 한다니...\n하지만, 크루들이나 리뷰어들이 나에게 해준 피드백들은 나에게 정말 많은 도움이 되었으며, 도움을 받은 만큼 나도 도움을 주고 싶었다. 그래서, 조금 달라져 보기로 했다. 지금부터라도 다른 사람들의 행동과 생각에 대해서 조금 깊게 대해보는 것으로.\n\n나와 의견이 다른 사람이 있으면 그냥 저 사람은 저렇게 생각하구나가 아닌 '왜 다르지? 어떻게 다르지?'에 대한 궁금증을 가졌다. 리뷰어가 내 PR 메시지를 읽고, 내 코드를 보며 피드백을 해줄 때에도 나와 의견이 다르면\n\n> '리뷰어는 왜 이렇게 고민해 보는 것을 권장하지?\n>\n> '이 코드에 대해서는 어떻게 생각할까?'\n\n에 대한 궁금증을 가졌다.\n매주 진행하는 유강스(유연성 강화 스터디)에도 연극 조원들이 목표를 잘 달성해나가고 있는지에 대해 집중해서 피드백을 전달해 주고 싶었고, 내 피드백이 조금이라도 도움이 되었으면 했다.\n\n우테코 생활을 두 달 정도 하면서, 스스로도 지금까지 보지 못했던 모습을 발견할 수 있었다.\n바로 생각보다 다른 사람의 이야기를 듣는 것을 좋아하며, 다른 사람들의 행동과 생각에 관심이 많다는 것이었다. 특히 나와 관심사가 비슷한다면. 나를 포함한 프론트엔드 크루들은 프론트엔드 공부(JS, TS, React 등등..)라는 공통된 관심사를 가지고 있을 것이다. 공통된 관심사를 가진 사람들이 모인 이 환경에서 주고받는 생각들과 이야기들은 정말 흥미로웠다.\n\n노이즈 캔슬링 헤드셋을 끼고 미션을 하고 있다가도, JS에 대한 토론을 하고 있는 작은 소리가 들리면 노이즈 캔슬링 효과는 사라졌다. '어... 재밌겠다!'라는 생각으로 어느 순간부터 옆에 붙어서 같이 얘기를 하고 있었다. (~~더 비싸고 효과 좋은 노이즈 캔슬링 헤드셋이 필요할지도...~~)\n\n레벨 1 때 스터디를 진행하지는 않았지만, 스터디를 진행 한 크루들은 어떻게 진행했는지에 대한 궁금증이 생겨서 찾아가서 인터뷰를 해보기도 했다. 남이 어떻게 생각하든 말든, 남이 나한테 뭐라 하든 말든 하나도 신경 쓰지 않던 내가 자발적으로 다른 사람들의 이야기를 들어보기 위해서 인터뷰를 하다니...많이 놀라웠다. (삐걱삐걱 인터뷰에 응해주었던 딩코 스터디 크루들과, 썬데이와 파슬리에게 감사드리며...🙇‍♂️) 우테코 생활을 시작하고, 나도 몰랐던 나의 모습을 발견할 수 있던 순간들은 정말 소중했다.\n\n다른 사람들이 발견해 준 내 모습, 스스로 발견한 내 모습 모두 앞으로의 우테코 생활을 어떻게 해나갈지에 대한 방향성을 잡을 수 있는 귀중한 피드백들이었다. (피드백 해준 분들 모두 감사합니다 🍀)\n\n## \"정답은 없다\"에 적응하기\n\n우테코를 시작한 지 얼마 되지 않았을 때, 다른 사람들을 피드백 하는 것만큼 나를 정말 힘들게 했던 문장이 있었다.\n바로 \"정답은 없다\"라는 문장이었다.\n\n고등학생, 반수, 대학생 시절 모두 5지 선다형 문제 아니면 주관식에 정해진 정답을 골라야 하는 환경에서 공부를 해왔었고, 이 환경에 익숙해지다 보니 자연스럽게 좋은 코드와 좋은 소프트웨어 개발에도 정답이 있다고 생각했었다. 우테코에서 진행하는 미션과 몇몇 활동들 모두 그 정답을 찾아가는 과정이라고 여겼다.\n\n하지만, 우테코에 와서 \"정답은 없다\"라는 말이 종종 들릴 때마다 '네...? 왜 없는건가요?'를 속으로 정말 많이 생각했다. (여긴 도대체 어디야...)\n\n> ??? : 내 리뷰어는 `Object.freeze` 사용 왜 했냐던데?\n>\n> ??? : 엥, 내 리뷰어는 `Object.freeze` 사용 잘했다던데?\n\n이런 대화가 들릴 때마다 너무나도 혼란스러웠다. (~~집에 가고 싶은걸...?~~) 동일한 코드에 대해서도 리뷰어들의 의견은 달랐고, 피드백도 천차만별이었다. 특정 메서드를 사용해야 하는 상황과 그렇지 않은 상황에 대한 정답이 있을 것이라 생각했는데... 그런 것은 없었다.\n\n![이제 내가 여기에 찍을 정답 따위는 없다.](./assets/level-1-2.webp)\n\n한 미션을 대하는 방법도 크루들마다 달랐고, 미션을 진행할 때 거쳤던 생각들도 달랐으며, 구현된 코드 또한 비슷한 크루들도 있었지만 대부분 달랐다. 그리고 그 어디에도 정답은 없었다.\n\n하지만, 정답이 없는 것은 어쩌면 당연한 것일지도 모른다. **존재하지 않는 정답을 찾으려 하기보다는 다양한 의견들을 주고받으면서 자신만의 주관과 의견을 만들어가는 것이 더 중요한 것**이었다. 미션의 학습 목표를 달성하기 위해서 어떤 고민들을 거쳤는지 공유하고, 그 고민을 코드에 녹여낸 방법을 공유하고, 받은 피드백들을 공유하면서 **수많은 정보와 의견들 속에서 \"내 의견\"을 만들어 가는 과정이 더 중요한 것**이었다. 우테코에서의 학습은 정답을 찾기 위한 학습이 아니라, 프로그래밍이든 소프트 스킬이든 그 속에서 내 모습과 페이스를 찾아가는 학습이었다.\n\n이걸 느낀 순간부터는 나도 '정답은 없다'라고 말하고 있다. 정답은 없고 각자의 의견만 있을 뿐...\n\n## 유연함에 대하여\n\n> 레벨 1 생활을 유연하게 했는가?\n\n이 질문에 대해서는 생각보다 유연하게 잘 했다고 대답할 수 있다. 우테코 생활을 하면서 생각보다 할 일들이 많았다. 미션과 피드백 반영, 미션에서 놓친 부분들 학습, 글쓰기 미션, 메타인지 말하기 활동 준비, 유연성 강화 스터디 내용 준비 등등 생각했던 것보다 너무 많은 할 일들이 있었다. 모든 것을 잘 해내고 싶다는 욕심과 비례해서 할 일들이 점점 쌓여갔고, 그럴 때마다 '내가 이걸 다 해낼 수 있을까'에 대한 자기 의심도 많이 했다. 자연스럽게 선릉 캠퍼스 왔다 감 고정 멤버가 되었고, 주말에는 잠실 캠퍼스로 출근했다. 많은 일을 하는 만큼 많은 성장을 할 수 있다는 것은 좋았지만, 한편으로는 수능을 다시 준비했던 시절과 연구실을 다니던 시절처럼 또다시 번아웃이 찾아오지 않을까 하는 걱정도 많이 했다.\n\n이 걱정은 매주 진행하는 유연성 강화 스터디를 통해 많이 해소되었다. 지친 것 같은 순간이 찾아올 때마다, 뇌가 멈춰버리고 아무 생각 없이 자리만 지키고 있었던 번아웃을 느낄 것 같은 순간이 찾아올 때마다 나의 레벨 1 유연성 강화 목표를 의식적으로 떠올렸다.\n\n> '방금 정한 내 목표는 또 너무 크고 추상적이지 않나? 조금 작더라도 목표를 구체화해보는 게 어떨까?'\n>\n> '나 지금 지친 것 같은데, 이 내용은 나중에 무조건 공부하게 될 것이니 지금 체력을 깎아먹으면서까지 억지로 할 필요는 없지 않을까?'\n\n위와 같은 생각을 계속 의식적으로 떠올리면서, 꾸준해야만 한다는 압박감 속에서 긴장을 하며 살아가던 내가 보다 유연하게 레벨 1 생활을 할 수 있었다. 유연성 강화 스터디를 하면서 스스로를 너무 혹사시키지 않고, 부드럽게 대했던 모습도 발견할 수 있었다. 단, 이 모든 것들은 혼자 했으면 절대 못했을 것이다. (나의 레벨 1 글쓰기 미션이 궁금하다면?)\n\n매 주말마다 하는 한강 러닝도 내 유연성에 정말 많은 도움을 주었다. 우테코를 시작하기 전, 부산에서 생활했을 때는 달리기에는 전혀 관심이 없었다. 단지 달리기가 멘탈 강화에 정말 좋은 운동이라는 것만 알고 있는 정도였다. 스스로 멘탈이 약한 사람이라고 생각하며 살아왔고, 달리기가 내 약한 멘탈에 도움이 될지 궁금했다. 그리고, 서울에는 뛸 곳이 굉장히 많으니 이 환경을 이용해 보고자 했다.\n\n달릴 때는 거의 아무런 생각을 하지 않는다. 계속해서 달리는 것에 집중해야 하기 때문에 다른 생각을 할 수 없다고 말하는 게 맞겠다. (진짜 힘들다...)\n\n하지만, 억지로라도 아무런 생각을 하지 않도록 하는 시간이 나에겐 너무나도 필요한 시간들이었다. 미션을 진행하면서 해결하지 못한 부분을 계속해서 생각하거나, 더 잘 하고 완벽하게 하고 싶어서 고뇌하던 시간들에서 잠시라도 벗어났기 때문에 보다 유연한 생활을 할 수 있었다. 만약, 달리지 않았었더라면 맥북을 보고 있든 아니든, 옆에 누가 있든 말든 계속해서 내가 해결해야만 하는 문제들을 생각했을 것이며 지쳤을 것이고 번아웃으로 끌려갔을 것이다. 달리는 행위에만 집중해야 했던 순간들과, 오늘 뛰기로 설정한 거리를 모두 다 달렸을 때 느낄 수 있었던 상쾌함은 다음 주 우테코 생활을 더 유연하면서도 단단하게 할 수 있도록 도와주었다.\n\n레벨 2에도 달리기는 필수야...!\n\n![](./assets/level-1-3.png)\n\n## 불안해서가 아닌 재밌어서\n\n지금까지 학습을 하지 않으면 안 될 것 같아서 했었다. 그리고 남들이 하니까 따라서 했었다. 특히 고등학생 때 했던 학습에서는 즐거움을 느낀 적이 거의 없었으며, '이걸 왜 하지?'라는 생각만 했다. 억지로 하고 싶지 않아서, 야간 자율학습도 많이 도망갔고 하는 척을 많이 했다. (이러니까 수능 두 번 치지...ㅋ)\n\n이후 컴퓨터 공학을 전공으로 바꾸면서, 적성에 맞는다는 것을 느꼈고 자연스럽게 재미를 느꼈다. 누가 시키지 않았는데도, 자발적으로 학습을 한 것은 처음이 아니었을까 싶다. 중간중간 번아웃도 느꼈지만, 잠시 자책하는 시간(?)과 휴식을 가지면서 계속 학습했었고 우테코까지 오게 되었다. 우테코 생활을 시작한 지 얼마 되지 않았을 때는 지금까지 해왔던 학습 방식, 분위기와는 너무나도 달라서 적응하는 데 조금 걸렸지만, 하지 않으면 안 될 것 같아서라는 생각으로 억지로 학습했던 적은 없다. 내가 관심 있어 하는 분야를 다른 크루들도 관심 있어 하며, 크루들은 내 이야기를 잘 들어주고, 나 또한 크루들의 이야기를 듣는 것이 재밌다.\n\n레벨 2에서도 자발적으로, 재밌게 학습하고 성장하고 싶다! 레벨 1 안녕 👋🏻🍀 (~~레벨 2는 조금만 더 뒤에 만나고 싶다...~~)\n"},{"excerpt":"🍀 실행 컨텍스트 실행 컨텍스트는 자바스크립트 엔진이 코드를 실행하기 위해서 필요로 하는 정보(환경)들이 담겨있는 객체이다. 코드를 실행할 때, 특정 환경에 있는 환경 정보들을 모은 실행 컨텍스트를 콜스택에 쌓아올린 후 실행한다. 여기서, 특정 환경이란 전역 공간이 될 수도 있고 함수 내부의 공간이 될 수도 있다. 이 때, 스코프, 식별자, 코드 실행 순…","fields":{"slug":"javascript-execution-context"},"frontmatter":{"date":"April 09, 2024","title":"[Javascript] Javascript Execution Context & Scope","tags":["Javascript","우아한테크코스"]},"rawMarkdownBody":"\n## 🍀 실행 컨텍스트\n\n실행 컨텍스트는 자바스크립트 엔진이 코드를 실행하기 위해서 필요로 하는 정보(환경)들이 담겨있는 객체이다. 코드를 실행할 때, 특정 환경에 있는 환경 정보들을 모은 실행 컨텍스트를 콜스택에 쌓아올린 후 실행한다.  \n여기서, 특정 환경이란 전역 공간이 될 수도 있고 함수 내부의 공간이 될 수도 있다. 이 때, 스코프, 식별자, 코드 실행 순서들의 관리가 필요한데 이 모든 것을 관리하기 위해서 실행 컨텍스트가 필요하다.\n\n이번 글에서는 호이스팅, 스코프와 함께 자바스크립트의 동작 원리를 담고 있는 핵심 개념인 실행 컨텍스트에 대해서 알아보자.\n\n### 소스 코드의 평가와 실행\n\n자바스크립트로 작성한 모든 소스 코드는 실행에 앞서 평가 과정을 거치며, 평가를 통해서 실행을 위한 준비를 한다. 자바스크립트 엔진은 코드를 평가와 실행 두 가지 과정으로 나누어서 처리한다.\n\n평가 과정에서는\n\n- 실행 컨텍스트를 생성한다.\n\n- 변수, 함수 등의 **선언문만 먼저 실행**하여 식별자(변수, 함수, 클래스 이름)를 키로 실행 컨텍스트 → 렉시컬 환경 → 환경 레코드에 등록한다.\n\n평가 과정이 끝나면 비로소 코드가 실행되는 런타임이 시작되며, **선언문을 제외한 나머지 코드를 순차적으로 실행한다.** 이 때, 실행에 필요한 정보를 평가 과정에서 생성된 실행 컨텍스트를 통해 얻는다.\n\n### 실행 컨텍스트의 역할\n\n```js\nvar harryAge = 26\n\nconst address = \"busan\"\n\nfunction bar() {\n  var harryAge = 20\n\n  console.log(\"해리의 나이는\", harryAge, \"입니다.\")\n\n  function foo() {\n    var nickName = \"harry\"\n\n    console.log(nickName)\n    console.log(harryAge)\n    console.log(harryHobby) // Error!\n  }\n\n  foo()\n}\n\nbar()\n\nconsole.log(\"해리의 나이는\", harryAge, \"입니다.\")\n```\n\n위 코드의 실행되는 과정을 간단하게 살펴보며, 실행 컨텍스트의 역할에 대해서 알아보자.\n\n![](./assets/call-stack.png)\n\n1. **전역 코드 평가**\n\n위 코드를 실행하기 전, 평가 과정을 거치며 전역 코드를 실행하기 위한 준비를 한다. 이 때, 전역 실행 컨텍스트가 콜스택에 담긴다. 전역 코드의 변수 선언문과 함수 선언문이 먼저 실행되고, 생성된 전역 변수(harry)와 전역함수(bar)가 전역 실행 컨텍스트가 관리하는 전역 스코프에 등록된다.  \nvar 키워드로 선언된 전역 변수와 함수 선언문은 전역 객체(브라우저의 경우 window, Node.js의 경우 global)의 프로퍼티와 메서드가 된다.\n\n2. **전역 코드 실행**\n\n전역 코드의 평가가 끝난 후, 코드가 실행되는 런타임이 시작되어 전역 코드가 순차적으로 실행된다. 이 때, 변수 값을 할당하거나, 함수를 호출한다. 코드를 실행하던 중, bar 함수가 호출되어 해당 함수를 실행하기 위한 준비를 한다.  \n함수가 호출되면 기존에 실행중이던 전역 코드의 실행을 일시 중단한다.\n\n3. **bar 함수 코드 평가**\n\nbar 함수 내부 코드를 실행하기 전 평가 과정을 거치며 코드 실행을 위한 준비를 한다. 즉, bar 함수의 환경 정보들을 수집해 실행 컨텍스트를 생성하고 콜스택에 담는다. 매개변수, 지역 변수의 선언문이 먼저 실행되고 함수 실행 컨텍스트가 관리하는 지역 스코프에 등록된다.\n\n4. **bar 함수 코드 실행, foo 함수 코드 평가 및 실행**\n\nbar 함수 코드의 평가가 끝난 후, 함수 내부 코드가 순차적으로 실행된다. bar 함수 내부 코드를 순차적으로 실행하던 중, foo 함수가 호출 되었다.  \n마찬가지로, 기존에 실행중이던 bar 함수 내부 코드의 실행을 일시 중단하고, foo 함수를 실행하기 전 평가 과정을 거치며 코드 실행을 위해 준비한다. foo 함수의 환경 정보들을 수집해 실행 컨텍스트를 생성하고 콜스택에 담는다. 이 후 코드가 순차적으로 실행된다.\n\n5. **실행 종료 및 콜스택에서 제거**\n\nfoo 함수 코드 실행이 완료되면, 콜스택에서 제거된다. 이 후, bar 함수 내부에서 foo 함수 호출로 인해 일시 중단되었던 지점부터 다시 코드를 실행하고 완료되면 콜스택에서 제거된다.\n\n전역 코드에서도 bar 함수 호출로 인해 일시 중단되었던 지점부터 다시 코드를 실행하고 전역에서 실행할 코드가 더이상 남아있지 않다면 전역 실행 컨텍스트 또한 콜스택에서 제거되어 모든 코드의 실행이 종료된다.\n\n위 순서에서 확인할 수 있듯, 자바스크립트에서 코드를 실행하려면 스코프, 식별자, 실행 순서 등의 관리가 필요하며 **이 모든 것을 관리하는 것이 실행 컨텍스트이다.**\n실행 컨텍스트는 식별자(변수, 함수, 클래스 이름)을 관리하고 스코프와 코드 실행 순서 관리를 위해 필요하며 모든 코드는 실행 컨텍스트를 통해 관리되고 실행된다고 할 수 있다.\n\n식별자, 스코프는 실행 컨텍스트 내부 렉시컬 환경으로 관리하고 코드 실행 순서는 실행 컨텍스트 스택(콜스택)으로 관리한다.\n\n### 렉시컬 환경\n\n렉시컬 환경은 실행 컨텍스트를 구성하는 하나의 단위이며, 다시 환경 레코드, 외부 렉시컬 환경에 대한 참조로 구분된다.  \n렉시컬 환경은 키, 값을 갖는 객체 형태의 스코프를 생성하여 식별자를 키로 등록하고 식별자에 바인딩 된 값을 관리한다. 그리고 렉시컬 환경에 상위 스코프에 대한 참조를 기록한다.\n\n즉, 렉시컬 환경은 스코프를 구분하여 **식별자를 등록하고 관리할 수 있는 저장소 역할을 한다.**\n\n![이미지 크기가 너무 커지는 것을 방지하기 위해서 실행 컨텍스트 스택을 눕혔다.](./assets/excution-context.png)\n\n- 환경 레코드\n\n스코프에 포함된 식별자를 등록하고 식별자에 바인딩 된 값을 저장하는 저장소이다.\n\n- 외부 렉시컬 환경에 대한 참조\n\n외부 렉시컬 환경에 대한 참조는 상위 스코프를 가르킨다. 상위 스코프란, 외부 렉시컬 환경을 말하며 즉, 해당 실행 컨텍스트를 생성한 소스 코드를 포함하는 상위 실행 컨텍스트의 렉시컬 환경을 말한다.\n\n정리하자면, **환경 레코드와 외부 렉시컬 환경에 대한 참조 를 통해서 스코프를 생성하고 관리**할 수 있다.\n\n실행 컨텍스트의 역할 부분의 코드 예시를 통해 조금 더 알아보자. 이 글에서는 전역 코드의 평가 과정에서 생성되는 전역 실행 컨텍스트에 대해서 다뤄본다.\n\n### 전역 실행 컨텍스트\n\n![](./assets/global-excution-context.png)\n\n- 환경 레코의 구성\n\nvar 키워드와 ES6의 let, const 키워드로 선언한 전역 변수를 구분하기 위해서 전역 환경 레코드는 다시 객체 환경 레코드와 선언적 환경 레코드로 구분된다. 객체 환경 레코드는 기존의 전역 객체가 관리하던 var 키워드로 선언한 전역 변수와 함수 선언문으로 정의한 함수, 표준 빌트인 객체(Number, Math,,,)를 관리한다.\n\n반면, 선언적 환경 레코드는 let, const 키워드로 선언한 전역 변수를 관리한다. 실행 컨텍스트가 생성될 때 구성되는 환경 레코드를 통해 특정 코드 환경의 스코프를 결정할 수 있다.\n\n- 외부 렉시컬 환경에 대한 참조 정하기\n\n외부 렉시컬 환경에 대한 참조는 현재 평가 중인 소스 코드를 포함하는 외부 소스 코드의 렉시컬 환경, 즉 상위 스코프를 가르킨다.\n\n```js\nvar harryAge = 26\n\nfunction sayHi() {\n  console.log(\"hi\")\n}\n```\n\n(위와 같은 코드가 있을 때, 전역 코드는 sayHi 함수 코드를 포함한다고 할 수 있다.)\n\n이를 통해서 **단방향 링크드 리스트인 스코프 체인**을 구현할 수 있다. 현재 평가중인 소스 코드는 전역 코드이고, 전역 코드를 포함하는 소스 코드는 없으므로 외부 렉시컬 환경에 대한 참조에 null이 할당된다.\n\n## 💭 호이스팅 알아보기\n\n실행 컨텍스트가 생성되는 과정과 내부 구성에 대해서 간략하게 알아보았다.  \n이제 자바스크립트의 특징 중 하나인 호이스팅에 대해서 알아보자. 호이스팅은 실행 컨텍스트 개념과 관련이 있는 개념이다 :)\n\n### 변수 호이스팅\n\n```js\nconsole.log(harryAge) // ?\n\nvar harryAge = 26\nconsole.log(harryAge) // 26\n```\n\n위 코드를 살펴보자. harryAge 변수(식별자)에 26 이라는 숫자 타입의 변수 값을 할당했다. 할당 후에 콘솔에 harryAge를 출력해보면 26이 출력될 것이다.  \n그렇다면, harryAge 변수의 선언과 할당 전에 콘솔에 출력해보면 어떤 결과가 출력될까?\n\n```js\nconsole.log(harryAge) // undefined\n\nvar harryAge = 26\n```\n\n선언과 할당을 하기 전이지만, 에러가 발생하지 않고 undefined 가 출력된다. 이 현상을 호이스팅 이라고 하며, 호이스팅은 선언문이 최상단에 끌어올려진 듯한 현상을 말한다.  \n이 현상의 이유에 대해서 간단하게 알아보자.\n\n![](./assets/hoisting.png)\n\n평가 과정에서는 선언문만 먼저 실행되며, 이 과정에서 harryAge는 undefined로 할당되어 환경 레코드에 등록된다. 더 이상의 선언문이 없으므로 평가 과정이 종료되며, 코드가 실행된다. 첫 번째 console.log 를 실행할 때, 환경 레코드 내부에 harryAge가 undefined 값을 가지고 있으므로 undefined를 출력한다.\n\n이 후, harryAge 변수 값이 26으로 재할당된다.\n\n두 번째 console.log 를 실행할 때, 환경 레코드 내부에 harryAge가 26값을 가지고 있으므로 26을 출력한다. 위와 같은 이유들로 인해서 harryAge 선언문이 최상단에 끌어올려진 것 처럼 보이는 호이스팅이 발생하는 것이다.\n\n그렇다면 let, const 키워드로 선언한 변수에도 동일하게 undefined가 출력될까?\n\n### 일시적 사각지대\n\n일시적 사각지대란, let과 const 키워드로 변수를 선언했을 때 선언 이전에 변수(식별자)를 참조할 수 없는 영역을 말한다. 참조할 수 없는 이유는 **let과 const 키워드로 선언한 변수는 선언 단계와 초기화 단계가 분리되어 진행**되기 때문이다.\n\n우선, var 키워드는 선언 단계와 초기화 단계가 동시에 진행된다.\n\n![](./assets/var.png)\n\n소스 코드가 실행되기 전, 평가 과정을 거칠 때\n\n- 선언 : 자바스크립트 엔진에게 식별자(harryAge)의 존재를 알리고 메모리 공간을 확보한 후 연결\n- 초기화 : 확보한 메모리 공간에 암묵적으로 undefined 값을 할당\n\n위 두 과정이 동시에 진행된다. 따라서, harryAge 변수(식별자)를 선언 및 할당하기 전에도 undefined 값을 참조할 수 있게되어 콘솔에 출력된다.\n\n반면, let과 const 키워드는 선언과 초기화 단계가 분리되어 진행된다.\n\n![](./assets/let-const.png)\n\n소스 코드가 실행되기 전, 평가 과정을 거칠 때 초기화 단계가 진행되지 않아 값이 바인딩 되지 않는다.  \n(`<uninitialized>`는 값이 바인딩 되지 않았음을 표현하기 위한 수단이며, `<uninitialized>` 값이 바인딩 된 것이 아니다.)\n\n![](./assets/tdz.png)\n\n위 이미지와 같이, 코드가 실행되는 런타임에 실행 흐름이 harryAge 변수에 변수 값 26을 할당하기 전 까지 일시적 사각지대에 빠지게 된다.\n주의할 점은, let과 const 키워드로 선언한 변수도 변수 호이스팅이 발생하는 것은 변함이 없다는 것이다.  \n호이스팅이 발생해서 변수 선언문이 제일 최상단으로 끌어올려진 것 처럼 동작하지만, 변수 값을 할당하기 전 까지 참조할 수 없기 때문에 일지적 사각지대에 빠지게 되는 것이다.\n\n### 함수 호이스팅\n\n1. 함수 선언문\n\n```js\nsayHi()\n\nfunction sayHi() {\n  console.log(\"안녕, 해리야.\")\n}\n```\n\n이번엔 위 코드를 한번 살펴보자. 함수 선언문으로 sayHi 함수를 선언했고, 해당 함수를 선언하기 전 호출하고 있다. 위 코드를 실행하면 예외가 발생해야 할 것 같지만, 정상적으로 호출되는 것을 확인할 수 있다. 그 이유는, 함수 선언문을 통해 생성한 함수는 선언과 동시에 함수가 생성되어 선언 전에도 함수를 사용할 수 있기 때문이다.\n\n![](./assets/declare-function-hoisting.png)\n\n위 이미지와 같이, 전역 코드를 실행하기 전 평가 과정에서 함수 선언문을 통해 생성한 sayHi 함수는 전역 객체의 메서드가 되어 객체 환경 레코드에 등록된다.\n\n따라서, 예외가 발생하지 않고 정상적으로 호출된다.\n\n2. 함수 표현식\n\n```js\nsayHi()\n\nvar sayHi = function () {\n  console.log(\"안녕, 해리야.\")\n}\n```\n\n자바스크립트에서는 변수에 함수를 담을 수 있다. (자바스크크립트에서 함수는 일급 객체이기 때문에 가능하다.)  \n위 코드에서는 var 키워드를 사용한 변수에 sayHi 변수를 담았다.\n\n위 코드를 실행하면 예외가 발생하는 것을 확인할 수 있다. 그 이유는, 전역 코드 평가 과정에서 var 키워드를 사용한 변수는 객체 환경 레코드에 undefined 값으로 등록되는데, sayHi 변수에 함수를 할당하기 전 호출하려고 했기 때문이다.\n\n**함수 표현식은 변수 호이스팅과 동일하게 동작**한다.\n\n![](./assets/funciton-hoisting.png)\n\n```text\nTypeError: sayHi is not a function\n```\n\n따라서 위와 같은 예외가 발생한다.\n\n## 💭 스코프 체인 알아보기\n\n위 코드 예시에서 foo 함수가 실행될 때,  \n`nickName`, `harryAge`, `harryHobby` 식별자를 찾아가는 과정을 통해 스코프 체인에 대해서 좀 더 알아보자.\n\n```js\nvar harryAge = 26\n\nconst address = \"busan\"\n\nfunction bar() {\n  var harryAge = 20\n\n  console.log(\"해리의 나이는\", harryAge, \"입니다.\")\n\n  function foo() {\n    var nickName = \"harry\"\n\n    console.log(nickName)\n    console.log(harryAge)\n    console.log(harryHobby)\n  }\n  foo()\n}\n\nbar()\n\nconsole.log(\"해리의 나이는\", harryAge, \"입니다.\")\n```\n\n![](./assets/scope-chaining.png)\n\nfoo 함수가 호출되면, 함수 코드가 실행되기 전 우선 평가 과정을 통해서 함수 실행 컨텍스트가 생성된다.\n\n함수 실행 컨텍스트가 생성될 때, 외부 렉시컬 환경에 대한 참조 가 결정되어야 하며, foo 함수를 평가하는 시점에 실행 중인 컨텍스트의 렉시컬 환경으로 참조결정된다. 즉, 현재 평가 중인 foo 함수를 포함하는 bar 함수 실행 컨텍스트의 렉시컬 환경으로 참조가 결정된다.\n\n이 후, 순차적으로 foo 함수 내부 코드를 실행한다.\n\n```js\nconsole.log(nickName)\nconsole.log(harryAge)\nconsole.log(harryHobby)\n```\n\nconsole.log 가 실행되면 **자바스크립트 엔진은 어떤 식별자를 출력할지 결정해야 한다.** 식별자를 결정하기 위해서 실행 중인 실행 컨텍스트의 렉시컬 환경에서 식별자를 검색하기 시작한다.\n\n1. **nickName**\n\n현재 실행중인 컨텍스트는 foo 함수의 실행 컨텍스트 이므로, 해당 컨텍스트의 렉시컬 환경에서 nickName 을 찾기 시작한다. 현재 실행중인 컨텍스트에서 찾을 수 있으므로 식별자에 값(”harry”)을 바인딩하고 출력한다.\n\n2. **harryAge**\n\nharryAge 는 foo 함수의 실행 컨텍스트에 없으므로 상위 렉시컬 환경인 bar 함수 실행 컨텍스트의 렉시컬 환경으로 이동해서 식별자를 검색한다. bar 함수의 실행 컨텍스트에서 찾을 수 있으므로 식별자에 값(20)을 바인딩하고 출력한다. 전역 실행 컨텍스트의 렉시컬 환경에도 동일한 harryAge 식별자가 있지만, 자바스크립트 엔진은 가장 먼저 발견된 식별자에만 접근한다.\n\n이 상황처럼, 동일한 식별자로 인해 상위 스코프(전역)에서 선언된 식별자의 값이 가려지는 현상을 변수 섀도잉이라 한다.\n\n3. **harryHobby**\n\nharryHobby 는 foo 함수의 실행 컨텍스트에 없으므로 상위 렉시컬 환경인 bar 함수 실행 컨텍스트의 렉시컬 환경으로 이동해서 식별자를 검색한다. bar 함수의 실행 컨텍스트에서도 찾을 수 없으므로 bar 함수의 상위 렉시컬 환경인 전역 실행 컨텍스트의 렉시컬 환경으로 이동해서 식별자를 검색한다.\n\n전역 렉시컬 환경에서도 찾을 수 없고, 더 이상 이동해서 검색할 수 있는 렉시컬 환경이 존재하지 않으므로 Reference Error 가 발생하게 된다.\n\n위 3가지 예시처럼 자바스크립트 엔진이 식별자를 찾아가는 과정을 스코프 체이닝이라고 하며, 이 과정에서 활용되는 스코프(렉시컬 환경)들의 연결리스트를 스코프 체인이라고 한다.\n\n## 📚 정리\n\n- 실행 컨텍스트란, 자바스립트 엔진이 코드를 실행하기 위해서 필요로 하는 정보(환경)들이 담겨있는 객체이다.\n- 렉시컬 환경이란, 실행 컨텍스트를 구성하는 하나의 단위이며, 다시 환경 레코드, 외부 렉시컬 환경에 대한 참조로 구분된다.\n- 렉시컬 환경은 키, 값을 갖는 객체 형태의 스코프(환경 레코드)를 생성하고, 상위 스코프에 대한 참조(외부 렉시컬 환경에 대한 참조)를 기록한다.\n- 호이스팅은 선언문이 최상단에 끌어올려진 듯한 현상을 말하며, 소스 코드를 실행하기 전 평가를 통해 실행 컨텍스트를 생성하기 때문에 생기는 현상으로 볼 수 있다.\n- var 키워드로 선언한 변수는 변수의 선언과 초기화가 동시에 진행되며, let과 const 키워드로 선언한 변수는 변수의 선언과 초기화가 분리되어 진행된다.\n- 자바스크립트 엔진이 식별자를 결정해가는 과정을 스코프 체이닝이라고 하며, 이 과정에서 활용되는 스코프(렉시컬 환경)들의 연결리스트를 스코프 체인이라고 한다.\n"},{"excerpt":"💭 변수 프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고, 저장된 값을 읽어 들여 재사용하기 위해서 변수라는 매커니즘을 제공한다. 변수는, 하나의 값을 저장하고 재사용하기 위해서 확보한 메모리 공간에 붙인 상징적인 이름을 말한다. 변수가 필요한 이유 변수를 왜 사용해야 할까? 변수를 사용해야 하는 이유에 대해서 공감해보기 위해 변수 없이 프로그래밍…","fields":{"slug":"javascript-data-types"},"frontmatter":{"date":"April 07, 2024","title":"[Javascript] Javascript Data Types","tags":["Javascript","우아한테크코스"]},"rawMarkdownBody":"\n## 💭 변수\n\n프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고, 저장된 값을 읽어 들여 재사용하기 위해서 변수라는 매커니즘을 제공한다.  \n변수는, 하나의 값을 저장하고 재사용하기 위해서 확보한 메모리 공간에 붙인 상징적인 이름을 말한다.\n\n### 변수가 필요한 이유\n\n변수를 왜 사용해야 할까? 변수를 사용해야 하는 이유에 대해서 공감해보기 위해 변수 없이 프로그래밍하는 상황을 생각해보자.\n\n```text\n10 + 20\n```\n\n![](./assets/1.png)\n\n10 + 20 연산이 성공적으로 잘 수행되었고, 연산 결과도 메모리에 잘 저장되었지만 한 가지 문제가 있다. 30 이라는 값이 어디에 저장되어 있는지를 모르기 때문에 30을 재사용할 수 없다는 것이다.\n\n`0x12f` 메모리 주소에 직접 접근하면, 30을 재사용할 수 있겠지만\n\n- 운영체제가 사용중인 영역에 접근해서 값을 변경할 경우, 전체 시스템에 치명적인 오류를 발생시킬 확률이 매우 높아진다.\n- 메모리 주소는 코드가 실행될 때마다 메모리 상황에 따라 임의로 결정된다. 코드가 실행되기 이전에는 값이 저장된 메모리 주소를 알 수 없으며, 알려주지도 않는다.\n\n위와 같은 이유들로 인해서, 자바스크립트는 개발자가 직접 메모리 주소에 접근할 수 있는 것을 허용하기 보다는 “변수”라는 매커니즘을 제공한다. 상징적인 이름인 변수는 자바스크립트의 인터프리터에 의해 값이 저장된 메모리 주소로 치환되어 실행된다.\n\n### 변수 사용하기\n\n```js\nconst result = 10 + 20\n```\n\n![](./assets/2.png)\n\n위 자바스크립트 코드에서, result 는 30을 저장하기 위해서 확보한 메모리 공간을 식별하는 역할을 한다.  \nresult 처럼 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름을 변수 이름(식별자)라고 하며, 변수에 저장된 값을 변수 값이라고 한다.\n\n### 식별자\n\n변수 이름은 식별자라고도 한다. 식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다. 값(위 예시에서는 30)은 메모리 공간 상에 저장되어 있고, 식별자는 메모리 공간에 저장되어 있는 여러 값들 중 한 값을 구별해서 식별해낼 수 있어야 한다. 이를 위해서 식별자는 어떤 값이 저장되어 있는 메모리 주소를 기억한다.\n\n위 예시에서 result 는 값 30이 저장되어 있는 메모리 주소인 0x12f를 기억한다. 식별자는 값(30) 자체가 아니라, 값이 메모리 공간 상에 저장되어 있는 주소와 매핑 관계를 가지며, 이 매핑 관계 정보 또한 메모리 공간 어딘가에 저장된다.\n\n![](./assets/3.png)\n\n### 값의 할당\n\n```js\nvar something // 변수 선언\nsomething = 30 // 값의 할당\n```\n\n```js\nvar something = 30 // 변수 선언 및 값의 할당\n```\n\n값을 저장하고 재사용하기 위해서 변수(식별자)를 사용할 때, 변수의 존재를 코드를 실행할 자바스크립트 엔진에 알려야 한다.  \n이 때, 변수 선언을 통해서 알리게 되며 코드가 실행되는 런타임 이전에 먼저 실행된다.\n\n반면, 값을 저장하는 할당은 코드가 순차적으로 실행되는 런타임에 실행된다. 변수 선언과 값의 할당을 구분해서 하든, 하나의 문으로 단축 표현해서 하든 선언은 런타임 이전, 값 할당은 런타임 이후에 실행된다.\n\n![](./assets/4.png)\n\n위 그림에서도 확인할 수 있듯, 변수를 통해 메모리 공간에 값을 저장하고 식별자가 해당 메모리 공간의 주소를 기억하게 되는 과정을 변수 선언 → 값의 할당 두 가지 과정으로 나누어서 생각해볼 수 있다.\n\n### 값의 재할당\n\n```js\nvar something = 30 // 변수 선언 및 값의 할당\n\nsomething = 80\n```\n\nvar 키워드로 선언한 변수는 재할당할 수 있다. 재할당은 현재 변수에 저장된 값을 버리고, 새로운 값을 저장하는 것을 말한다.  \n값을 재할당할 수 없다면, 변수가 아니라 상수라고 한다. 상수는 재할당이 불가능한 변수이다.\n\n![](./assets/5.png)\n\n`something` 변수에 값 80을 재할당 하면, 메모리 공간에서는 위 그림과 같이 식별자가 가르키는 메모리 공간의 주소가 변경된다. 기존에 30이 저장되어 있던 메모리 공간을 비우고, 그 공간에 다시 80을 할당하는 것이 아니라, 변경된 값 80을 저장하기 위해서 새로운 메모리 공간을 확보하고 식별자가 그 공간의 주소를 가르키도록 한다. 이를 통해서 불변성이 유지될 수 있도록 한다. 자바스크립트의 데이터 타입과 함께 불변성에 대해서 알아보자.\n\n## 💭 자바스크립트 데이터 타입\n\n![](./assets/6.png)\n\n자바스크립트에서 모든 값은 데이터 타입을 가지며, 데이터 타입을 크게 원시 타입과 객체 타입으로 구분할 수 있다.\n\n### 원시 값\n\n자바스크립트의 데이터 타입 중 원시 타입의 값은 위 이미지에서도 확인할 수 있듯, Number, String, Boolean, undefined, null, Symbol이 있다.\n\n원시 타입의 값, 즉 원시값의 가장 중요한 특징은 변경 불가능한 값이라는 것이다. 한번 생성된 원시값은 읽기 전용 값으로써 변경할 수 없다.\n\n```js\nvar something = 10\nsomething = 20\n\nconsole.log(something) // 20\n```\n\nsomething 변수에 숫자 10을 할당했다. 이 후, 숫자 20을 할당하고 콘솔에 출력해보면 20이 출력되는 것을 확인할 수 있다. 숫자는 원시 타입의 값이며, 변경 불가능한 값이라고 했는데 변경이 된 것처럼 보인다. 무엇이 변경 불가능하다는 것일까?\n\n`변경이 불가능한 값`이라는 개념을 이해하기 위해서, 우선 변수와 값을 구분해서 생각해야 한다. 변수는 값을 저장하기 위해서 확보한 메모리 공간을 말하거나 메모리 공간을 식별하기 위해서 붙인 상징적인 이름이다. 반면, 값은 변수에 저장된 데이터를 말한다.\n\n![](./assets/7.png)\n\n“원시 값은 변경이 불가능하다”라는 말은, 변수 값을 변경할 수 없다는 것이 아니라 어떤 메모리 공간에 저장되어 있는 원시 값 자체를 변경할 수 없다는 것을 말한다. 변수는 위 예시처럼 재할당을 통해서 언제든 변수 값을 변경할 수 있다. 원시 값은 어떤 일이 있어도 변경이 불가능하기 때문에, 데이터의 신뢰성을 보장한다.\n\n![](./assets/8.png)\n\n만약, 원시 값이 변경 가능 하다면 위 이미지와 같이 메모리 공간에 저장되어 있는 값이 변경될 것이다.\n\n정리하자면, 원시 값은 변경이 불가능하기 때문에 값을 직접 변경할 수 없다. 변수 값 변경을 위해서 값을 재할당하면 새로운 원시 값을 저장하기 위한 메모리 공간을 추가로 확보하고 변수가 참조하던 메모리 공간의 주소를 변경한다. 이러한 특징을 불변성이라고 한다.\n\n원시 값을 할당 받은 변수가 변수 값을 변경할 수 있는 유일한 방법은 재할당이다. 변수 값을 변경할 수 있는 방법을 단 한 가지로 둔 이유는, 변수 값의 변경을 추적하기 쉽도록하기 위해서이다.\n\n### 값에 의한 전달\n\n```js\nvar age = 26\n\nvar copiedAge = age\n\ncopiedAge = 20\n\nconsole.log(copiedAge) // 20\nconsole.log(age) // 26\n```\n\n`age` 변수에 원시 값인 26을 할당하고, `copiedAge` 에는 age 변수를 할당했다. 이 후, copiedAge를 20으로 변경하고 각 변수를 콘솔에 출력해서 확인해보면 age 변수는 copiedAge 변수 값 재할당에 영향을 받지 않고 기존 값인 26이 그대로 출력되는 것을 확인할 수 있다.\n\n```js\nvar copiedAge = age\n```\n\n해당 줄에서 어떤 일이 발생하는지를 파악해보면, 왜 copiedAge 변수 값 재할당에 영향을 받지 않는지에 대해서 이해할 수 있다.  \n우선 age 변수에 원시 값 26이 할당되었으므로, copiedAge 에도 동일하게 26이 할당될 것이다. 이 때, 새로운 값 26이 생성되어서 copiedAge 변수에 할당된다. 변수에 원시 값을 갖는 변수를 할당하면 원시 값이 복사되어 전달되는데, 이를 값에 의한 전달이라고 한다. 새로운 값 26이 생성되면, 이 값을 저장하기 위한 새로운 메모리 공간이 추가적으로 필요하게 되고 해당 공간의 주소는 기존 age 변수 값 26이 저장되어 있는 메모리 공간의 주소와는 별개의 독립된 주소이다.\n\n엄격하게 말하면, 변수에는 값이 전달되는 것이 아니라 메모리 주소가 전달되며 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억한다. copiedAge 변수(식별자)는 새로운 값 26이 생성되어 저장된 메모리 공간 상의 주소를 기억하게 된다.\n\n![](./assets/9.png)\n\n따라서, copiedAge 변수 값을 20으로 재할당한다 하더라도 age 변수는 영향을 받지 않게되어 변수 값이 변경되지 않는다.\n\n### 객체\n\n자바스크립트에서 객체는\n\n- 프로퍼티의 개수가 정해져 있지 않아, 계속해서 프로퍼티를 생성할 수 있다.\n- 프로퍼티는 동적으로 추가, 삭제가 가능하다.\n- 프로퍼티가 가지는 값에 제약이 존재하지 않는다. 원시값이 될 수도, 객체 타입의 값이 될 수도 있다.\n\n위와 같은 특징을 가지며, 원시 값과는 달리 확보해야할 메모리 크기를 사전에 정의할 수 없다.\n\n위와 같은 특징으로 인해서, 객체를 관리하는 방식은 원시 값을 관리하는 방식에 비해서 상당히 복잡하고 비용이 많이든다. 객체도 원시 값 처럼 변경(재할당)이 있을 때마다 복사하고 새롭게 생성한다면 신뢰성을 보장할 수는 있지만 객체의 크기가 매우 클 수 있으며, 프로퍼티 값이 또 다른 객체일 수 있어 복사의 비용이 상당히 많이 든다. 즉, 한정된 메모리 공간을 효율적으로 소비하기 힘들고 성능이 나빠질 수 있다.\n\n따라서, 메모리를 보다 효율적으로 사용하기 위해서 변경이 있을 때마다 복사한 객체를 저장할 새로운 메모리 공간을 확보하는 것이 아닌 객체를 변경 가능한 값으로 설계했다.\n\n`한정된 메모리를 효율적으로 사용하기 >>> 데이터의 신뢰성 유지하기` 로 볼 수 있다.\n\n변수에 객체를 할당하면\n\n```js\nvar age = 26\n```\n\n원시 값을 할당한 변수(식별자)는 메모리 공간 상에서 원시 값(26)이 저장된 주소를 기억하고 있으며, 이 주소를 통해서 원시 값에 접근할 수 있다. 즉, 원시 값을 할당한 변수는 원시 값 자체를 값으로 갖는다.\n\n```js\nvar harry = {\n  age: 26,\n}\n```\n\n반면, 객체를 할당한 변수가 기억하는 메모리 공간 상의 주소를 통해 메모리 공간에 접근하면 저장된 객체가 아닌 객체를 가르키고 있는 참조 값에 접근할 수 있다. 여기서, 참조 값은 객체가 메모리 공간 상에 저장된 주소 그 자체다.\n\n![](./assets/10.png)\n\n위 이미지처럼, 객체를 할당한 변수를 참조하면 메모리에 저장되어 있는 참조 값(주소)를 통해 실제 객체에 접근한다. 원시 값을 할당한 변수의 경우 “age 변수는 26이라는 숫자형 값을 갖는다.” 또는 “age 변수의 값은 26이다.”라고 표현한다.\n\n하지만, 객체를 할당한 변수의 경우 “harry 변수는 객체를 참조하고 있다.” “harry 변수는 객체를 가르키고 있다.”라고 표현한다. 변수가 기억하는 메모리 공간 상의 주소에 무엇이 저장되어 있는지에 따라 원시 값인지 객체인지 구분할 수 있다.\n\n원시 값은 변경 불가능한 값이므로 재할당 이외에 변수 값을 변경할 수는 없다. 하지만, 객체는 변경 가능하며 재할당 하지 않고도 객체를 직접 변경할 수 있다. 재할당 없이 프로퍼티를 추가/삭제가 가능하며, 프로퍼티 값을 갱신할 수 있다. 객체가 변경 가능하다는 것은, 메모리에 저장된 객체를 직접 변경할 수 있다는 것을 말한다.\n\n```js\nvar harry = {\n  age: 26,\n}\n\nharry.address = \"busan\"\n```\n\n![](./assets/11.png)\n\nharry 객체에 address 프로퍼티를 추가하면, 메모리에 저장되어 있던 harry 객체를 직접 수정할 수 있다. 그리고 harry 객체를 변경할 때, 재할당하지 않았으므로 harry 변수에 저장되어 있던 참조 값도 변하지 않는다.\n\n정리하자면,\n\n- 객체를 할당한 변수는 객체가 저장된 메모리 공간의 주소를 참조한다(가르킨다).\n- 객체는 재할당을 하지 않고도, 값을 변경할 수 있다. 즉, 메모리에 저장된 객체를 직접 수정할 수 있다.\n\n하지만, 위와 같은 특징들로 인해서 부작용이 생길 수도 있는데 바로 원시 값과는 다르게 여러 식별자가 하나의 객체를 공유할 수 있다는 점이다.\n\n### 참조에 의한 전달\n\n```js\nvar harry = {\n  age: 26,\n}\n\nvar copiedHarry = harry\n```\n\n객체를 참조하고(가르키고) 있는 변수(harry)를 다른 변수(copiedHarry)에 할당하면, 원본 객체의 참조 값이 복사되어 전달되는데 이를 참조에 의한 전달이라고 한다.\n\n![](./assets/12.png)\n\n위 이미지와 같이, 원본 객체를 가르키고 있던 참조 값(0x30f)가 복사되어 전달된다. 따라서, 원본 harry와 사본 copiedHarry 모두 동일한 객체를 가르키게 된다. 이것이 여러 식별자가 하나의 객체를 공유한다는 것을 의미한다.\n\n```js\nvar harry = {\n  age: 26,\n}\n\nvar copiedHarry = harry\n\ncopiedHarry.age = 20\n\nconsole.log(harry.age) // 20\n```\n\n따라서 원본에서든 사본에서든, 객체의 프로퍼티를 추가/삭제 하거나 프로퍼티 값을 변경하면 서로 영향을 주고 받는다.\n\n자바스크립트에서 “값에 의한 전달”이든 “참조에 의한 전달”이든 기존 메모리 공간에 저장되어 있던 값을 복사해서 전달한다는 것은 같다. 다만, 기존 메모리 공간에 원시 값이 저장되어 있었느냐 참조 값이 저장되어 있었느냐의 차이만 있을 뿐이다.\n\n## 😎 퀴즈\n\n```js\nconst myAge = 26\n\nconst harryAge = 26\n\nconsole.log(myAge === harryAge) // ?\n\nconst myHarry = {\n  age: 26,\n}\n\nconst yourHarry = {\n  age: 26,\n}\n```\n\nconsole.log(myHarry === yourHarry); // ?\n위 콘솔의 출력 결과를 예측해보자.\n\n```js\nconsole.log(myAge === harryAge)\n```\n\n![](./assets/13.png)\n\n자바스크립트의 `===` 연산자는 변수에 저장되어 있는 값을 타입 변환하지 않고 비교한다. 원시 값을 할당한 변수는 원시 값 자체를 가지고 있고 === 연산자를 통해서 비교하면, 원시 값을 비교한다. 두 변수에 저장된 26은 Number 타입이며, 값도 같기 때문에 true가 출력된다.\n\n```js\nconsole.log(myHarry === yourHarry)\n```\n\n![](./assets/14.png)\n\n객체를 할당한 변수는 참조 값을 가지고 있고 === 연산자를 통해서 비교하면, 참조 값을 비교한다. 객체 리터럴({})는 평가될 때마다 새로운 객체를 생성하기 때문에 myHarry 변수와 yourHarry 변수가 가르키는 객체는 모두 구성은 같지만 다른 메모리 공간에 저장되는 별개의 객체이다. 따라서, 두 변수의 참조 값도 다르게 되며 비교 했을 때 false 가 출력된다\n\n## 📚 정리\n\n- 변수는 값을 저장하고, 재사용하기 위해서 메모리 공간 상에 붙인 상징적인 이름이다.\n- 변수 이름(식별자)은 값이 저장된 메모리 공간 상의 주소를 기억한다.\n- 변수 값은 재할당을 통해서 언제든 변경할 수 있다.\n- 원시 값은 변경 불가능하며, 이는 메모리 공간에 저장되어 있는 원시 값 자체가 변경이 불가능하다는 의미이다.\n- 객체는 변경 가능하며, 이는 메모리 공간에 저장되어 있는 객체를 직접 변경할 수 있다는 의미이다.\n- 변수 이름(식별자)이 가르키는 메모리 공간에 원시 값이 저장되어 있었느냐, 참조 값이 저장되어 있었느냐에 따라서 “값에 의한 전달”과 “참조에 의한 전달”을 구분할 수 있다.\n"},{"excerpt":"꾸준함과 번아웃의 굴레 속에서 살아가던 나 \"어...나 지금 지친 건가? 아직 할게 산더미인데?\" 이 생각을 처음으로 했던 것은 20살, 수능을 다시 준비하던 어느날이였다. 평소와 다름없이 매일 다니던 독서실에서 뇌가 정말 멈춘 듯 멍하니 30분 동안 책을 바라만 봤었다. 전역을 하고, 코딩을 잘하고 싶다는 생각으로 들어간 연구실에서도 이 현상은 반복되었…","fields":{"slug":"woowacourse-level-1-writing"},"frontmatter":{"date":"March 28, 2024","title":"우아한테크코스 레벨1 글쓰기 미션","tags":["회고","우아한테크코스"]},"rawMarkdownBody":"\n## 꾸준함과 번아웃의 굴레 속에서 살아가던 나\n\n```js\nwhile(1){\n    목표 세우기\n    그냥 꾸준히 하기\n    번아웃 느끼기\n    자책하기\n}\n```\n\n\"어...나 지금 지친 건가? 아직 할게 산더미인데?\" 이 생각을 처음으로 했던 것은 20살, 수능을 다시 준비하던 어느날이였다. 평소와 다름없이 매일 다니던 독서실에서 뇌가 정말 멈춘 듯 멍하니 30분 동안 책을 바라만 봤었다. 전역을 하고, 코딩을 잘하고 싶다는 생각으로 들어간 연구실에서도 이 현상은 반복되었다. \"언제까지 연구실에 매일 와서 이러고 있어야 하는거지?\"에 대해 생각하며 모니터만 멍하니 바라보는 날이 많아졌다.\n\n지금 생각해 보면, **확실히 번아웃이었다.**\n\n지금까지 스스로를 꾸준하고 부지런한 사람으로 생각하며 살아왔다. 운동을 정말 좋아해서 군대에서도, 전역을 하고도 일주일에 5번은 무조건 운동을 했다. 최근 달리기도 시작해 10KM 마라톤 대회를 준비하며 매주 한 번은 무조건 한강에서 러닝도 한다. 수능을 다시 준비하던 시절, 연구실을 다니던 시절 모두 특별한 일이 없으면 매일 출석해서 공부했다. 주변 친구, 지인들이 가끔 \"진짜 꾸준하다, 부지런하다\"라는 말을 해주기도 했다.\n\n무언가를 꾸준히 하는 습관을 가지는 것은 정말 어렵고, 이 습관을 원하지 않는 사람은 거의 없을 것이다. 하지만 나는, 꾸준한 사람이기보다 **꾸준해야만 한다는 강박 속에서 살아가는 사람**이였다. 무언가를 꾸준하게 하는 게 **당연한 것으로 자리 잡았기 때문에** 재미, 성취, 목적의식 모두 흐릿해지게 되었다. 이 현상을 양치에 비유하고 싶다. 양치를 하면서 재미, 성취, 목적의식을 느끼는 사람은 거의 없을 것이지만 양치를 하지 않으면 이가 썩기 때문에 해야만 한다. 성장을 위해 목표를 세우고 꾸준하게 해가는 것이 결국, 양치를 하는 것과 같아졌다. 특히 수능 준비와 연구실에서의 상황처럼 학습과 관련된 꾸준함이라면 유독 번아웃이 심하게 찾아왔다.\n\n## 왜?\n\n이유가 궁금했다. 왜 꾸준함에 대해서 강박을 느끼며 살아가고 있는지, 왜 목표를 이뤄가는 과정에서 아무런 재미와 성취도 느끼지 못하는지. 나름대로 분석을 해봤을 때, 이유는 크게 2가지였다.\n\n### 너무 큰 목표\n\n위에서 \"코딩을 잘하고 싶다\"는 생각으로 연구실에 들어갔다고 했는데, 해당 목표는 **너무 크고 추상적이다.** 목표를 달성하기 위해 노력할 꾸준함은 가지고 있지만, 목표를 세분화하는 방법은 몰랐다. 그리고 목표가 크면 클수록 장기전이 되는데, 목표의 크기와 상관없이 항상 단기전 경기를 치르는 선수처럼 살아왔다. 추상적이면서 큰 목표를 가질 때 가장 큰 단점은, **주어진 시간 동안 뭘(What) 해야 할지 정리하기 매우 힘들다**는 것이다. 독서실, 연구실에도 \"일단 간다..!\"는 생각으로 매일 출근했다.\n\n### 너무 큰 기대치\n\n스스로에게 거는 기대치가 항상 매우 컸다. 친구, 지인들이 인정하고 칭찬해 줄 만한 상황이 생겨도 \"이게 그렇게 까지 잘한 일인가?\"를 계속 의심했다. 항상 \"나는 아직 멀었어...\"라는 생각을 하며 살아왔기 때문이다.\n\n## 그래서 유연성 강화 목표가...?\n\n서론이 길었는데, 유연성 강화 목표는 **실천 가능한 작은 목표를 세우고, 꾸준하지 못할 수도 있음을 받아들이기**로 정했다. 꾸준함에 대한 강박은 이제 좀 내려놓고, 더 유연하게 목표를 향해 나아가고 싶었기 때문이다.\n\n## 해리, 유연하게 잘 하고 있나요?\n\n누군가 나에게 위와 같은 질문을 한다면, \"네 그럼요~\"라고 말할 수 있을 정도로 의식적으로 내 목표를 떠올리며 우테코 생활을 하고 있다.\n\n### 우테코와 운동 병행하기\n\n운동을 정말 좋아해서 우테코 생활을 하면서도 집에 도착하면 일주일에 4일은 1시간 정도 맨몸운동을 했다. 하지만, 우테코 생활이 정신없어지고 할게 많아지면서 자연스럽게 늦게 집에 도착하는 날이 많아지기 시작했다. 정해진 루틴대로 운동을 다 한다면 내일 컨디션에 영향을 줄 만큼 수면 시간이 늦어져 계획을 변경해 보기로 했다. 평소였으면 '그래도 정해진 건 꾸준히 무조건 한다.'라고 생각하며 정해진대로 했을 것이다. 현재는 우테코에 집중하고 싶은 마음이 더 크기 때문에, 집에 도착하면 **딱 턱걸이 100개만**하는 것으로 계획을 수정했다. 정해진 루틴대로 하지 못하는 것을 자책하거나 아쉬워하지 않고, 턱걸이를 100개라도 하는 것에 의의를 둔다!\n\n### 왔다감 고정 멤버입니다만...?\n\n어느 순간부터 선릉 캠퍼스 왔다감의 고정 멤버(?)가 되었다. 우테코에 쓰는 시간이 많아진 만큼, 몰입하고 있다고 볼 수 있겠지만 독서실과 연구실에서의 상황처럼 **맹목적으로 남게 될까 봐** 두렵기도 했다. 우테코를 통한 학습에서 만큼은 이전 상황을 반복하고 싶지 않았다. 그래서 저녁을 먹은 후, **11시까지 남는 이유와 작은 목표를 카톡 나에게 보내기나 노션에 작성해보고 있다.** 머릿속으로 '아, 내가 ~를 해야 하니 남아야지'를 생각만 하는 것보다, 글로 옮기는 것까지 해보니 목표를 한번 더 생각할 수 있어 걱정했던 맹목성이 어느 정도 사라졌다.\n\n![](./assets/내%20목표.png)\n\n## 할만 한데요?(같이 하니까)\n\n유연성 강화 스터디를 시작하기 전에 걱정했던 것보다는 목표를 잘 달성해가고 있다.\n\n1. '나 유연한 사람이었네?',\n2. '이 쉬운걸 이때까지 왜 시도해보려고 하지 않았지?'\n\n위 두 가지 문장은 지금까지 스터디를 하면서 내가 많이 했던 생각이다. 생각했던 것보다 꾸준함에 얽매이지 않고 있고, 목표를 작게 잘 나누고 있다. 이게 가능한 이유는 아마도 혼자 하는 것이 아니라 유연성을 강화하고 싶은 크루들과 **같이 하기 때문**인 것 같다. 매주 진행하는 스터디에서 크루들과 피드백을 주고받으면서 선한 자극을 얻으니 흔들리지 않고 의식적으로 목표를 떠올리고 있다. 우테코 수료까지 내가 정한 목표를 잘 달성해갈 수 있을까?\n"},{"excerpt":"3주차 웹 기반 로또 게임\n헤인과의 페어 프로그래밍이 끝난 후, step2로 넘어가면서 콘솔 기반이 아닌 웹 기반으로 로또 게임을 구현해야했다. 프리코스와 자동차 경주, 로또 미션 step1 까지는 모두 콘솔 기반이였는데 처음 웹 기반 미션으로 넘어가면서 오랜만에 DOM을 다뤄야했기에 어떻게 해야할지 막막했다. 막막하니 처음부터 차근차근 LMS에 있는 학…","fields":{"slug":"woowacourse-level-1-week3&4-retrospect"},"frontmatter":{"date":"March 11, 2024","title":"우아한테크코스 레벨1 3~4주차 돌아보기","tags":["회고","우아한테크코스"]},"rawMarkdownBody":"\n## 3주차\n\n웹 기반 로또 게임\n헤인과의 페어 프로그래밍이 끝난 후, step2로 넘어가면서 콘솔 기반이 아닌 웹 기반으로 로또 게임을 구현해야했다. 프리코스와 자동차 경주, 로또 미션 step1 까지는 모두 콘솔 기반이였는데 처음 웹 기반 미션으로 넘어가면서 오랜만에 DOM을 다뤄야했기에 어떻게 해야할지 막막했다.\n\n막막하니 처음부터 차근차근 LMS에 있는 학습 목표와 요구 사항들을 읽으며 내가 해야할 일에 대해서 정리해보기로 했다.\n\n### 로또 미션의 학습 목표\n\n- UI, 도메인을 분리해볼 수 있는 설계를 고민하고, 목적에 맞게 객체와 함수를 활용한다.\n- 단위 테스트를 기반으로 점진적인 리팩터링을 한다.\n\n핵심은 도메인과 UI를 모듈화해서 관심사를 분리해보는 연습인 것 같았다. 이 연습을 해보기 위해서 LMS에서도 나와있는 step1에서 구현한 도메인 로직을 수정하지 않는 것을 목표로 잡고 미션을 진행했고, 미션이 끝난 후 다시 돌아보니 도메인 로직을 하나도 수정하지 않았던 것을 확인할 수 있었다.  \n나름 관심사 분리를 잘한 것 같아 만족했다. 😊 도메인 로직과 UI 로직을 분리하는 것은 프리코스의 공통 피드백에서도 확인할 수 있었던 내용이였고 지금까지 미션을 진행하면서 내가 내린 나름대로의 결론은 아래와 같다.\n\n### 1. 도메인\n\n> \"도메인은 문제를 해결에 대해 고민하며, 해결책을 만든다.\"\n\n이번에 진행한 로또 미션을 예로 들자면, 로또 게임이 해결해야 하는 문제는 \"사용자가 일정 금액만큼 로또를 구매했을 때, 총 당첨금과 수익률은 얼마인가?\"로 정리해볼 수 있다. 도메인은 **이 문제를 해결하는데 집중**한다.\n\n- 로또 구입 금액으로 몇 장의 로또를 생성할 수 있는지 판단한다.\n- 1 ~ 45 사이의 랜덤 숫자 6개를 뽑아 로또 한장을 생성한다.\n- 당첨 번호, 보너스 번호를 바탕으로 로또 한장의 등수를 결정한다.\n- 등수에 맞는 상금을 더한 후, 수익률을 계산한다.\n\n이렇듯, 도메인은 로또 게임이 해결해야하는 문제에만 집중한다. 도메인이 제시하는 **문제 해결책이 어디서 어떤 방식으로 사용될지는 도메인의 관심사가 아니다.** 따라서, UI가 콘솔에서 웹으로 변경되는 것은 도메인의 관심사가 아닌 UI의 관심사이기 때문에 UI만 수정하면 되는 것이다.\n\n### 2. UI\n\n> \"UI는 도메인의 문제 해결책을 사용한다.\"\n\n문제의 해결책만 존재하고, 사용할 수 없다면 프로그램이 완성되지는 못할 것이다. 이 때, UI는 사용자가 도메인이 제시하는 문제 해결책을 사용할 수 있도록 연결해주는 역할을 한다. UI는 문제 해결책을 어떻게 사용할 수 있도록 할 것인지와 문제 해결의 결과를 어떻게 보여줄 것인지에 집중한다.\n\n- 로또 구입 금액을 어떻게 입력 받을 것인지 (Console, HTML input)\n- 발급된 로또들은 어떻게 보여줄 것인지 (Cosole, HTML ul li)\n- 당첨 번호, 보너스 번호는 어떻게 입력 받을 것인지 (Console, HTML input)\n- 총 당첨금, 수익률은 어떻게 보여줄 것인지 (Console, modal)\n\n이렇듯, UI는 도메인이 제시하는 문제 해결책을 어떻게 사용할 것인지에만 집중한다. **어떤 방식으로 문제를 해결하는지에 대한 방법을 고민하는 것은 UI의 관심사가 아니다.** 오직 도메인이 알려주는 문제 해결의 결과만 받아서 사용하면 되는 것이다. 도메인과 UI의 관심사를 분리하는것에 대한 내가 내린 나름대로의 결론은 위와 같다.\n\n😊 추가로, 이번 미션에서 DOM을 다뤄보면서 했던 고민들도 [PR](https://github.com/woowacourse/javascript-lotto/pull/314)을 날릴 때 리뷰어에게 내 고민을 공유했다! 미션을 진행하면서 잊었던 개념들이나 잘 모르고있던 부분을 정리하고 기록했다.\n\n- HTMLCollection vs NodeList\n- HTML id vs class\n\n## 레벨 1 유연성 강화 목표 : \"꾸준하지 못할수도 있음을 받아들이기\"\n\n3주차 소프트 스킬 교육 시간에는 **유연성 강화**에 대한 내용으로 수업이 진행되었다. 수업 하루 전, 데일리 미팅 시간에 크루들과 온보딩 미션을 하면서, 우테코 이전의 나의 모습을 돌아보며, 지원서의 실패 경험을 돌아보았을 때..\n\n- 나에게 가장 부족했거나 아쉬웠던 점은?\n- 어떻게 하면 더 좋은 방향으로 바꿀 수 있었을까?\n\n에 대한 내용을 바탕으로 이야기를 나누었다. 스스로 생각했을 때, 부족했던 모습과 아쉬웠던 모습들을 누군가에게 얘기해본 경험이 거의 없다보니 어떻게 말해야할지도 모르겠고 부끄러운 감정이 들었다.(부족한 모습들은 보여주고 싶지 않아 숨기는것에 익숙해졌기 때문에...) 하지만, 걱정과는 달리 막상 이야기를 해보니 그렇게 부끄럽지는 않았던 것 같다. 레벨마다 유연성 강화 목표를 세우고, 유연성 강화 스터디를 통해 크루들과 함께 각자의 유연성 강화 활동에 대한 피드백을 주고받는 스터디를 진행하는 방식으로 유연성 강화 수업이 진행 되는데, 크루들과 나눈 이야기를 바탕으로 레벨 1 유연성 강화 목표를 **꾸준하지 못할수도 있음을 받아들이기**로 정했다.\n\n나는 운동하는 것, 몸 쓰는 것을 굉장히 좋아한다. 그래서, 군대에 있을 때는 특별한 훈련이 없는 날에는 매일 운동을 했고 전역을 하고나서도 일주일에 5번 이상은 항상 헬스장에 가서 운동을 했고, 서울에 올라온 지금도 시간을 내서 맨몸 운동을 하고 있다. 또, 10KM 마라톤 대회에 나가기 위해서 매 주 한강에 가서 달리기도 하고 있다. 꾸준히 무언가를 하고 있는 것 같음에도 불구하고 내가 꾸준하지 못할수도 있음을 받아들이기를 목표로 설정한 이유는 어느 순간부터, **꾸준함에 대한 강박을 느낀다**는 것을 알게되었기 때문이다. 내가 강박을 느끼고 있는 것 같다고 생각하게 된 근거들은 아래와 같다.\n\n- 운동 또는 학습이 재미가 없다고 느낀날이 많아졌다.\n- 운동 또는 학습에 대한 성취감이 급격하게 떨어지고 있었다.\n- 운동 또는 학습에 대한 목적 의식이 흐릿해지고 있었다.\n\n내가 꾸준하게 하고 있는 행동들이 어느 순간 **당연하게 해야하는 것으로 자리 잡았기 때문에** 당연한 일을 해가는 것에 대한 재미도, 성취도 느끼지 못하기 시작한 것이다. 특히 학습에 관해서는 이런 감정들이 유독 심하게 느껴졌었다. 전역을 하고 복학을 한 후 머릿속으로 \"코딩을 잘하고 싶다\"라는 생각으로 연구실에 들어갔고, 특별한 일이 없는 날에는 대부분 연구실에서 공부를 하며 시간을 보냈다. 덕분에 학부생으로써 굉장히 좋은 성적을 받고, 가족과 친구들의 칭찬도 많이 받았지만 좋은 성적을 받은것에 대한 기쁨도 그렇게 크게 느껴지지 않았고 \"이제 다음엔 뭘 해나가지?\"에 대해 생각하며 다음 계획을 세웠던 것 같다. 어느 날, 연구실에서 공부를 하고 있던 중 \"내가 언제까지 매일 여기 와서 이러고 있어야 하는거지?\", \"내일도 오늘처럼 이러고 있겠지..?\"와 같은 생각을 하게 되었다. 지칠만큼 지쳤으며 번아웃이 온 것이다. 학습에 대한 재미, 성취감, 목적의식 모두 흐릿해지고 있었던 것이다. **꾸준함을 무기로 갖고 있긴 했지만, 그 무기를 어떻게 써야하는지에 대해서는 전혀 알지 못한 상태**로 학습을 해갔던 것이였다. 지금 생각해보면 고등학생 때나, 수능을 다시 준비하던 시절 모두 연구실을 다니며 느꼈던 감정들과 비슷한 감정을 느꼈던 것 같다.\n\n우테코에서의 학습, 앞으로의 학습에서는 비슷한 감정들을 더이상 느끼고 싶지 않았기 때문에 나름대로 내가 번아웃을 겪게되는 이유를 정리해보았다.\n\n### 1. 크고 막연한 목표\n\n학습에 있어서 목표가 너무 컸다. 위에서 \"코딩을 잘하고 싶다\"라는 생각으로 연구실에 들어갔다고 했는데, 이 목표자체가 너무 크고 너무 모호하다. 목표가 클수록 장기전이 되는데, 나는 이 때까지 목표의 크기와 상관없이 항상 단기전 경기를 치르는 선수처럼 살았던 것 같다. 또, 목표가 너무 모호하면 그 목표를 세분화하기가 너무 힘들다. \"코딩을 잘하고 싶다\"라는 너무 모호한 목표를 세우니 일단 연구실에 가긴 가는데 연구실에 있는 시간을 어떻게 활용할지에 대해서 잘 몰랐었다.  \n(~~일단 간다. 가면 뭐라도 하겠지~~)\n\n![](./assets/week-3&4-1.png)\n![](./assets/week-3&4-2.png)\n\n\"리액트를 잘하고 싶어\" 리액트 공부를 하기 위한 계획을 세웠었다. 계획을 세운지는 6개월 정도 된 것 같다. 하지만, 위 사진에서도 확인할 수 있듯이 아직까지 체크표시를 한 계획이 하나도 없다.(~~이 정도면 그냥 게으른거 아닌가?ㅋ~~)  \n리액트 딥다이브도 2장만 공부하고 어렵기도 하고 막대한 양 앞에서 그만 포기를 해버렸던 것 같다. 이렇듯, 지금까지 학습에 있어서 내 목표는 너무 크고 너무 모호했다.\n\n### 2. 너무 큰 기대치\n\n목표를 너무 크게 잡는 것과 결이 비슷한 이야기지만, 지금까지 스스로에 대한 기대치가 너무 높았던 것 같다. 스스로에게 항상 꾸준하고 항상 잘하는 모습을 기대하다보니 이럴수도 있고 저럴수도 있는 유연한 사고를 하지 못한 채 강박 속에서 고통을 받았던 적도 많았다. [이 글](https://eopla.net/magazines/12608#)을 읽으면서 지금이라도 스스로에 대한 기대치를 조금 낮춰보고자 한다.\n\n꾸준함에 대해서 더 유연한 사고를 가지기 위해서 레벨 1의 목표를 \"꾸준하지 못할수도 있음을 받아들이기\"로 잡았다\n\n![](./assets/week-3&4-3.png)\n\n## 오늘은 여기까지만 달리죠\n\n주말에는 항상 러닝을 하기에, 3주차 주말에도 한강에 가서 러닝을 했다. 이 때까지는 항상 저녁에 러닝을 했었는데 3주차 날씨가 유독 추웠기에 해가 떠 있는 낮에 한강에 갔다. 하지만, 낮에도 정말 춥고 바람이 많이 불었고 심지어 뛰는 방향 반대로 바람이 정말 심하게 불어서 속도도 나지 않았다. 그리고, 그 동안의 맨몸 운동과 8KM 과 10KM을 뛰면서 몸에 피로가 많이 쌓였는지 컨디션도 정말 별로였다. 한마디로 모든 환경이 오늘 내가 달리지 말라고 말하는 것 같았다. 3KM가 지나고 나서부터는 그만 달리고 싶다는 생각만 하게 되었다. 원래라면 10KM을 채워야한다는 강박 속에서 어떤 환경이든 끝까지 달렸을 것 같은데 \"오늘이 내 마지막 러닝도 아닐텐데 이렇게 까지 해야할까?\"라는 생각이 들어 같이 달리는 누나한테 3KM 지점에서 다시 돌아가자고 했고 목표를 채우지는 못했다. 오늘 10KM을 채우지 못한것에 대해서 너무 많은 생각은 하지 않기로 했고, 오히려 다음 주에 더 잘 뛰기 위해 쉬는시간을 가진다고 생각했다. 4주차 달리기는 매우 좋은 컨디션으로 만족할만한 러닝을 했다. 😊\n\n## 4주차\n\n### 지니와의 메타인지 말하기 시간\n\n4주차 월요일에는 [메타인지 말하기](https://github.com/woowacourse/woowacourse-docs/blob/main/studylog/meta-speech.md) 시간이 있었다. 내 페어는 지니였고, 2분 30초 시간을 재고 돌아가며 말하고 5분씩 질문을 주고받았다.\n\n- 나(해리): HTMLCollection vs NodeList\n- 지니 : [DOM 요소를 숨길 수 있는 다양한 방법들](https://velog.io/@jinyoung234/%EC%9A%94%EC%86%8C%EB%A5%BC-%EC%88%A8%EA%B8%B0%EA%B8%B0-%EC%9C%84%ED%95%9C-%EB%8B%A4%EC%96%91%ED%95%9C-%EB%B0%A9%EB%B2%95%EB%93%A4-with-Lotto-%EB%AF%B8%EC%85%98)\n\n내가 말하는 차례가 됐을 때, NodeList의 절반까지만 설명하고 시간이 종료되어버렸다... 나의 학습 내용을 모두 설명하기에 2분 30초라는 시간은 생각보다 짧았다. 말할 내용을 미리 정리해보고, 시간을 재면서 간단명료하게 학습 내용을 전달할 수 있도록 연습해봐야겠다. 지니는 DOM 요소를 숨길 수 있는 방법들을 학습하면서 웹 접근성에 대해서도 학습했었고, 지니의 학습 내용 설명을 통해서 알지 못했던 웹 접근성에 대한 내용들도 새롭게 알 수 있었다.\n\n- 시간에 맞게 분량을 조절하자!(2분 30초)\n- 글을 미리 써오는 것도 좋을거 같다!\n- 기술의 출발점을 앞에 말해보는 것도 좋을거 같다!\n\n메타인지 시간이 끝난 후 위와 같은 피드백을 주고받았다!\n\n### 봄이 좋냐?\n\n![](./assets/week-3&4-4.jpeg)\n\n나에게 봄은 정말 오지 않았으면 하는 계절이다...\n심한 꽃가루 알러지와 환절기 때마다 떨어지는 면역력으로 인해서 입술포진이 올라오기 때문이다. 약과 연고를 일주일 간 병행한 덕분에 증상이 심하게 나타나지는 않았지만, 꽃가루 알러지 예방을 위해 먹는 약의 부작용 중 하나가 심한 피로감을 주는 것이라서 집중하기가 쉽지 않다. 그래도 하루종일 눈이 가렵거나 재채기를 하는 것 보다 피로감을 얻는 것이 더 나으니까~!\n\n### 점심 뭐 먹지 페어 프로그래밍\n\n4주차 미션 점심 뭐 먹지의 페어는 해시였다. 점심 뭐 먹지 미션의 학습 목표는\n\n- 전체 애플리케이션을 컴포넌트 단위로 모듈화한다.\n  - UI를 컴포넌트 단위로 생각하고 개발하는 연습을 해본다.\n  - 재사용할 수 있는 컴포넌트를 고민해본다.\n- Typescript의 기본 문법을 익히며 필요성을 경험한다.\n\n였다. 리액트를 사용하면서 프로젝트를 진행했을 때 컴포넌트를 만들어보았지만 컴포넌트가 무엇인지, 컴포넌트 단위로 개발을 하면 어떤점이 좋은지에 대해서 깊게 고민해본 적은 없는 것 같았다. 이번 미션의 목표가 **컴포넌트 단위로 생각해보기**인 만큼 내가 생각하는 컴포넌트는 무엇이고, 컴포넌트 단위로 나누었을 때 어떤 점이 좋은지에 대해 고민해보고 싶었다. 고민 후, 나름대로의 결론을 내렸다.\n\n### 컴포넌트를 나눈다는 것은 책임을 나눈다는 것\n\n전체 UI를 컴포넌트 단위로 생각해보고 나누었을 때,\n\n> \"컴포넌트를 나눈다는 것은 책임을 나누는 것과 같지 않을까?\"\n\n라는 생각을 하게 되었다. 그렇다면 각 컴포넌트가 가지는 작은 책임은 UI를 그리는 책임과 특정 이벤트가 발생했을 때 특정 행동을 하는 책임 2개를 가진다고 생각했다.\n\n```text\n- 상태 : 컴포넌트가 그리는 UI\n- 동작 : 특정 이벤트(click, change)에 대한 액션\n```\n\n상태와 동작으로 구분했을 때, 위와 같이 정리해볼 수 있었고 컴포넌트는 전체 애플리케이션을 구성하는 작은 객체가 될 수 있다고 생각했다. 또, 컴포넌트내에서 도메인 로직을 사용해서 새로운 UI를 그리기 위한 데이터를 받아오기도 하니 컴포넌트는 **하나의 작은 컨트롤러**의 역할을 한다고 결론을 내리게 되었다.\n정리하자면 나름대로의 내 결론에서\n\n- **컴포넌트는 하나의 작은 컨트롤러**이다.\n- 전체 애플리케이션을 **컴포넌트 단위로 생각하고 나눈다는 것은 책임을 나눈다는 것이다.**\n\n## 소파의 이벤트 설명\n\n주말에 잠실 캠퍼스에서 공부를 하고 있던 중, 소파가\n\n> \"나 이벤트 완벽 이해함\"\n\n라며 나를 찾아왔다. 마침 나도 모던 자바스크립트 딥다이브의 이벤트 부분을 읽고 있던터라 소파와 소규모 메타인지(?) 시간을 가졌다. 소파와 이야기를 하면서 이 때까지 캡쳐링, 버블링에 대해서 완전히 잘못 알고 있었음을 알게 되었다. `addEventListener`를 통해서 특정 이벤트에 대한 핸들러(액션)를 등록할 때, 캡쳐링은 기본적으로 false인 것은 알고 있었지만 이 **false의 의미가 캡쳐링이 완전히 발생하지 않는다**라고 알고 있었다.\n\n하지만, 이벤트 자체는 항상 캡쳐링부터 시작해서 이벤트가 발생한 타겟까지 흐르고 다시 버블링이 되어 흘렀고, 언제 핸들러(액션)가 등록이 되는지를 중심으로 캡쳐링과 버블링을 이해해야했다. 소파의 설명을 모두 이해한 후, \"그럼, 이벤트는 항상 흐르고 핸들러(액션)은 그 흐름위에 타는거네?\"라고 정리했었는데 소파가 그게 맞다며 이벤트를 이해하기 위해 했던 이틀간의 노력이 방금 내가 말한 한 문장으로 정리된다고 말했다..ㅋㅋㅋ\n\n소파랑 이벤트에 대한 이야기를 하면서 내가 그동안 이해했다고 생각했던 것이 정확하지 않았던 것을 알게 되었고, 잘못알고 있던 내용을 바로잡으면서 이 시간이 정말 재밌다고 느껴졌다. 이게 포비가 말했던 \"프로그래밍을 학습의 도구로 삼고, 학습에 대해 즐거움을 느끼는 경험을 하는것\"이 아닐까? 라는 생각을 하며 4주차를 마무리했다! 소파의 이벤트에 관한 학습 기록은 [여기](https://velog.io/@ss0526100/JS-%EC%9D%B4%EB%B2%A4%ED%8A%B8%EC%99%80-%EC%95%A1%EC%85%98)에서 확인할 수 있다~!👍\n"},{"excerpt":"한 주의 시작, 유연성 강화 스터디 매주 월요일 데일리 미팅은 레벨1에서 정한 유연성 강화 목표에 대해서 연극조와 이야기를 나누는 방식으로 진행된다. 3~4 주차 회고에서 확인할 수 있듯, 나의 레벨1 유연성 강화 목표는 꾸준함에 대한 강박을 좀 내려놓고, 꾸준하지 못할수도 있음을 받아들이는 것이였다. 나의 유연성 강화 목표에 대해서 생각해볼 수 있는 상…","fields":{"slug":"woowacourse-level-1-week5-retrospect"},"frontmatter":{"date":"March 11, 2024","title":"우아한테크코스 레벨1 5주차 돌아보기","tags":["회고","우아한테크코스"]},"rawMarkdownBody":"\n## 한 주의 시작, 유연성 강화 스터디\n\n매주 월요일 데일리 미팅은 레벨1에서 정한 유연성 강화 목표에 대해서 연극조와 이야기를 나누는 방식으로 진행된다. 3~4 주차 회고에서 확인할 수 있듯, 나의 레벨1 유연성 강화 목표는 **꾸준함에 대한 강박을 좀 내려놓고, 꾸준하지 못할수도 있음을 받아들이는 것**이였다. 나의 유연성 강화 목표에 대해서 생각해볼 수 있는 상황을 생각해보고, 그 상황에 대해서 스스로 돌아보고 크루들의 피드백을 받는다. 이번에 내가 생각해본 상황은 **운동 계획 변경을 결심한 순간**이였다. 지난 회고에서도 언급했듯이, 나는 운동을 정말 좋아해서 주 4일은 미리 짜놓은 루틴대로 홈트를 하고 주말 중 하루는 한강에 가서 러닝을 한다.\n\n하지만, 홈트와 러닝을 둘 다 하는 날은 없어서 평일 5일 중 4일은 맨몸 운동을 해야 했는데 점점 미션과 개인 공부를 하느라 집에 도착하는 시간이 늦어졌고, 운동까지 하고 잔다면 수면 시간이 굉장히 늦어져 다음날 컨디션에도 영향을 주게 되었다. 다음날 좋은 컨디션도 유지하고 싶었고, 운동도 계속 하고 싶어서 조율이 필요하다고 생각했다. 지금은 우테코에 집중하고 싶은 마음이 조금 더 강해 운동 루틴을 수정하기로 했는데 집에 도착해서 더도 말고 덜도 말고 딱 턱걸이 100개만 제대로 하고 자는 것으로 수정했다. \"운동에 조금 더 많은 시간을 쓸 수 있는 상황이 언젠가는 생기지 않을까~?\"라고 생각하며 현재 상황에 맞게 유동적으로 계획을 조절하게 되었다.\n\n매일 \"어떻게 하면 유연성 강화 목표를 더 잘 달성할 수 있을까\"를 생각하지는 않지만, 내가 설정한 계획을 수정해야 하는 상황이 생기면 의식적으로 \"조금 더 유연하게 생각해볼까?\"를 머릿속으로 떠올리는 것 같다. 혼자 하는 것이 아니라 연극조 크루들에게 피드백을 받으며 내가 잘 하고 있는지를 확인할 수 있고 크루들에게 피드백을 해주며 피드백을 잘 전달하기 위한 고민을 해보는 연습도 할 수 있어서 유연성 강화 스터디는 나에게 정말 의미 있는 활동인 것 같다!\n\n![](./assets/week-5-1.png)\n\n## 점심 뭐 먹지 미션 회고 (반성...)\n\n점심 뭐 먹지 미션을 진행할 때, 웹 컴포넌트를 사용했었다. 로또 미션에서 콘솔에서 웹으로 UI가 변하면서 DOM을 조작했어야 했는데, 여기서 나름대로의 불편함을 느껴 웹 컴포넌트를 사용해보면 내가 느낀 불편함들을 해결할 수 있지 않을까 하여 사용하게 되었다. 나름대로 잘 사용해서 미션을 진행하고, PR도 잘 날렸다고 생각했는데 미션 피드백 시간에 코치들이 해준 얘기와 크루들과 대화를 나눠보면서 내가 **이번 미션의 학습 목표와는 맞지 않는 고민들을 한 것**을 알게 되었다. 점심 뭐 먹지 미션의 학습 목표를 상기해보면\n\n- 어플리케이션을 컴포넌트 단위로 모듈화하여 개발\n  - UI를 컴포넌트 단위로 생각하고 개발하는 연습\n  - 재사용할 수 있는 컴포넌트를 고민해보기\n- TypeScript의 기본 문법을 익히며 필요성을 경험\n\n위와 같다. 하지만, 지금 생각해보면 나는 컴포넌트 단위로 생각해보는 것을 빌미로 웹 컴포넌트를 사용해서 로또 미션에서 느낀 **개인적인 불편함**을 해소해보고자 했다. 로또 미션과 점심 뭐 먹지 미션은 **학습 목표가 다른 별개의 미션**인데 로또 미션의 느꼈던 불편함을 점심 뭐 먹지 미션에서 해소해보려고 시도한다...? 방향성이 많이 어긋난 생각이였던 것 같다. 그리고 컴포넌트 단위로 더 잘 모듈화 하고 재사용할 수 있는 컴포넌트는 무엇이 있고 어떻게 만들 수 있을까를 고민하기 보다는 처음 사용해보는 웹 컴포넌트를 공부하거나 이벤트를 주고 받는 방법에 대해 고민하는데 더 많은 시간을 사용한 것 같다. PR 메시지에도 학습 목표와 관련된 고민을 드러내는 이야기는 거의 없고, 새로운 기술 도입의 배경과 트러블 슈팅에 관한 내용만 있었다. ([PR](https://github.com/woowacourse/javascript-lunch/pull/122#event-12085423630)).\n\n만약 웹 컴포넌트 기술을 컴포넌트를 더 잘 모듈화하고 **재사용 가능한 컴포넌트를 만들어보기 위한 도구로써 활용했다면** 즉, **학습 목표를 더 잘 달성해보기 위한 도구로써 활용했다면** 얻어가는 것이 많았을 것 같은데 이번 미션에서는 학습 목표의 방향과 어긋난 고민을 많이 한 것 같아서 아쉬움이 많이 남았었다. 한편으로는 이번 회고와 반성을 통해서 \"현재 내 고민이 학습 목표의 방향성과 일치하는 고민인가?\"를 의식적으로 생각해보자는 결심을 하게 되었기 때문에 오히려 좋아~ 라고 생각하고 다음 미션에 적용해보기로 했다. (레벨 1에서 이걸 깨달은게 어디냐~)  \n주말에 잠실캠에 가서 점심 뭐 먹지 미션 step2를 마무리 하던 중 렌더링 효율과 관련된 고민을 했었는데 지금 이 고민은 학습 목표와 전혀 관계가 없는 고민인 것 같아서 빠르게 치워버렸다..ㅋㅋㅋㅋ\n\n## 선수타\n\n수요일에는 5기 FE 선배님들과 선수타를 가졌다. 5기 분들이 우테코 생활을 어떻게 했었는지에 대한 얘기를 들을 수 있었고, 6기 생활을 어떻게 하면 좋을지에 대한 간단한 조언도 들을 수 있었다. 공통적으로,\n\n- 남들에게 설명하면서 공부하는 것\n- 같은 분야를 공부하는 크루들이 모여있는 훌륭한 환경을 적극 활용하여 개발 관련 잡답 즐겨보기\n- 우테코에서만 할 수 있는 활동을 해보기\n\n등에 대한 조언을 해주셨다. 슬랙에 `블로그-포스팅-스터디`를 만드신 선배분의 발표가 가장 기억에 남았는데, 진행했던 스터디 이름이 잘 기억 나지는 않지만 크루들끼리 특정 시간에 특정 행동을 릴레이 방식으로 해야만하는 스터디가 매우 재밌고 흥미로워보였다. 개발 관련 스터디만 하는게 아니라 여러 유형의 스터디를 하면 우테코 생활을 더 재밌고 유익하게 할 수 있겠구나하고 생각했다..ㅋㅋㅋ 기록의 중요성도 강조해주셨는데, 기억보다는 기록을 하기 위해서 블로그-포스팅-스터디를 만드셨다고 한다. 현재 나도 이 스터디에 참여해서 열심히 회고를 작성하고 있다(?). 우테코에 오기 전 까지는 이렇게까지 열심히 회고를 하지 않은 것 같은데 매일 많은 정보가 들어오고, 하루의 구성이 거의 비슷하고 어제와 이틀 전이 잘 구분이 안가기 시작하면서 기록이 정말 중요하겠다고 깨달은 후 나름대로 열심히 기록과 회고를 하고있다. 선수타가 끝나고 선배님들과 따로 이야기를 나누는 시간을 가졌다. 이야기가 끝나고 내용을 정리해보니 우테코가 강조하는 내용과 이어져 정말 놀랐었다.\n\n- 잡담\n\n제일 처음 점심 뭐 먹지 미션에 대해 나름대로 반성한 경험에 대해 이야기를 나누면서, 로또 미션을 진행하면서 느꼈던 불편함은 **나 혼자 결론지은 불편함**이였다는 것을 알게 되었다. 주변 크루들에게 다가가서 불편함에 대해 얘기해보는 시간을 가졌더라면 내 생각이 달라질 수 있었고 불편함에 대한 결론이 **웹 컴포넌트를 사용해보자가 아닐수도 있었다.** 앞으로는 혼자 생각하고 결론을 짓기 보다는 내 생각과 생각을 통한 나름대로의 결론을 크루들에게 다가가서 얘기해보고 다른 크루들도 나와 같은 생각인지, 다르다면 그 크루는 어떻게 생각하는지에 대해서 이야기 해보는 시간을 많이 가져야겠다.\n\n- 몰입\n\n우테코 생활을 하면서 내가 지금 우테코에 몰입을 하고 있는 것인지, 매몰되어 있는 것인지 헷갈리는 순간들이 있었다. 뭐든지 과하면 안좋은 결과를 초래할 수 있고, 몰입과 매몰은 정말 한끗차이인 것 같다고 생각해 같이 이야기를 나눈 선배님에게도 혹시 현재 나와 같은 고민을 한 적이 있는지에 대해서 물었고 선배님은 \"몰입과 매몰을 나누는 기준을 우테코 미션으로 잡아보는 것은 어떤가요?\"라고 대답해주셨다. 정말 괜찮은 접근 방법이다! 미션에서 주어지는 학습 목표에 대한 고민을 **너무 과하게하거나 방향성이 어긋나는 것 같은 고민을 하고 있다면 그건 어쩌면 매몰되어 있는것인지도 모른다.** 앞으로 페어 프로그래밍으로 미션을 진행하거나, 혼자 step2를 진행할 때도 의식적으로 미션을 기준으로 내가 지금 잘 몰입하고 있는지, 매몰되어 있는지에 대해서 생각해봐야겠다.\n\n- 경험\n\n5주차는 조금 혼란스러웠던 것 같다. 1~2주차 회고에서 언급했던 익숙지 않은 환경으로 인한 혼란스러움보다는 미션을 잘못 대하고 있는 것 같다는 생각으로 인한 혼란스러움이였다. 이에 대해서도 얘기를 해주셨는데 지금 내가 느끼는 혼란스러움들은 모두 경험이고, 이런 경험들도 나중에 피가되고 살이되니 경험을 쌓고 성장하고 있는 과정이라고 생각하라고 말씀해 주셨다.\n\n선수타 시간을 통해서 앞으로 어떻게 우테코 생활을 할지에 대한 인사이트를 얻은 것 같아서 너무 좋은 시간이였다. 😊\n\n## todo-mate\n\n저번 주 목요일부터 크루들과 함께 todo-mate를 하고있다. todo-mate는 계획을 공유하고 상대방의 계획에 대한 반응을 남길 수 있는 앱인데, J인 나로써는 너무 좋고 유용할 것 같아서 같이 하고있다!\n\n![](./assets/week-5-2.png)\n\n다른 크루들은 오늘 어떤 계획을 가지고 캠퍼스에 오는지 알 수 있고, 반응도 남길 수 있어서 정말 재밌게 하고있다. 유연성 강화 스터디든, todo-mate든 확실히 혼자보다는 같이 하는게 훨씬 재밌고 오래할 수 있는 것 같다.\n\n## 왔다감 고정멤버\n\n어느 순간부터 캠퍼스 왔다감 고정 멤버가 되었다.(지토썬해...)  \n늦게까지 남아서 공부를 하며 다른 데일리 조 크루들과 이야기할 수 있는 시간이 많이 생겨 빠르게 친해진 것 같아서 좋았다. 한편으로는 왔다감 멤버가 되는 것에 익숙해지면서 **\"맹목적으로 11시까지 캠퍼스에 남아있게되지는 않을까?\"에 대한 걱정**도 생겼다. 정규 시간이 끝난 뒤에도 5시간 동안이나 캠퍼스에 남게 될 텐데, 길다면 긴 이 시간을 어떻게 잘 활용하고 집중의 비중을 높일 수 있을까에 대한 고민을 했다. 일단 지금은 이 고민을 해결하기 위해서 **오늘 내가 정규 시간이 끝난 뒤에도 남기로 한 이유와 목적을 글로 적는 것을 해보는 중이다.** \"오늘 내가 ~~해야 하니 남아야지\"하며 생각만 하는 것 보다 글로도 옮겨 적으면서 한번 더 리마인드를 해보고 있다. 이 방법이 괜찮은 방법인지는 잘 모르겠으나 어느 정도 효과는 있는 듯하다.\n\n![](./assets/week-5-3.png)\n\n위 사진 처럼 카톡 나에게 보내기를 하거나 노션에 정말 간단하게 정리 중이다. 왔다감을 하는 크루들끼리 데일리 미팅을 하며 11시까지 남는 목적을 공유해보는 시간을 가지는 것도 생각해봤는데 하루에 2번 데일리 미팅을 하는 것은 체력적으로 힘들 것 같다는 생각이 들어 보류중이다. 뭐 좋은 방법 없을까~?\n\n## 마니또\n\n지난 주 금요일(3/8) 데일리 마스터였던 빙봉이 마니또 게임을 준비해왔다. 게임 규칙은 아래와 같았다.\n\n- 마니또에게 1주일 동안 잘해주기(마니또 몰래 특별한 미션(?) 하나 수행하기)\n  - DM 보내기\n  - 크루 닉네임으로 2행시 짓기\n  - 크루에게 손 편지 작성하기\n  - 크루 초상화 그리기\n  - 금요일 족발 회식 때 마니또 공개!\n\n![](./assets/week-5-4.jpeg)\n![](./assets/week-5-5.jpeg)\n\n나는 일주일 동안 마니또에게 위 사진 처럼 2행시를 전달 받고, 단백질 음료수도 선물 받았다. 위 선물을 받기 전 수야에게 DM을 받아서 수야라고 생각하고 있었는데 뭐지? 혼란스러웠다..ㅋㅋㅋ 하지만 내 마니또가 실수를 하는 바람에 누가 내 마니또인지 알 수 있었다. 우리 데일리 조의 크루들은 대부분 도시락을 싸오고 점심을 같이 먹는다. 점심을 같이 먹다가 해시가 똑같은 음료수를 꺼내 먹으면서 \"실수했다..\"라고 말해버려 내 마니또가 누구인지 바로 알게되었다. 그런데 공개 전 티를 내면 재미가 없으니 모르는 척 하기로 했다...밥을 먹을 때 고개를 숙여야하니 숙이면서 티가 나지 않게 웃었다..ㅋㅋㅋㅋㅋ (해시 땡큐!)\n\n나의 마니또는 헤인이였고 미션은 손편지 작성하기였다. 손편지를 쓰기로 결정한 날 좋은 글을 읽어 응원의 말과 함께 해당 글의 내용을 공유했다. 그리고 헤인이 자리에 없을 때 젤리와 함께 몰래 올려놓았다. 빙봉이 재밌는 게임을 준비해와서 일주일 동안 내 마니또가 누구인지, 어떻게 마니또에게 안들키고 미션을 수행할 수 있는지에 대한 재밌는 고민을 했던 것 같다. 빙봉 아이디어 굿~👍\n\n## 회원증\n\n![](./assets/week-5-6.jpeg)\n\n회원증을 보니 다시 한번 내가 우테코 크루라는 것을 실감할 수 있었고, 데일리 조와 모여서 다같이 회원증 사진도 찍었다. 앞으로도 열심히 해보자~😊\n"},{"excerpt":"서론 3주차 로또 미션을 진행할 때, 정말 자연스럽게 id와 class를 혼용해서 사용했다. 너무나도 자연스럽게 id는 특정 HTML 요소를 자바스크립트에서 접근할 때 사용했고, class는 스타일을 적용할 때 사용했었는데 어떤 이유로 이렇게 구분지어 사용한건지 id와 class의 차이점을 알아보며 학습하고자 한다! ID id는 HTML 문서 전체에서 한…","fields":{"slug":"html-class-vs-id"},"frontmatter":{"date":"March 04, 2024","title":"HTML Attribute의 id와 class 차이 이해해 보기","tags":["HTML","Javascript","우아한테크코스"]},"rawMarkdownBody":"\n### 서론\n\n```html\n<button id=\"modal-cancel-button\" class=\"cancel-button text-m\">X</button>\n```\n\n3주차 로또 미션을 진행할 때, 정말 자연스럽게 id와 class를 혼용해서 사용했다.\n\n너무나도 자연스럽게 id는 특정 HTML 요소를 자바스크립트에서 접근할 때 사용했고, class는 스타일을 적용할 때 사용했었는데 어떤 이유로 이렇게 구분지어 사용한건지 id와 class의 차이점을 알아보며 학습하고자 한다!\n\n## ID\n\nid는 HTML 문서 전체에서 한 엘리먼트를 유일하게 식별해야할 때 사용할 수 있다.\n\n```html\n<button id=\"some-id\">X</button>\n```\n\n```css\nsomd-id{\n  some-style...\n}\n```\n\n```js\nconst someDOM = document.getElementById(\"some-id\")\n```\n\n`#`를 사용해서 스타일을 적용할 수 있고, getElementById를 사용해서 특정 id를 가진 HTML 요소에 접근할 수 있다.\n\nid는 다음과 같은 특징을 가진다.\n\n### 1. 한 요소는 오직 하나의 id만 가질 수 있다, 여러 요소가 동일한 id를 가질 수 없다.\n\n```html\n<h1 id=\"my-name\">Harry</h1>\n<h1 id=\"my-name\">Hyun</h1>\n```\n\n```js\nconst myName = document.getElementById(\"my-name\")\n\nconsole.log(myName) // <h1 id=\"my-name\">Harry</h1>\n```\n\n동일한 id를 가진 2개의 h1요소를 getElementById로 접근하면 첫 번째 h1 요소만 접근하게된다. id는 전체 HTML 문서에서 유일하기 때문에 특정 요소를 빠르게 찾아야 할 때 유용하게 활용할 수 있다.\n\n## 2. id 이름에 공백이 있다면 공백마저 id 이름으로 취급한다.\n\n공백을 통해 구분하는 class와는 달리, id에 공백이 있다면 그 공백마저 하나의 id에 포함시키기 때문에 공백으로 혼란을 줄 수 있는 상황은 피하는게 좋다.\n\n```html\n<h1 id=\"my name\">Harry</h1>\n// id : my name\n```\n\n```js\nconst myName = document.getElementById(\"my name\")\nconsole.log(myName) // <h1 id=\"my-name\">Harry</h1>\n```\n\n### 3. css 선택자 우선순위가 class보다 높다.\n\n```html\n<h1 id=\"my-name\" class=\"harry\">Harry</h1>\n```\n\n```css\n#my-name {\n  color: red;\n}\n\n.harry {\n  color: blue;\n}\n```\n\nid와 class를 모두 사용해서 스타일을 지정할 경우 id가 우선순위가 더 높기 때문에 텍스트의 색상이 red가 된다.  \n위에서 확인할 수 있듯이, 전체 HTML 문서에서 오직 하나의 요소에 빠르게 접근하기 위해 id를 사용해볼 수 있다. 하지만, 스타일이나 동작이 같은 여러개의 HTML 요소들을 유형별로 구분하기 위해서는 class 사용이 더 적합할 수 있다.\n\n## Class\n\nclass는 id와 달리 한 HTML 문서 내에서 중복해서 사용될 수 있고, 하나의 HTMl 요소는 여러개의 클래스를 가질 수 있어 스타일과 동작을 유형별로 묶을 때 활용할 수 있다.\n\n```html\n<h1 class=\"harry\">Harry</h1>\n```\n\n```css\n.harry {\n  color: blue;\n}\n```\n\n```js\nconst myName = document.querySelector(\".harry\")\nconst myName = document.getElementsByClassName(\"harry\")\nconst myNameList = document.querySelectorAll(\"harry\")\n```\n\n`.`을 사용해서 스타일을 적용할 수 있고, class 이름을 인자로 넘기는 메서드들을 활용해서 특정 class를 가진 HTML 요소에 접근할 수 있다.\n\nclass는 다음과 같은 특징을 가진다.\n\n### 1. 중복이 가능하다.\n\n- 스타일 중복\n\n한 HTMl 요소는 여러개의 class를 가질 수 있다. 이를 활용해서 비슷한 스타일과 동작을 가지는 요소들을 유형별로 묶을 수 있다.\n\n```html\n<div class=\"flex justify-between\">\n  <span class=\"text-sm font-light\">당첨 번호</span>\n  <span class=\"text-sm font-light\">보너스 번호</span>\n</div>\n<div class=\"flex justify-between\">\n  <div id=\"winning-lotto-input-container\" class=\"flex gap-x-1\"></div>\n  <div id=\"bonus-number-input-container\"></div>\n</div>\n```\n\n로또 미션 step2를 진행하면서 작성했던 HTML 코드이다.\n\n```css\n.flex {\n  display: flex;\n}\n\n.justify-between {\n  justify-content: space-between;\n}\n\n.text-m {\n  font-size: 2.1rem;\n}\n\n.font-light {\n  font-weight: lighter;\n}\n```\n\n여러 요소들에 중복해서 사용되는 스타일들을 class를 통해서 정의하고 해당 스타일이 필요한 요소에서 class 이름을 중복해서 사용함으로써 스타일을 적용하고 있다. 만약 id를 사용해서 스타일을 정의했을 경우 오직 하나의 HTML 요소에만 적용할 수 있기 때문에 스타일이 같더라도 새로운 요소를 만들 때마다 중복해서 같은 스타일을 지정해줘야 하는 불편함이 있을 것이다.\n\n- 동작 중복\n\n```js\nstatic #renderWinningLottoInputs() {\nif (!WinningLottoForm.#isEmptyHTML(WinningLottoForm.#winningLottoContainer))\nreturn;\n\n    WinningLottoForm.#winningLottoContainer.innerHTML = `<inputtype=\"number\"\n        class=\"text-h-center winning-input winning-lotto-input\"\n        id=\"winning-number-input\"\n        required\n        min=\"1\"\n        max=\"45\"/>`.repeat(6);\n\n}\n```\n\n6개의 input 요소들이 모두 당첨 번호와 관련되어 있어 동일한 class 이름(winning-lotto-input)을 설정하고, querySelectorAll 메서드를 사용해서 한번에 참조할 수 있었다.\n\n### 2. className, classList API\n\n한 HTML 요소는 여러개의 class를 가질 수 있기 때문에 자바스크립트는 해당 클래스들을 조작할 수 있도록 className, classList API를 제공한다.\n\n- className\n\n특정 HTML 요소의 클래스 이름들을 문자열 형태로 참조한다.\n\n```html\n<h1 class=\"harry hyun woong\">Harry</h1>\n```\n\n```js\nconst myName = document.querySelector(\".harry\")\nconsole.log(myName.className) // harry hyun woong\nconsole.log(typeof myName.className) // string\n\nmyName.className = \"styles\"\n```\n\n해당 요소의 모든 클래스 이름들을 하나의 문자열 형태로 참조할 수 있고, 클래스 이름에 다른 문자열을 할당해서 스타일이나 동작을 변경할 수도 있다. 한 요소가 너무 많은 클래스 이름들을 가진다면 문자열을 직접 할당해서 변경하는 것 보다 classList 에서 제공하는 메서드들을 통해 클래스 이름들의 구성을 변경할 수 있다.\n\n- classList\n\nclassList는 읽기 전용 프로퍼티이며, remove와 add등 한 요소의 클래스 이름들의 구성을 변경할 수 있는 유용한 메서드를 제공한다.\n\n```js\nconst myName = document.querySelector(\".harry\")\nconsole.log(myName.classList) // harry hyun woong\nconsole.log(myName.classList[0]) // harry\n\nmyName.classList[0] = \"choi\" // error\n```\n\n인덱스를 통해서 여러개의 클래스 중 하나의 클래스 이름을 참조할 수 있으며, 읽기 전용 프로퍼티이기 때문에 할당을 통해서 변경하려고 하는 경우 에러가 발생한다.\n\n```html\n<form id=\"winning-lotto-form\" class=\"hidden winning-lotto-form\"></form>\n```\n\n```css\n.hidden {\n  visibility: hidden;\n}\n```\n\n```js\nstatic renderWinningLottoForm() {\n\tWinningLottoForm.#winningLottoForm.classList.remove(\"hidden\");\n\t//...\n}\n\nstatic hideWinningLottoForm() {\nWinningLottoForm.#winningLottoForm.classList.add(\"hidden\");\n}\n```\n\n위 코드는 이번 미션을 진행할 때, 당첨 결과 모달을 렌더링하거나 숨기기 위해서 구현한 메서드들이다. remove 메서드를 사용해서 클래스의 이름들 중 hidden을 지우면 모달이 렌더링 되고 add 메서드를 통해서 hidden을 추가하면 모달이 숨겨진다. remove, add 이외에도\n\n- contains: 클래스 이름들 중 특성 클래스를 포함하는지를 확인한다.\n- replace(oldClass, newClass): void, 기존의 클래스들에서 새로운 클래스들로 변경한다.\n\n등 다양한 메서드들을 제공한다.\n"},{"excerpt":"서론 로또 step2 미션을 진행하면서, 여러개의 DOM을 한번에 참조해야 하는 상황이 생겼다. 당첨 번호를 입력할 때, 제일 처음에 입력 할 당첨 번호 input에 focus를 해줘야 하는 상황 사용자가 입력한 당첨 번호를 확인해야 하는 상황 과 를 사용하면서 이 두개의 반환값은 뭘까? 궁금했었고 children은 이며, querySelectorAll은…","fields":{"slug":"htmlcollection-vs-nodelist"},"frontmatter":{"date":"March 04, 2024","title":"HTMLCollection과 NodeList 차이 이해해 보기","tags":["HTML","Javascript","우아한테크코스"]},"rawMarkdownBody":"\n## 서론\n\n로또 step2 미션을 진행하면서, 여러개의 DOM을 한번에 참조해야 하는 상황이 생겼다.\n\n1. 당첨 번호를 입력할 때, 제일 처음에 입력 할 당첨 번호 input에 focus를 해줘야 하는 상황\n\n```js\nstatic focusFirstWinningLottoInput() {\n  WinningLottoForm.#winningLottoContainer.children[0].focus();\n}\n```\n\n2. 사용자가 입력한 당첨 번호를 확인해야 하는 상황\n\n```js\nconst getWinningLottoNumbers = () => {\n  const winningLottoInputs = document.querySelectorAll(\n    ELEMENT_SELECTOR.winningLottoInput\n  )\n  //...\n}\n```\n\n`children`과 `querySelectorAll`를 사용하면서 이 두개의 반환값은 뭘까? 궁금했었고 children은 `HTMLCollection`이며, querySelectorAll은 `NodeList`임을 확인할 수 있었다.\n\n- HTMLCollection\n\n![](./assets/1.png)\n\n- NodeList\n\n![](./assets/2.png)\n\n이 두개의 차이점에 대해서 예전에 자바스크립트 딥다이브를 읽으면서 공부했던 적이 있었지만, 잘 기억이 나지 않아 이번 기회에 다시 학습해보고자 한다.\n\n## HTMLCollection\n\nHTMLCollection은 문서(HMTL) 내부에서 선택한 요소만을 정렬된 순서대로 모아둔 집합 나타내며 위 예시 처럼 여러 DOM에 접근해야할 때 사용할 수 있다.\n\n![](./assets/3.png)\n\n유사 배열 객체이기 때문에,\n\n- length 프로퍼티를 가진다\n- 인덱스를 통해서 접근할 수 있다.\n- 이터러블 하기 때문에 for...of 로 순회할 수 있다.\n\n하지만 배열은 아니기 때문에 map, reduce, filter와 같이 배열 프로토타입 메서드는 사용할 수 없다. HTMLCollection의 가장 큰 특징은 **살아 있다(live-collection)는 것이다.**\n\n### 살아있는 HTMLCollection\n\nHTMLCollection를 반환하는 메서드는\n\n- `getElementsByTagName`\n- `getElementsByClassName`\n- `children` 프로퍼티\n\n3가지가 있다.\n\nHTMLCollection이 살아있는 객체라는 것의 의미는 **DOM의 변경사항을 실시간(live)로 반영**한다는 것이다. 아래의 예시를 통해 “살아있다”는 것의 의미를 이해해보자.\n\n```html\n<style>\n  .blue {\n    color: blue;\n  }\n\n  .red {\n    color: red;\n  }\n</style>\n<body>\n  <div id=\"app\">\n    <h1 class=\"blue\">Harry</h1>\n    <h1 class=\"blue\">Hyun</h1>\n    <h1 class=\"blue\">Hyunwoong</h1>\n  </div>\n  <script type=\"module\" src=\"./src/study/index.js\"></script>\n</body>\n```\n\n![](./assets/4.png)\n\n클래스 이름이 blue 이며, 텍스트의 색이 파란색임을 확인할 수 있다. `for...of` 로 HTMLCollection을 순회하면서 텍스트의 색을 빨간색으로 변경해보자.\n\n```js\nconst names = document.getElementsByTagName(\"h1\")\nconst names = document.getElementsByClassName(\"blue\")\nconst names = document.getElementById(\"app\").children\n\nfor (let i = 0; i < names.length; i++) {\n  names[i].className = \"red\"\n}\n```\n\n`getElementsByClassName` 메서드를 호출함으로써, 문서(HTML)내에 선택한 요소(blue)들을 정렬된 순서로 모아둔 집합을 얻을 수 있고 순회하며 클래스 이름을 red로 변경했기 때문에 모든 텍스트의 색이 빨간색으로 변경될 것이라 예상된다. 하지만,\n\n![](./assets/5.png)\n\n예상과는 다르게 2번 째 텍스트는 색이 그대로 파란색임을 확인할 수 있는데, 클래스 이름이 변경된 사항을 실시간으로 반영해서 names의 구성이 달라지기 때문에 발생한 현상이다.\n\n- `i = 0`\n\n첫 번째 요소(Harry)의 클래스 이름이 red로 변경된다.\n더이상 클래스 이름이 blue가 아니기 때문에 names에서 제거된다.\n첫 번째 반복문이 종료되면 names의 구성은 [Hyun, Hyunwoong]가 된다.\n\n- `i = 1`\n\n[Hyun, Hyunwoong]으로 구성된 집합에서 인덱스가 1인 요소는 Hyunwoong이기 때문에 해당 요소의 클래스 이름이 red로 변경된다.\n더이상 클래스 이름이 blue가 아니기 때문에 names에서 제거된다.\n두 번째 반복문이 종료되면 names의 구성은 [Hyun]가 된다.\n\n- `i = 2`\n\n[Hyun] 집합의 길이는 1이고 인덱스가 2인 요소가 존재하지 않기 때문에 클래스 이름이 변경되는 동작이 발생하지 않는다.\n위와 같은 내용으로 반복문을 순회하면서 DOM의 변경사항을 실시간으로 반영한다는 특징이 있다\n\n## NodeList\n\nNodeList는 문서(HMTL) 내부에서 선택한 요소와 텍스트, 주석, 속성등 모든 노드를 정렬된 순서대로 모아둔 집합 나타낸다.\n\nHTMLCollection과 대비되는 특징으로는\n\n- 경우에 따라 live-collection이 될 수도 non-live-collection이 될 수도 있다.\n- forEach를 사용할 수 있다. 이 때, forEach는 배열 프로토타입 메서드가 아닌 NodeList가 독자적으로 가지는 메서드이다.\n\n### 1. 살아있는 NodeList\n\n살아있는 NodeList를 반환하는 것은 `Node.childNodes`가 있다.\n\n```html\n<body>\n  <div id=\"app\">\n    <h1>🎱 행운의 로또</h1>\n    <!-- 주석 -->\n    <h1>💌 행운의 편지</h1>\n    <h1>🍀 행운의 네잎클로버</h1>\n  </div>\n  <script type=\"module\" src=\"./src/study/index.js\"></script>\n</body>\n```\n\n```js\nconst luckyText = document.getElementById(\"app\").childNodes\nconsole.log(luckyText)\n```\n\n![](./assets/6.png)\n\n`Node.childNodes` 프로퍼티가 반환하는 살아있는 NodeList는 위 사진에서도 확인할 수 있듯이 선택한 HTML 요소 뿐만 아니라 **텍스트(\\n)와 주석 등 모든 노드를 정렬된 순서대로 모은 집합**이다. HTMLCollection 처럼 DOM의 변경사항을 실시간으로 반영한다.\n\n```js\nconst app = document.getElementById(\"app\")\n\nconst luckyText = app.childNodes\n\nconsole.log(luckyText.length) // 9\n\nconst H1 = document.createElement(\"h1\")\nH1.innerHTML = \"🚀 행운의 로켓\"\napp.appendChild(H1)\n\nconsole.log(luckyText.length) // 10\n```\n\n위 예시에서도 확인할 수 있듯이, `🚀 행운의 로켓` 을 추가하면 해당 변경사항이 바로 DOM에 반영이 되기 때문에 luckyText의 길이가 9에서 10으로 증가한 것을 바로 확인할 수 있다.\n\n### 2. 살아있지 않은 NodeList\n\n살아있는 NodeList를 반환하는 메서드는 `querySelectorAll`가 있다.\n\n```html\n<body>\n  <div id=\"app\">\n    <h1 class=\"blue\">🎱 행운의 로또</h1>\n    <!-- 주석 -->\n    <h1 class=\"blue\">💌 행운의 편지</h1>\n    <h1 class=\"blue\">🍀 행운의 네잎클로버</h1>\n  </div>\n  <script type=\"module\" src=\"./src/study/index.js\"></script>\n</body>\n```\n\n```js\nconst blueTitleList = document.querySelectorAll(\".blue\")\nconsole.log(blueTitleList)\n```\n\n![](./assets/NodeList.png)\n\n`querySelectorAll` 메서드가 반환하는 살아있지 않은 NodeList는 childNodes 프로퍼티를 통해 참조할 수 있는 NodeList와 다르게 **텍스트, 주석, 속성들을 포함하지 않고 선택한 HTML 요소만을 가지는 집합**임을 확인할 수 있다.\n\n```js\nblueTitleList.forEach(node => {\n  node.className = \"red\"\n})\n```\n\nforEach 메서드를 활용해서 모든 요소의 클래스 이름을 red로 변경하면 **변경사항이 바로 DOM에 반영되지 않기 때문에, 모든 요소의 텍스트 색을 빨간색으로 변경할 수 있다.**\n\n![](./assets/7.png)\n\n```js\nconst blueTitleList = document.querySelectorAll(\".blue\")\n\nconsole.log(blueTitleList.length) // 3\n\nconst H1 = document.createElement(\"h1\")\nH1.innerHTML = \"🚀 행운의 로켓\"\nH1.className = \"blue\"\napp.appendChild(H1)\n\nconsole.log(blueTitleList.length) // 3\n```\n\n또, 새로운 노드를 추가하는 변경사항도 DOM에 바로 반영되지 않기 때문에 새로운 노드를 추가해도 길이는 유지된다.\n\n## 결과를 예측할 수 없는 상황 예방하기\n\nHTMLCollection 예시에서 3개의 텍스트의 색이 모두 빨간색으로 변경될 것으로 예상 됐지만, 실시간으로 변경을 감지하는 특징으로 인해 예상과는 다른 결과가 나타났다. NodeList도 경우에 따라서 실시간으로 변경을 감지하므로 결과를 예측할 수 없는 상황이 충분히 발생할 수 있다. 이런 상황을 예방하기 위해서, 여러개의 DOM을 더 편하게 다루기 위해서 배열로 치환한 후 사용할 수 있다. 배열로 치환하면 항상 정적임을 보장할 수 있다.\n\n```js\nconst names = document.getElementsByClassName(\"blue\")\n\n;[...names].forEach(name => {\n  name.className = \"red\"\n})\n\nArray.from(names).forEach(name => {\n  name.className = \"red\"\n})\n```\n\n스프레드나 `Array.from` 을 사용해서 배열로 치환한 후 클래스 이름을 red로 변경하면 모든 텍스트의 색이 빨간색으로 잘 변경이 되는 것을 확인할 수 있다.\n\n```js\nconst getWinningLottoNumbers = () => {\n  const winningLottoInputs = document.querySelectorAll(\n    ELEMENT_SELECTOR.winningLottoInput\n  )\n\n  return [...winningLottoInputs].map(winningNumber => {\n    return winningNumber.value\n  })\n}\n```\n\n나 역시 이번 미션을 진행할 때, 입력한 당첨 번호를 가져오는 함수를 구현할 때 선언적으로 작성하고싶어 map 메서드를 활용하기 위해서 배열로 치환했었다. 😊\n"},{"excerpt":"우테코를 위해 부산에서 서울로 올라온 건 2/5 였다. 지금 서울에 올라온지 딱 한 달 정도가 됐다. 3주차가 지난 시점에서 1, 2 주차를 돌아보자면 정말 혼란 그 자체였다. 낯을 정말 많이 가리는 성격에(MBTI 중 I의 비중이 제일 높다..),기존에 살던 곳에서 500KM이나 떨어진 곳에, 새로운 사람들... 새로운 환경에 적응해보기 위해서 몸부림을…","fields":{"slug":"woowacourse-level-1-week1&2-retrospect"},"frontmatter":{"date":"March 04, 2024","title":"우아한테크코스 레벨1 1~2주차 돌아보기","tags":["회고","우아한테크코스"]},"rawMarkdownBody":"\n![](./assets/week-1&2-1.png)\n우테코를 위해 부산에서 서울로 올라온 건 2/5 였다. 지금 서울에 올라온지 딱 한 달 정도가 됐다. 3주차가 지난 시점에서 1, 2 주차를 돌아보자면 정말 혼란 그 자체였다. 낯을 정말 많이 가리는 성격에(~~MBTI 중 I의 비중이 제일 높다..~~),기존에 살던 곳에서 500KM이나 떨어진 곳에, 새로운 사람들... 새로운 환경에 적응해보기 위해서 몸부림을 쳤던\n기억이 제일 강하다. 거기다가 갑자기 연극이라뇨?\n\n## 연극\n\n우테코를 시작하기 전, 연극의 존재는 이전 기수분들의 블로그를 읽으며 이미 알고 있었다. 하지만, 연극의 존재를 미리 알고 있다는 것이 연극을 준비하는데는 아무런 도움이 되지 않았고 오히려 올게 왔구나.. 하는 생각을 했다. 이전 기수분들의 블로그를 읽을 때는 '에이...이걸 진짜 한다고? 설마~' 라는 생각을 하며 블로그를 읽을 다음 기수분들을 위한 몰래카메라인 줄 알았지만 진짜 연극을 해야했다.\n\n## 우아한 나락 퀴즈쇼\n\n나의 연극조는 나(해리), 낙타, 포메, 해시 빙봉이였다. 모두가 내향인이였고 연극에 대한 걱정들이 엄청났다. 주제에 관한 얘기를 하던 중, 낙타가 피식대학의 나락 퀴즈쇼를 우테코 버전으로 만들면 어떨까 하는 의견을 제시했고 모두가 찬성해 우아한 나락 퀴즈쇼를 준비하게 되었다. 주제가 워낙 강력하고 형식이 짜여 있다 보니 주제가 정해지고 나서부터는 연극 준비가 수월하게 진행됐다. 나는 퀴즈쇼 진행자(김민수)의 역할을 맡게 되었다. 굉장히 많은 질문 후보들이 나왔지만 5분이라는 요구사항을 만족하기 위해서 4개의 질문만 준비하기로 했다. 선정된 질문들은\n\n- 알맞은 우아한 테크코스 로고 고르기\n- 가장 나이가 많아 보이는 코치 고르기\n- 자바스크립트를 만든 사람 고르기\n- 가장 첫인상이 별로였던 코치 고르기\n\n들이였고, 과연 이 질문들을 해도 될까? 진짜 나락 가면 어떡하지? 라는 걱정을 했었다..\n연극을 준비하면서 연극조 사람들과 슬라이드를 같이 만들고, 같이 연극을 걱정하면서 의견 공유도 많이 하고 많은 대화를 나누었고 이로 인해 빠르게 친해질 수 있었던 것 같다. 연극 당일 포메가 코로나에 걸려 같이 참여를 못하게 되어 너무 아쉬웠고, 연극 진행에 필요했던 코치들도 자리에 없어 더 많은 재미를 유도하지 못해서 아쉬었다. 하지만, 연극을 잘 마무리 했다는 것에 의미를 두고 싶다! 리허설, 최종 순위 모두 4위를 해서 나름 재밌는 연극을 한 것 같아 만족했다. 😊\n\n![](./assets/week-1&2-2.png)\n\n연극은 몰래카메라가 아니라 진짜입니다. 이 글을 읽을지도 모를 우테코 7기분들 화이팅 하세요~!\n\n## 페어 프로그래밍\n\n연극을 준비하면서 온보딩 미션 [자동차 경주](https://github.com/woowacourse/javascript-racingcar)를 페어 프로그래밍으로 진행했다. 내 페어는 빙봉이였고 프리코스 때도 진행했던 미션이라, 각자 해당 미션을 어떻게 진행했고 무엇을 고민해봤는지에 대해 이야기를 나누었다. 각자 고민한 내용은 비슷했지만, 구현 방식에 차이가 있었고 \"설득하고 설득 당하기\" 대화를 하면서 내가 생각한 방식으로 이번 미션을 진행해보기로 했다. 15분 동안 네비게이터, 드라이버 역할을 번갈아 가며 진행하려 했지만 처음이다보니 시간을 재는 것도 까먹고 각 역할을 어떻게 수행해야되는지에 대한 감이 없어 한 명이 계속 네비게이터를 하거나, 드라이버를 하고 있는 상황도 발생했다. 페어 프로그래밍 경험이 처음이라 너무 어색했지만, 같이 기능 명세서를 작성하고 미션을 해결하기 위한 고민을 공유하는 경험은 정말 재밌었다. ([PR](https://github.com/woowacourse/javascript-racingcar/pull/260))\n\n첫 페어 프로그래밍을 끝내고, \"우테코 미션을 진행하면서 페어 프로그래밍을 계속해서 하게 될 텐데, 어떡하면 이 시간을 더 잘 활용해 볼 수 있을까?\"에 대한 고민을 했었다. 이 고민은 포비가 해줬던 말을 통해서 바로 해결할 수 있었다.\n\n> _페어 프로그래밍을 할 때, 아무말도 하지 않고 페어의 의견만 수용하면서 프로그래밍 하면 그건 본인 손해입니다. 모르는게 있으면 바로 질문하고, 반대되는 의견이 있으면 제시해보고 이렇게 해야 남는게 많을겁니다._\n\n이 말을 듣고 나서 \"이거다...!\" 싶었다. 포비의 말을 듣고 앞으로 페어 프로그래밍 시간을 어떻게 활용할지에 대한 감이 잡혔다. 더 많이 소통하고, 더 많이 설득하고 설득당하는 자세로 페어 프로그래밍을 해야겠다고 생각했다.\n\n2주차 [콘솔 기반 로또 게임](https://github.com/woowacourse/javascript-lotto)은 같은 데일리 조의 헤인과 진행했는데, 자동차 경주 미션 때 페어 프로그래밍보다 더 많은 이야기를 나눴다. 로또 미션을 진행하면서 TDD를 배울 수 있는 시간이 있었는데, 수업 시간이 끝나도 TDD가 무엇인지 와닿지 않았고 어떻게 해야할지에 대한 감도 잡히지 않았다. TDD에 대해서도 헤인과 이야기를 나눴는데 TDD가 무엇인지 잘 모르겠고, 와닿지도 않고, 필요한지 그렇지 않은지에 대해서도 잘 모르겠으니, TDD에 대해 나름대로 판단을 내려보기 위해 이번 미션을 완전 TDD로 구현해보자고 의견이 모아졌다. 미션을 진행하면서, 헤인과\n\n- 상속과 조합의 차이는 무엇이고 왜 LMS에서는 조합을 권장하는지?\n- 뎁스를 늘리더라도 최대한 함수의 동작을 순수하게 만드는 것이 좋은지?\n- 상태를 가지고 있는 객체가 스스로 동작하며 객체끼리 메시지를 주고받게 하려면 어떻게 해볼 수 있을지?\n\n위와 같은 주제로 많은 이야기를 나누었고, 3주차가 지난 시점에서 헤인과의 페어 프로그래밍을 되돌아봤을 때 미션을 진행하기 위한 코드를 짰던 시간들보다\n이야기를 나누었던 시간이 더 강하게 기억에 남았다. ([PR](https://github.com/woowacourse/javascript-lotto/pull/282)) 콘솔 기반 로또 게임 미션이 종료된 후 상속과 조합의 차이에 대해서 더 이해해보고싶어, 공부를 하고 내용을 기록했다!\n\n- [상속과 조합의 차이 이해해 보기](https://hwinkr.github.io/inheritance-vs-composition)\n\n## 리뷰를 대하는 자세\n\n페어 프로그래밍 미션을 제출하면, 현업자 분들께 리뷰를 받을 수 있었다. 미션을 진행하면서, 내 코드를 완벽하게 짠 후 제출하고 싶은 욕심이 있었다. 하지만, 3주차가 지난 시점에서는 완벽하고 모두가 만족하는 코드를 짜는 것은 사실상 불가능에 가깝기 때문에 완벽하게 짜기 위한 고민을 하기보다는 요구사항들을 잘 만족하기 위한 고민을 하는 것이 미션을 통한 성장에 훨씬 도움이 될 것이라고 생각하게 되었다. 그래서 리뷰어에게 PR을 날릴 때, 이번 미션을 진행할 때 한 고민들을 최대한 드러내고 매듭짓지 못한 의문들에 대한 의견을 묻고자 했다.\n자동차 미션을 진행할 때는\n\n- getter를 어디까지 지양해야 하는지?\n- 유효성 검증은 어느 영역에서 해야 하는게 좋을지?\n\n로또 미션을 진행할 때는\n\n- 뎁스를 줄이기 vs 뎁스를 포기하더라도 순수함수를 지양하기\n- 상속 vs 조합\n\n에 대한 의견을 물었다. 리뷰어의 답변들을 통해서 의문들을 어느정도 해결할 수 있어서 좋았다. 코드에 대한 리뷰를 받을 때도, 무조건적으로 리뷰어의 의견을 수용하기 보다 내 생각을 적극적으로 제시해 더 많은 의견을 통해 더 많은것을 얻고자 했다!\n\n![](./assets/week-1&2-3.png)\n\n확실히 리뷰에 대한 내 생각을 적극적으로 얘기하면서 리뷰어와 더 많은 대화를 할 수 있었고, 많은 것을 얻을 수 있었던 것 같다.\n앞으로 미션이 끝나고 리뷰를 요청할 때도 지금까지의 미션을 진행하면서 했던 것 처럼\n\n- 미션을 진행했을 때 했던 고민 드러내기\n- 매듭짓지 못한 의문이 있다면 적극적으로 질문하기\n\n이 2가지 자세로 리뷰를 요청해봐야겠다.\n\n## 5기분들과의 대화\n\n로또 미션을 진행하던 중, 5기 크루분들이 캠퍼스에 방문해 대화해볼 수 있는 기회가 생겼다. 여러 얘기들을 해주셨지만 공통적으로\n\n1. 미션에만 제대로 집중해도 얻을 수 있는 것들이 굉장히 많을 것\n2. 레벨 1이면, 자바스크립트만 깊게 학습해도 충분할 것\n\n위와 같은 말씀을 해주셨다. 추가로, 5기 크루 분들과 대화를 나누면서 이 때 까지 내가 객체지향 프로그래밍과 함수형 프로그래밍을 너무 이분법적으로 생각하고 있었음을 깨닫게 되었고, 레벨 1에서 객체라는 키워드가 많이 나오는 만큼 나도 객체에 대해서 제대로 알아보고자 `객체지향의 사실과 오해`를 읽고있다!\n\n## 뚝섬 러닝\n\n![](./assets/week-1&2-4.jpeg)\n\n올 해 목표 중 하나는 10KM 마라톤 대회에 참가하는 것이다. 연습을 하기 위해서 1주차는 8KM, 2주차는 10KM을 달렸다.(3주차 주말에도 달렸다) 내가 왜 달리기에 관심을 가지고 대회까지 준비하게 되었는지에 대한 이야기는 추후에 하고자 한다.\n"},{"excerpt":"서론 우테코 레벨1 콘솔 기반 로또 애플리케이션을 진행하면서, 로또와 당첨 로또의 유효성 검증 로직이 중복되는 부분이 많아 재사용하기 위해서 이미 구현된 로또 도메인에서 재사용하는 로직을 재사용해보기 위해서 상속이나 조합을 사용해볼 수 있었다. \"상속이나 조합을 사용해서 중복을 줄일 수 있다...? 그렇다면...\" 두 방식은 어떠한 차이점이 있을까? 왜 …","fields":{"slug":"inheritance-vs-composition"},"frontmatter":{"date":"February 25, 2024","title":"상속과 조합 차이 이해해 보기","tags":["Javascript","우아한테크코스"]},"rawMarkdownBody":"\n## 서론\n\n우테코 레벨1 콘솔 기반 로또 애플리케이션을 진행하면서, 로또와 당첨 로또의 유효성 검증 로직이 중복되는 부분이 많아 재사용하기 위해서 이미 구현된 로또 도메인에서 재사용하는 로직을 재사용해보기 위해서 상속이나 조합을 사용해볼 수 있었다.\n\n> \"상속이나 조합을 사용해서 중복을 줄일 수 있다...? 그렇다면...\"\n\n- 두 방식은 어떠한 차이점이 있을까?\n- 왜 LMS에서는 조합을 권장하는 것일까?\n\n의 두 가지 의문점이 생겼다. 이 글에서 의문점을 나름대로 해결하고 차이를 이해해 본 내용을 기록해본다. 😊\n\n## 상속\n\n로또 도메인에서 진행하는 유효성 검증은 다음과 같다.\n\n- 로또 번호는 1 ~ 45 사이의 숫자여야 한다.\n- 로또 번호는 6개의 숫자로 이루어진다.\n- 로또 번호는 중복이 있을 수 없다.\n\n이를 아래와 같이 코드로 표현해볼 수 있다.\n\n```js\nclass Lotto {\n  #numbers\n\n  constructor(numbers) {\n    Lotto.#validate(numbers)\n    this.#numbers = numbers\n  }\n\n  static #validate(numbers) {\n    Lotto.#validateNumbersType(numbers)\n    Lotto.#validateLength(numbers)\n    Lotto.#validateUniqueness(numbers)\n  }\n\n  static #validateNumbersType(numbers) {\n    // 로또 번호가 1 ~ 45 사이의 숫자들인지 판단한다.\n  }\n\n  static #validateLength(numbers) {\n    // 로또 번호가 6개의 숫자로 이루어져 있는지 판단한다.\n  }\n\n  static #validateUniqueness(numbers) {\n    // 로또 번호에 중복이 있는지 판단한다.\n  }\n  //...\n}\n```\n\n생성자 함수에서 멤버 변수에 외부에서 주입한 값을 할당해주기 전에 유효성 검증을 진행한다. 당첨 로또를 만들 때 진행하는 유효성 검증은 다음과 같다\n\n- 로또 번호는 1 ~ 45 사이의 숫자여야 한다.\n- 로또 번호는 6개의 숫자로 이루어진다.\n- 로또 번호는 중복이 있을 수 없다.\n- 보너스 번호는 로또 번호와 중복될 수 없다.\n\n4번 째 검증을 제외하면 로또 번호가 진행하는 유효성 검증과 중복된다. 상속을 통해서 중복을 줄여보자\n\n```js\nclass WinningLotto extends Lotto {\n  constructor(numbers, bonusNumber) {\n    super(numbers)\n    //...보너스 번호 유효성 검증\n  }\n}\n```\n\n구현된 로또 클래스를 상속 받은 당첨 로또는 인스턴스가 생성될 때, 외부에서 주입 받은 numbers에 대한 유효성 검증을 부모 클래스인 로또에서 진행하기 때문에 당첨 로또 클래스는 보너스 번호와의 중복을 확인하는 유효성 검증을 제외하면 중복을 줄일 수 있게 되었다. 중복을 줄였으니 이제 상속을 통해서 애플리케이션을 계속 만들어가면 되는 것일까? 잠시 멈추고 상속의 단점에 대해서도 한 번 생각해 보자.\n\n### 1. 부모 클래스와 너무 강한 결합도\n\n상속은 부모 클래스와 자식 클래스 사이의 너무 강한 결합도로 인해서 변경에 취약해진다는 단점이 있다. 예시를 들어보자,\n\n만약 리뷰어가\n\n> _꼭 배열로 외부에서 주입해줘야 하나요? Set을 사용해서 외부에서 주입하면 uniqueness에 대한 유효성 검증은 생략할 수 있을 것 같은데 한번 해보실래요~?_\n\n와 같은 내용의 리뷰를 해줬다고 가정해보자. 이제 피드백을 반영하기 위해서 코드를 수정해본다.\n\n```js\nclass Lotto {\n  #numbers;\n\n  constructor(numbers) {\n    Lotto.#validate(numbers);\n    this.#numbers = numbers;\n  }\n\n  static #validate(numbers) {\n    Lotto.#validateNumbersType(numbers);\n    Lotto.#validateLength(numbers);\n  }\n\n  static #validateNumbersType(numbers) {\n\t\t// 로또 번호가 1 ~ 45 사이의 숫자들인지 판단한다.\n  }\n\n  static #validateLength(numbers) {\n\t\t// 로또 번호가 6개의 숫자로 이루어져 있는지 판단한다.\n  }\n\n  static #validateUniqueness(numbers) {\n\t\t// 로또 번호에 중복이 있는지 판단한다.\n  }\n\n  //...\n}\n\nconst lotto = new Lotto(new Set([1,2,3,4,5,6)]\n```\n\n피드백 수용 과정에서 어떤 문제가 있었을까? 자식 클래스는 부모 클래스에 강하게 의존하고 있기 때문에 부모 클래스에 변경 사항이 있으면 자식 클래스도 그 변경을 반영하기 위한 변경이 불가피하다는 것이다.  \n지금은 생성자 함수에 변경 사항이 생긴 간단한 예시를 들었지만, 부모 클래스의 변경이 매우 많다면, 이에 비례해서 자식 클래스도 변경해야 한다는 문제점을 생각해볼 수 있다. 즉, **자식 클래스가 부모 클래스의 변경을 항상 바라보고 있기 때문에** 생긴 문제이다.\n\n### 2. 불필요한 메서드도 상속\n\n```js\nclass Vector {\n  add() {}\n}\n\nclass Stack extends Vector {\n  pop() {}\n\n  push() {}\n}\n\nconst stack = new Stack()\n\nstack.pop()\nstack.push()\nstack.add()\n```\n\n스택 클래스는 벡터 클래스를 상속받아 스택과 관련된 기능을 구현하고 있다. 이를 사용해서 생성된 인스턴스는 위의 코드와 같이 pop, push, add 메서드에 모두 접근이 가능하다.\n\n- 스택 클래스는 add 메서드가 필요한 것일까?\n- 구현에 있어서 필요하지 않은 메서드까지 같이 상속 받아버린것은 아닐까?\n- 해당 메서드를 잘못 호출해서 애플리케이션이 예상치 못한 동작을 할 수도 있지 않을까?\n\n구현에 필요하지 않은 메서드는 들고오지 않는다면, 위와 같은 문제들이 발생하지 않을 것 같은데 어떻게 해결해 볼 수 있을까?\n\n## 조합\n\n조합은\n\n- 전체를 표현하는 클래스에서 부분을 표현하는 객체를 포함해서 부분 객체의 동작을 재사용하는 것을 말한다.\n- 기존 클래스가 새로운 클래스의 부모가 되는 것이 아니라 새로운 클래스의 구성요소가 된다.\n- 새로운 클래스는 기존 클래스를 호출해서 생성된 인스턴스를 멤버변수로 가진다.\n\n위와 같은 특징을 가진다. 또, 기존 클래스에서 구현된 동작을 상속받는 것이 아닌 호출해서 사용하기 때문에(조합은 기존 클래스의 퍼블릭 메서드에 의존하기 때문에) 새로운 클래스를 통해서 생성될 인스턴스에 모든 동작(메서드)을 드러내지 않아 캡슐화를 깨뜨리지 않는다는 장점이 있다.\n기존 클래스의 동작 방식이 변경 되어도 영향을 덜 받는다. 즉, 상속에 비해서 변화에 민감하게 반응할 필요가 없다.\n조합을 사용해서 상속을 사용했을 때 확인할 수 있었던 문제들을 해결해보자.\n\n### 1. 부모 클래스와의 결합도 낮추기\n\n```js\nclass Lotto {\n  #numbers\n\n  constructor(numbers) {\n    Lotto.#validate(numbers)\n    this.#numbers = numbers\n  }\n\n  static #validate(numbers) {\n    Lotto.#validateNumbersType(numbers)\n    Lotto.#validateLength(numbers)\n  }\n\n  static #validateNumbersType(numbers) {\n    //...\n  }\n\n  static #validateLength(numbers) {\n    //...\n  }\n\n  has(number) {\n    return this.#numbers.includes(number)\n  }\n}\n```\n\n```js\nclass WinningLotto{\n  constructor(winningLotto, bonusNumber) {\n\tif(winningLotto.has(bonusNumber){\n\t\tthrow new Error(\"보너스 번호는 당첨 번호와 중복될 수 없습니다.\");\n\t}\n\t//...보너스 번호 유효성 검증\n  }\n}\n```\n\n당첨 로또 클래스는 이미 구현된 로또 클래스를 통해서 생성된 인스턴스를 멤버변수로 가지며 로또 클래스의 메서드를 사용해서 유효성 검증을 진행하고 있다. 조합을 사용하는 경우에 리뷰어의 피드백을 반영하기 위해서 배열을 집합으로 바꾸는 상황을 생각해보자. 과연 당첨 로또 클래스 내부에서 변화가 있을까? 없다.\n\n당첨 로또 클래스는 로또 클래스를 호출해서 생성된 인스턴스를 **생성자 함수를 통해서 주입받기 때문에, 배열을 통해서 생성되든 집합을 통해서 생성되든 신경쓸 필요가 없다.** 따라서, 로또 클래스의 생성자 함수에 변경이 발생해도 당첨 로또 클래스는 변경할 필요가 없어진다. 이로써 부모, 자식 클래스가 너무 강하게 묶여있어 변화에 유연하게 대응하지 못하는 문제를 조합을 통해서 어느정도 해결할 수 있게 되었다.\n\n### 2. 불필요한 메서드 드러내지 않기\n\n```js\nclass Stack {\n  #vector\n\n  constructor() {\n    this.#vector = new Vector()\n  }\n\n  pop() {}\n\n  push() {}\n}\n\nconst stack = new Stack()\n\nstack.pop()\nstack.push()\nstack.add() // error\n```\n\n스택 클래스는 벡터 클래스를 통해 생성된 인스턴스를 멤버 변수로 가지고 있다. 벡터 클래스의 모든 메서드를 드러내지 않아도 되기 때문에, 스택 클래스를 통해서 생성될 인스턴스에 add 동작이 필요하지 않다면 외부에 노출하지 않을 수 있다. 이로써, 인스턴스에서 필요로 하지 않는 동작까지 외부로 드러냈던 문제를 해결할 수 있게 되었다. (이미 구현된 동작에서 필요한 것만 뽑아 쓰자!)\n\n## 상속 쓰면 안되나요?\n\n지금까지 상속이 가진 문제를 조합이 어떻게 해결해볼 수 있는지에 대해 살펴봤다. 상속의 단점만 부각시킨 것 같은데, 그렇다면 상속은 아예 사용하지 말라는 것일까?\n\n상속은 의미상 관계가 있고 상하 관계가 분명한 객체를 나타내고 연결하기 위해서 고려해볼 수 있다. 또, 객체의 동작을 사용하는 입장에서 동일한 행동을 할 것임을 기대할 수 있을 때 고려해볼 수 있다.\n\n나 역시 프리코스와 이번 미션에서 모두 상속을 사용했었다.\n\n```js\nclass InvalidInputException extends Error {\n  constructor(error) {\n    super(`${ERROR_MESSAGES.prefix} ${error}`)\n  }\n}\n```\n\n콘솔에서 받는 입력이 유효하지 않다면 예외를 발생 시켜야 했는데, 그냥 Error 객체를 던지기 보다 어떤 상황에서 발생한 예외인지를 더 잘 표현하기 위해서 Error 클래스를 상속 받아서 InvalidInputException을 구현했다. 이는 둘 다 예외를 던진다는 의미상의 관계가 있으며 상하 관계도 분명하다고 볼 수 있다. 그리고, Error와 InvalidInputException 모두 예외를 던진다는 동일한 행동을 할 것임을 기대할 수 있다.\n\n![](./assets/error.png)\n\n또 다른 예시로, `IS-A` 관계일 경우에도 상속을 고려해볼 수 있다. IS-A 관계는 한마디로 **“자식클래스는 부모클래스이다”라고 말해도 이상하지 않은 관계**이다.\n\n```js\nclass Person {\n  talk() {\n    console.log(\"말하기\")\n  }\n\n  run() {\n    console.log(\"달리기\")\n  }\n}\n\nclass Student extends Person {}\n\nconst student = new Student()\n\nstudent.talk()\nstudent.run()\n```\n\n위 예시에서 Student 클래스는 Person 클래스를 상속받고 있다. “학생은 사람이다”라는 문장은 어색하지 않기에 상속을 고려해볼 수 있다.(상하 관계가 분명하다)\n\n## 결론\n\n상속과 조합의 차이에 대해서 알아보면서 LMS에서 왜 조합을 권장하는지에 대해 나름대로 정리해볼 수 있었다.(아, 이래서 조합을…!)\n\n상속을 사용하는 목적이 단순히 코드의 재사용이라면 다시 생각해봐야할 듯 하다.\n\n## 🔗 참고 링크\n\n- https://mangkyu.tistory.com/199\n- https://www.youtube.com/watch?v=U4OSS4jJ9ns&t=189s\n- https://tecoble.techcourse.co.kr/post/2020-05-18-inheritance-vs-composition/\n"},{"excerpt":"서론 현재 진행중인 프로젝트에서 정보를 보여줄 때, 토글 기능을 사용해서 보여주는 경우가 2가지가 있었다. 지도 페이지에서 건물 정보를 보여주는 경우 FAQ 페이지에서 질문에 대한 응답을 보여주는 경우 \n 이 2가지 경우에 대해서 각각 독립된 다른 컴포넌트를 만들기 보다 재활용 할 수 있는 컴포넌트를 만들 수 있는 방법에 대해서 고민하다  패턴을 적용해 …","fields":{"slug":"react-use-render-props"},"frontmatter":{"date":"February 06, 2024","title":"[React] render-props 사용해보기","tags":["React","부림이"]},"rawMarkdownBody":"\n## 서론\n\n현재 진행중인 프로젝트에서 정보를 보여줄 때, 토글 기능을 사용해서 보여주는 경우가 2가지가 있었다.\n\n- 지도 페이지에서 건물 정보를 보여주는 경우\n- FAQ 페이지에서 질문에 대한 응답을 보여주는 경우\n\n![](./assets/building-info.png)\n![](./assets/faq-info.png)\n\n이 2가지 경우에 대해서 각각 독립된 다른 컴포넌트를 만들기 보다 **재활용 할 수 있는 컴포넌트를 만들 수 있는 방법에 대해서 고민**하다 `render-props` 패턴을 적용해 보기로 했다. 리액트의 특별한 props인 `children` props를 사용해도 되지만, 다양한 패턴들을 경험해 보고자 적용해 보기로 했다!\n\n## render-props?\n\nrender-props는 리액트에서 사용되는 패턴 중 하나로, 부모 컴포넌트에서 자식 컴포넌트로 props를 넘겨 줄 때 JSX를 반환하는 함수를 props로 넘겨주는 패턴을 말한다. props를 받는 컴포넌트에서는 호출함으로써 렌더링한다. 패턴의 이름이 render-props일 뿐이지 props의 이름이 꼭 render여야 할 필요는 없다.\n\n```jsx\n;<Title render={() => <h1>I am a render prop!</h1>} />\n\nconst Title = props => props.render()\n```\n\nrender-props는 props를 받는 컴포넌트를 재사용하기 좋다는 장점을 가진다. 위의 Title 컴포넌트는 단순히 전달 받은 함수를 호출함으로써 렌더링 하지만, Title 컴포넌트 내부에서 가진 상태 또는 데이터를 인자로 전달하는 것도 가능하다.\n\n```tsx\nfunction Title(props) {\n  const someData = { ... }\n\n  return props.render(someData)\n}\n```\n\n## 활용하기\n\n위 서론에서, 토글 기능을 통해서 정보를 보여주는 재사용할 수 있는 컴포넌트를 만들고자 했다. 이미지에서도 확인할 수 있듯이 두 UI는 모두 다르다. 이 때, render-props를 활용해서 스타일이 정해진 JSX를 반환하는 함수를 주입하고 컴포넌트를 유연하게 재사용해볼 수 있다.\n\n### ToggleInfo\n\n```tsx\ninterface ToggleInfoProps {\n  infoTitle: () => JSX.Element\n  infoDesc: () => JSX.Element\n}\n\nconst ToggleInfo = ({ infoTitle, infoDesc }: ToggleInfoProps) => {\n  const [showInfo, setShowInfo] = useState<boolean>(false)\n  const toggleInfo = () => setShowInfo(prevState => !prevState)\n\n  return (\n    <>\n      <ToggleContainer showInfo={showInfo} onClick={toggleInfo}>\n        {infoTitle()}\n        <IconContainer>\n          <Icon kind=\"arrowDown\" size=\"24\" />\n        </IconContainer>\n      </ToggleContainer>\n      {showInfo && infoDesc()}\n    </>\n  )\n}\n```\n\nToggleInfo 컴포넌트는 JSX를 반환하는 2개의 함수를 props로 받아서 showInfo 상태일 때만 infoDesc 함수를 호출한다. infoDesc 함수를 호출할지 말지에 대한 여부는 ToggleInfo 컴포넌트의 내부 상태인 showInfo에 의해서 결정된다. Title 컴포넌트 예시에서 컴포넌트 내부의 상태나 데이터를 전달해서 호출하는 것도 가능하다고 했었는데 ToggleInfo의 경우 showInfo 상태를 통해서 조건부 렌더링에 활용하고 있다.\n\n### 지도 페이지에 사용하기\n\n```tsx\n<ToggleInfo\n  infoTitle={() => (\n    <FloorText>\n      {formatFloorTitle(floorType as Floor, floor)}\n    </FloorText>\n  )}\n  infoDesc={() => (\n    <RoomInfoContainer key={index}>\n      {(infoContent[floor] as Room[]).map(\n        ({ roomNumber, roomName }, dataIndex) => (\n          <RoomInfo key={dataIndex}>\n            <RoomNumber>{roomNumber}</RoomNumber>\n            <Seperator />\n            <RoomName>{roomName}</RoomName>\n          </RoomInfo>\n        ),\n      )}\n    </RoomInfoContainer>\n)}\n```\n\n지도 페이지에서는 건물의 층을 클릭하면 각 층에 있는 강의실 정보를 보여준다. 이 때, 스타일이 결정 된 JSX를 반환하는 함수를 컴포넌트를 호출부에서 주입한다.\n\n### FAQ 페이지에 사용하기\n\n```tsx\n<ToggleInfo\n  infoTitle={() => (\n    <>\n      <span\n        css={css`\n          font-weight: bold;\n        `}\n      >\n        {FAQ_CONSTANTS.QUESTION_MARK}\n      </span>\n      <QuestionText>{question}</QuestionText>\n    </>\n  )}\n  infoDesc={() => (\n    <AnswerContainer>\n      {answer.text}\n      {hasLink && (\n        <StyledLink onClick={moveToLink}>{FAQ_CONSTANTS.LINK}</StyledLink>\n      )}\n    </AnswerContainer>\n  )}\n/>\n```\n\nFAQ 페이지에서는 사용자들이 자주 할법한 질문을 클릭하면 해당 질문에 대한 답을 보여준다.\n\n## 사용 후기\n\n### 1. 관심사의 분리\n\nToggleInfo 컴포넌트 내부에서는 showInfo의 상태만 관리하고 상태에 따라서 조건부 렌더링에 대한 책임만 가진다. 반면, 호출부에서는 ToggleInfo 내부에서 어떤 상태가 있고 해당 상태를 어떻게 관리하는지에 대해서 알 필요 없이 UI 2개만 넘겨주면 된다.\n\n### 2. 유연한 스타일 적용\n\n지도 페이지, FAQ 페이지에서 사용하는 UI가 달랐다.\n\n```tsx\nconst InfoInMap = ({ infoTitle, infoDesc }: ToggleInfoProps) => {\n  const [showInfo, setShowInfo] = useState<boolean>(false);\n  const toggleInfo = () => setShowInfo((prevState) => !prevState);\n\n  return (\n    <>\n      <ToggleContainer showInfo={showInfo} onClick={toggleInfo}>\n        // styled title UI in map\n        <IconContainer>\n          <Icon kind=\"arrowDown\" size=\"24\" />\n        </IconContainer>\n      </ToggleContainer>\n      {showInfo && // styled desc UI in map}\n    </>\n  );\n};\n```\n\n```tsx\nconst InfoInFAQ = ({ infoTitle, infoDesc }: ToggleInfoProps) => {\n  const [showInfo, setShowInfo] = useState<boolean>(false);\n  const toggleInfo = () => setShowInfo((prevState) => !prevState);\n\n  return (\n    <>\n      <ToggleContainer showInfo={showInfo} onClick={toggleInfo}>\n        // styled title UI in FAQ\n        <IconContainer>\n          <Icon kind=\"arrowDown\" size=\"24\" />\n        </IconContainer>\n      </ToggleContainer>\n      {showInfo && // styled desc UI in FAQ}\n    </>\n  );\n};\n\n```\n\n위와 같이 2개의 컴포넌트를 만들고 각 페이지에서 해당 컴포넌트를 호출해서 사용할 수 있겠지만, 두 컴포넌트 모두\n\n- 정보를 보여줄지 말지 결정하는 상태(showInfo)\n- 정보를 보여주는 상태일 때 화살표 애니메이션\n\n이 두 부분이 동일하기 때문에 충분히 재사용할 수 있게 만들어볼 수 있었고 render-props를 활용해서 유연하게 스타일을 적용해볼 수 있었다.\n\n### 깊어지는 depth\n\n```tsx\n<ToggleInfo\n  infoTitle={() => (\n    <FloorText>\n      {formatFloorTitle(floorType as Floor, floor)}\n    </FloorText>\n  )}\n  infoDesc={() => (\n    <RoomInfoContainer key={index}>\n      {(infoContent[floor] as Room[]).map(\n        ({ roomNumber, roomName }, dataIndex) => (\n          <RoomInfo key={dataIndex}>\n            <RoomNumber>{roomNumber}</RoomNumber>\n            <Seperator />\n            <RoomName>{roomName}</RoomName>\n          </RoomInfo>\n        ),\n      )}\n    </RoomInfoContainer>\n)};\n```\n\n지도 페이지에서 사용한 부분에서 느낄 수 있겠지만, JSX를 반환하는 함수를 props로 전달할 때 해당 JSX가 복잡한 UI를 다루고 있다면 위 처럼 코드의 depth가 굉장히 깊어져 가독성이 떨어진다는 느낌도 받았다.\n"},{"excerpt":"서론  현재 프로젝트에서 카카오 지도 API를 활용해서 학교 지도 페이지를 구현 하고 있고, 지도 위 건물 번호(카카오 지도가 제공하는 커스텀 오버레이)를 클릭하면 해당 건물에 대한 정보를 보여주는 컴포넌트를 추가로 구현 중에 있었다. 커스텀 오버레이에  이벤트 프로퍼티를 추가해줘도 되지만, 지도 위 건물 번호의 렌더링 로직을 클래스로 구현 했고, 해당 …","fields":{"slug":"react-useeffect-dependencies"},"frontmatter":{"date":"January 28, 2024","title":"[React] 실수 기록 - useEffect의 의존성 배열 잘 활용하기","tags":["React","부림이"]},"rawMarkdownBody":"\n## 서론\n\n![](./assets/pknu-map.png)\n\n현재 프로젝트에서 카카오 지도 API를 활용해서 학교 지도 페이지를 구현 하고 있고, 지도 위 건물 번호(카카오 지도가 제공하는 커스텀 오버레이)를 클릭하면 해당 건물에 대한 정보를 보여주는 컴포넌트를 추가로 구현 중에 있었다. 커스텀 오버레이에 `onClick` 이벤트 프로퍼티를 추가해줘도 되지만,\n\n```tsx\ninterface ICustomOverlay {\n  handleOverlays(buildingTypes: Record<BuildingType, boolean>, map: any): void;\n  addOverlay(\n    buildingType: BuildingType,\n    building: PKNUBuilding,\n    map: any,\n  ): void;\n}\n\nclass CustomOverlay implements ICustomOverlay {\n  private overlays: Record<BuildingType, any[]>;\n\n  constructor() {\n    this.overlays = {\n      A: [],\n      B: [],\n      C: [],\n      D: [],\n      E: [],\n    };\n  }\n\n  private createOverlayContent(\n    activeColor: CSSProperties['color'],\n    building: PKNUBuilding,\n  ) {\n    const content = document.createElement('span') as HTMLSpanElement;\n\n    //...add style\n\n    const buildingNumberText = document.createTextNode(building.buildingNumber);\n    content.appendChild(buildingNumberText);\n    content.onclick = () => //... mount building info component\n\n    return content;\n  }\n\n  //...\n```\n\n지도 위 건물 번호의 렌더링 로직을 클래스로 구현 했고, 해당 클래스에 리액트 상태 훅인 `useState` 훅을 주입해서 구현하는 것 보다 document에 클릭 이벤트를 추가해서 어떤 건물 번호를 클릭했는지 알아내는 것이 더 낫다고 생각해 해당 방법으로 구현하기로 했다.\n\n## 문제\n\n```tsx\nconst BuildingInfoToggle = () => {\n  const [buildingNumber, setBuildingNumber] = useState<string>(\"\")\n\n  const unmountInfo = () => setBuildingNumber(\"\")\n  const isInfoMounted = buildingNumber !== \"\"\n\n  useEffect(() => {\n    const getNumber = (e: MouseEvent | TouchEvent) => {\n      console.log(\"building number : \", buildingNumber) // always empty string\n      if (!(e.target instanceof HTMLSpanElement) || isInfoMounted) return\n\n      setBuildingNumber(e.target.innerText)\n    }\n\n    document.addEventListener(eventType, getNumber)\n    // eventType : 'touchstart' or 'click'\n\n    return () => {\n      document.removeEventListener(eventType, getNumber)\n    }\n  }, [])\n\n  return isInfoMounted ? (\n    <BuildingInfo buildingNumber={buildingNumber} unmountInfo={unmountInfo} />\n  ) : null\n}\n```\n\n위 로직은, document에 클릭 이벤트가 발생할 때마다 지도 위 건물 번호를 클릭한 것인지 확인하고 만약 그렇다면 `setBuildingNumber`를 호출해서 상태를 변경한다. 그리고 건물 정보 컴포넌트가 렌더링 될 때 해당 컴포넌트에서 span을 사용하는 JSX가 있는 경우 `buildingNumber`의 상태가 변경되면 안되므로 `isInfoMounted` 불리언 변수를 사용해 이미 건물 정보 컴포넌트가 렌더링 된 상태라면 `setBuildingNumber`를 호출하지 않도록 early return 패턴을 적용했다.\n\n하지만, 건물 정보 컴포넌트 위의 **span을 클릭할 때 buildingNumber의 상태가 계속해서 변경되는 문제가 발생했다.** 즉, 적용하려고 했던 early return 패턴이 적용되지 않은 것이다.\n\n## 원인 파악\n\n리액트의 useEffect 훅은 의존성 배열이 비어있다면 해당 컴포넌트가 렌더링 될 때 한번만 실행되며 상태 변화로 인해 컴포넌트가 재호출 되어 리렌더링 되더라도 다시 실행되지 않는다. 만약, 의존성 배열에 어떠한 요소가 있다면 해당 요소가 변할 때마다 useEffect 훅의 첫 번째 인자인 콜백 함수가 실행되며 해당 콜백 함수가 실행되기 전\n\n```js\nreturn () => {}\n```\n\n해당 함수가 실행된다.\n\n이 내용에 대해서 알고 있었지만, 막상 개발을 진행 할 때는 의존성 배열이 비어 있어도 `buildingNumber`의 상태가 변하면 `getNumber` 함수 내부에서 변경된 상태를 참조할 수 있을 것이라고 생각했다.\n\n자바스크립트에서 함수가 선언될 때, 주위의 환경을 기억한다. 실행되기 전 평가될 때의 렉시컬 환경을 기억한다.\n\n```tsx\nconst BuildingInfoToggle = () => {\n  const [buildingNumber, setBuildingNumber] = useState<string>(\"\")\n\n  useEffect(() => {\n    const getNumber = (e: MouseEvent | TouchEvent) => {\n      console.log(\"building number : \", buildingNumber) // always empty string\n      if (!(e.target instanceof HTMLSpanElement) || isInfoMounted) return\n\n      setBuildingNumber(e.target.innerText)\n    }\n\n    //...\n  }, [])\n\n  //...\n}\n```\n\n`BuildingInfoToggle` 컴포넌트가 제일 처음 렌더링 될 때, `buildingNumber`의 메모리 주소가 만약 100이라면 `getNumber` 함수 내부에서 참조하고 있는 `buildingNumber`의 메모리 주소도 100이 된다. 지도 위 건물 번호를 클릭해 상태가 변경되면 불변성을 유지하기 위해 메모리 주소도 변경 된다.\n\n하지만, useEffect의 첫 번째 콜백 함수는 의존성 배열이 비어있어 다시 실행되지 않고 따라서 getNumber 함수도 다시 선언되지 않아 메모리 주소가 100인 즉, 빈 문자열인 buildingNumber을 계속해서 참조하게 된다. **따라서 isInfoMounted는 항상 false가 되어 early return 패턴이 적용되지 않았던 것이다.**\n\n그렇다면 useEffect 훅 밖에 getNumber 함수를 선언하면 상태가 변할 때마다 함수를 다시 선언하니 변경된 메모리 주소를 참조해서 문제를 해결할 수 있지 않을까? 라는 생각을 했었다.\n즉,\n\n```tsx\nconst BuildingInfoToggle = () => {\n  const [buildingNumber, setBuildingNumber] = useState<string>(\"\")\n\n  const getNumber = (e: MouseEvent | TouchEvent) => {\n    if (!(e.target instanceof HTMLSpanElement) || isInfoMounted) return\n\n    setBuildingNumber(e.target.innerText)\n  }\n\n  useEffect(() => {\n    document.addEventListener(eventType, getNumber)\n\n    return () => {\n      document.removeEventListener(eventType, getNumber)\n    }\n  }, [buildingNumber])\n\n  //...\n}\n```\n\n위와 같이 밖에 선언하면 변경된 상태를 참조할 수 있을 것이라 생각 했지만, useEffect훅의 첫 번째 콜백 함수 자체가 다시 실행되지 않기 때문에 컴포넌트가 제일 처음 렌더링 됐을 때의 getNumber 함수를 호출하고 해당 함수 내부에서는 buildingNumber 의 상태가 항상 빈 문자열이기 때문에 문제를 해결할 수 없었다.\n\n## 해결\n\n이 문제를 해결하기 위해서 **의존성 배열에 buildingNumber 를 추가**해줘야 했다.\n\n```tsx\nconst BuildingInfoToggle = () => {\n  const [buildingNumber, setBuildingNumber] = useState<string>(\"\")\n\n  useEffect(() => {\n    const getNumber = (e: MouseEvent | TouchEvent) => {\n      if (!(e.target instanceof HTMLSpanElement) || isInfoMounted) return\n\n      setBuildingNumber(e.target.innerText)\n    }\n\n    document.addEventListener(eventType, getNumber)\n\n    return () => {\n      document.removeEventListener(eventType, getNumber)\n    }\n  }, [buildingNumber])\n\n  //...\n}\n```\n\n이제 **buildingNumber가 변경될 때마다 useEffect의 콜백 함수가 다시 실행되어 변경된 메모리 주소를 제대로 참조**할 수 있게 되었고 따라서, early return 패턴도 잘 적용되어 건물 정보 컴포넌트가 렌더링 될 때 예상치 못하게 상태가 변경되는 문제를 해결할 수 있게 되었다. 😊\n"},{"excerpt":"서론  위 이미지처럼 탭 버튼이 있고 탭에 해당되는 내용을 보여주는 기능을 구현하려고 할 때, Tabs 컴포넌트를 만들 수 있을 것이다. 만약, 만들고 있는 프로덕션의 규모가 커 여러 페이지에서 탭이 필요한 경우 Tabs 컴포넌트를 재사용하기 위해서 buttons : 탭 버튼들 children : 클릭한 탭 버튼에 따라서 보여져야하는 내용들 이 2가지를 …","fields":{"slug":"react-jsx-intrinsic-elements"},"frontmatter":{"date":"January 14, 2024","title":"[React] JSX.intrinsicElements","tags":["React"]},"rawMarkdownBody":"\n## 서론\n\n![](./assets/tabs.png)\n\n위 이미지처럼 탭 버튼이 있고 탭에 해당되는 내용을 보여주는 기능을 구현하려고 할 때, Tabs 컴포넌트를 만들 수 있을 것이다. 만약, 만들고 있는 프로덕션의 규모가 커 여러 페이지에서 탭이 필요한 경우 Tabs 컴포넌트를 재사용하기 위해서\n\n```tsx\ninterface TabsProps {\n  children: React.ReactNode\n  buttons: JSX.Element\n}\n\nconst Tabs = ({ children, buttons }: TabsProps) => {\n  return (\n    <>\n      <div>{buttons}</div>\n      {children}\n    </>\n  )\n}\n```\n\n- buttons : 탭 버튼들\n- children : 클릭한 탭 버튼에 따라서 보여져야하는 내용들\n\n이 2가지를 props로 넘겨줄 수 있을 것이다.\nbuttons의 타입은 JSX.Element이기 때문에 Tabs 컴포넌트를 호출할 때마다 여러 페이지에서 스타일이 다른 버튼들을 props로 넘겨줄 수 있을 것이다. 각 버튼들의 스타일은 유연하게 정할 수 있지만 버튼들을 감싸는 부모 태그는 현재 div로 고정되어 있기 때문에 스타일을 유연하게 정할 수 없다. 예를 들어,\n\n- a 페이지 : 버튼들의 방향flex-direction : row\n- b 페이지 : 버튼들의 방향flex-direction : column\n\n일 경우 Tabs 컴포넌트를 재사용하기 힘들 것이다. 이를 해결하기 위해서 버튼들을 감싸는 부모도 함께 props로 넘겨줄 수 있다. 버튼들을 감싸는 부모는 JSX가 되거나 children props를 받는 리액트 컴포넌트가 된다. JSX인 경우\n\n```tsx\nReact.createElement('div',,,)\n```\n\n이런 식으로 변환되기 때문에\n\n```tsx\ninterface TabsProps {\n  children: React.ReactNode\n  buttons: JSX.Element\n  ButtonContainer: string | React.FunctionComponent\n}\n\nconst Tabs = ({ children, buttons, ButtonContainer }: TabsProps) => {\n  return (\n    <>\n      <ButtonContainer>{buttons}</ButtonContainer>\n      {children}\n    </>\n  )\n}\n```\n\n`ButtonContainer`의 타입을string으로 지정했다 하지만,\n\n```text\nType '{ children: Element; }' has no properties in common with type 'IntrinsicAttributes'.\n```\n\n위 에러를 확인할 수 있었는데, 현재 사용하려고 하는 컴포넌트에는 컴포넌트를 호출할 때 전달해야 하는 기본 속성인 IntrinsicAttribute가 존재하지 않기 때문이다. 리액트 컴포넌트에는 기본적인 내장 속성 IntrinsicAttribute가 존재하는데 이 속성에 컴포넌트를 호출할 때 기본적으로 전달해야하는 속성(onClick, onChange, style,,,)들이 정의되어 있다. 하지만 현재 사용하려고 하는 컴포넌트에는 이러한 기본 속성이 없다는 것을 의미하며, string으로 JSX의 타입을 지정하려고 했기 때문에 생긴 문제임을 파악할 수 있었다.\n\n## JSX.intrinsicElement\n\n타입스크립트 공식문서에서는 JSX.intrinsicElement 다음과 같이 설명하고 있다.\n\n> _Intrinsic elements are looked up on the special interface JSX.IntrinsicElements. By default, if this interface is not specified, then anything goes and intrinsic elements will not be type checked. However, if this interface is present, then the name of the intrinsic element is looked up as a property on the JSX.IntrinsicElements interface._\n\n즉, 타입스크립트에서 유효한 JSX인지 타입 체크를 하기 위해서 사용하는 타입이며\n\n```ts\ninterface IntrinsicElements {\n  //HTML\n\ta: React.DetailedHTMLProps<React.AnchorHTMLAttributes<HTMLAnchorElement>, HTMLAnchorElement>;\n\tabbr: React.DetailedHTMLProps<React.HTMLAttributes<HTMLElement>, HTMLElement>;\n  //...\n```\n\n유효한 html 태그인지 확인하기 위한 타입이다. 유요한 intrinsicElement만 기본 내장 속성인 intrinsicAttribute을 가질 수 있다.\n\n```ts\ndeclare namespace JSX {\n  interface IntrinsicElements {\n    foo: any\n  }\n}\n;<foo /> // ok\n;<bar /> // error\n```\n\n## JSX.IntrinsicElement vs React.FunctionComponent\n\nJSX 요소와 리액트 함수형 컴포넌트는 다음과 같은 차이가 있다.\n\n### React.createElement 호출\n\n```tsx\nReact.createElement(\"div\",,,)\nReact.createElement(Component)\n```\n\nJSX를 전달하는 경우에는 유요한 html 태그 문자열을 전달하며, 함수형 컴포넌트를 전달하는 경우 참조할 수 있는 값으로 전달된다.\n\n### attribute vs props\n\nJSX 요소는 기본 내장 속성 intrinsicAttribute를 전달받으며, 함수형 컴포넌트는 props를 전달받는다.\n\n```tsx\n;<div onClick={doSomething} />\n\ninterface ComponentProps {\n  onClick: () => void\n}\n\nconst Component = ({ onClick }) => {\n  return <div onClick={onClick} />\n}\n\n;<Component onClick={doSomething} />\n```\n\n만약 한 컴포넌트가 받는 props가 많은 경우, 해당 props가 컴포넌트가 반환하는 JSX 더미 중 어디에서 사용되는지를 수동으로 설정해줘야 한다.\n\n## 해결\n\n```tsx\ninterface TabsProps {\n  children: React.ReactNode\n  buttons: JSX.Element\n  ButtonContainer: keyof JSX.IntrinsicElements | React.FunctionComponent\n}\n\nconst Tabs = ({ children, buttons, ButtonContainer }: TabsProps) => {\n  return (\n    <>\n      <ButtonContainer>{buttons}</ButtonContainer>\n      {children}\n    </>\n  )\n}\n```\n\n`keyof` 연산자를 사용해서 유효한 JSX.intrinsicElement 중 하나임을 설정했다. 컴포넌트를 호출할 때,\n\n```tsx\n<Tabs\n  ButtonContainer=\"abc\"\n  //...\n/>\n```\n\n위 처럼 유효하지 않은 JSX를 전달하려고 하면,\n\n```text\nType '\"abc\"' is not assignable to type 'keyof IntrinsicElements | FunctionComponent<{}>'.\n```\n\n위 에러가 발생한다.\n"},{"excerpt":"서론 프로젝트를 진행 하면서 공지사항을 보여주는 컴포넌트를 구현하는 작업을 맡았다. 공지사항은 다시 일반, 고정 공지사항으로 나눠서 보여줘야 해서 url을 통해서 보여 줄 공지사항을 구분하기로 했다. 일반 :  고정 :  그리고 리액트의 Suspense를 활용해서 공지사항을 가져올 때 까지 Skeleton을 보여주는 방식으로 구현했다. 여기서, norma…","fields":{"slug":"react-usememo"},"frontmatter":{"date":"November 18, 2023","title":"[React] useMemo는 정말 최적화에 도움이 될까?","tags":["React","부림이"]},"rawMarkdownBody":"\n## 서론\n\n```tsx\nconst AnnounceContainer = ({\ntitle,\ncategory,\nendPoint,\n}: AnnounceContainerProps) => {\n  const { type } = useParams();\n  if (!type) return <></>;\n\n  const { routerTo } = useRouter();\n\n  const showNormalAnnouncement = () => routerTo(PATH.NORMAL_ANNOUNCEMENT(category));\n  const showPinnedAnnouncement = () => routerTo(PATH.PINNED_ANNOUNCEMENT(category));\n\n  const resource = fetchAnnounceList<AnnounceItemList>(endPoint)\n\n  return (\n  //...\n  <Suspense fallback={<AnnounceCardSkeleton length={30} />}>\n    <AnnounceList resource={resource} type={type as AnnouncementType} />\n  </Suspense>\n  //...\n)\n```\n\n프로젝트를 진행 하면서 공지사항을 보여주는 컴포넌트를 구현하는 작업을 맡았다. 공지사항은 다시 일반, 고정 공지사항으로 나눠서 보여줘야 해서 url을 통해서 보여 줄 공지사항을 구분하기로 했다.\n\n- 일반 : `announcement/school/normal`\n- 고정 : `announcement/school/pinned`\n\n그리고 리액트의 Suspense를 활용해서 공지사항을 가져올 때 까지 Skeleton을 보여주는 방식으로 구현했다. 여기서, normal, pinned가 변경될 때마다 AnnounceContainer 컴포넌트가 리렌더링 되었으며 따라서 공지사항 데이터를 가져오기 위한 api 호출도 매번 발생했다. (`React-Query` 라이브러리를 활용하지 않기에 별도의 캐싱 기능을 활용할 수 없는 상황이었다.)  \n공지사항 페이지를 처음 방문할 때 데이터를 한번만 가져오면 되는데 url이 변경될 때마다 똑같은 데이터를 가져오기 위해서 불필요한 api 호출을 할 필요는 없다고 생각했다.  \nuseEffect, useState 훅을 사용해서 해결할 수 있지만 이 방법은 제일 처음 공지사항 페이지를 방문할 때 컴포넌트가 두 번 렌더링 되며, 클라이언트와 서버의 상태를 분리하기 위해서 Suspense를 사용한 것이므로 useState를 사용하면 Suspense를 사용한 의미가 없어진다고 판단했다.  \n따라서, 이번에는 의존성 배열의 원소가 변경되지 않는 한 함수의 계산 결과를 캐싱하는 useMemo 훅을 사용해서 api 호출 결과를 캐싱해보기로 했다.\n\n```tsx\nconst resource = useMemo(\n  () => fetchAnnounceList<AnnounceItemList>(endPoint),\n  []\n)\n```\n\n이제 일반, 공지사항으로 url이 변경될 때마다 불필요한 api 호출이 발생하지 않았다.\nuseMemo훅은 성능 최적화를 위해서 주로 사용된다고 하는데, 과연 정말 최적화에 도움이 되는 훅인지에 대해서 궁금해졌다. 지금까지 프로젝트를 진행하면서 useMemo를 처음 써봤는데, 써본김에 궁금증을 해결해보기로 했다.\n\n## 리액트가 제공하는 훅 : useMemo\n\n```tsx\nconst cachedValue = useMemo(calculateValue, dependencies)\n```\n\n컴포넌트가 리렌더링 될 때, dependencies의 값이 변하지 않으면 이전 계산 결과 calculateValue를 재사용할 수 있는 리액트 훅이다.\n\n### useMemo 훅이 유용한 경우\n\n1. useMemo의 계산이 눈에띄게 느리면서 의존성 배열이 거의 변하지 않아 캐싱의 장점이 최대한 드러나는 경우\n\n내가 useMemo훅을 적용한 이유이다.\n서버에서 데이터를 가져오는 것이기 때문에 서버의 상태와 사용자 네트워크 환경 상태에 따라서 계산이 느려질 가능성이 충분히 있고, 공지사항 페이지에 처음 방문했을 때 데이터를 가져오면 되기 때문에 캐싱의 장점을 최대한 살릴 수 있을 것이라 판단했다.\n\n2. React.memo로 감싼 컴포넌트에 prop으로 전달하는 경우.\n\n```tsx\nconst ParentComponent = () => {\n  const [count, setCount] = useState<number>(0)\n  const addCount = () => setCount(prevCount => prevCount + 1)\n\n  const objExample = {\n    name: \"woong\",\n    age: 25,\n  }\n\n  return (\n    <>\n      <ChildComponent name={objExample.name} age={objExample.age} />\n      <button onClick={addCount}>ParentComponent Rerender</button>\n    </>\n  )\n}\n```\n\n```tsx\nconst ChildComponent = ({ name, age }: Props) => {\n  console.log(\"ChildComponent rerendered\")\n  return (\n    <div>\n      <h1>{name}</h1>\n      <h1>{age}</h1>\n    </div>\n  )\n}\n\nexport default React.memo(ChildComponent)\n```\n\n리액트는 기본적으로 컴포넌트가 리렌더링 되면 해당 컴포넌트의 모든 자식 컴포넌트들을 재귀적으로 리렌더링 한다. 하지만, 자식 컴포넌트의 리렌더링 비용이 큰 경우에 React.memo를 활용해서 이전 렌더링의 props와 비교해 변경되지 않는다면 리렌더링을 건너뛸 수 있다.  \nReact.memo는 이전 렌더링의 props와 비교할 때 얕은 비교로 비교한다.\n\n```js\nconst oldProps = {\n  a: \"1\",\n  b: \"2\",\n}\n\nconst newProps = {\n  a: \"1\",\n  b: \"2\",\n}\n\nObject.keys(oldProps).forEach(key => {\n  console.log(Object.is(oldProps[key], newProps[key])) // all true\n})\n```\n\n자바스크립트에서 객체를 비교할 때는 메모리 참조값을 통해서 비교하므로 oldProps, newProps는 다른 객체이다. 이 방법으로 비교하면 React.memo를 활용해도 항상 자식 컴포넌트는 리렌더링 되기 때문에 최적화가 전혀 되지 않는다. 따라서, 얕은 비교를 통해 객체 키의 값(원시 값)들이 같은지 비교한다.\n\n3. 자식 컴포넌트에서 props를 useEffect와 같은 훅의 의존성 배열에 활용하는 경우\n\nuseEffect는 의존성 배열의 한 원소라도 변경되면 첫 번째 인자인 콜백 함수를 다시 실행한다. 만약 콜백 함수의 실행이 불필요한 과정이라면 부모 컴포넌트에서 useMemo를 사용해서 props를 전달할 수 있다.\n\n## 정말 최적화에 도움이 되는가?\n\n궁금증을 해결하기 위해서 useMemo를 사용하는 컴포넌트와 그렇지 않은 컴포넌트를 비교해보기로 했다. 비교는\n\n- 제일 첫 번째 렌더링이 얼마나 걸리는가?\n- 리렌더링 얼마나 걸리는가?\n\n이 2가지를 통해서 진행 했다.\n\n### Normal\n\n```tsx\nconst Normal = ({ level, count }: Props) => {\n  const obj = {\n    values: [] as Record<string, string>[],\n  }\n\n  for (let i = 0; i <= level; i++) {\n    obj.values.push({ test: \"test\" })\n  }\n\n  return <div>Benchmark level: {level}</div>\n}\n```\n\nprops로 전달되는 level만큼 for문을 돈 후, JSX를 리턴한다.\n\n### Memo\n\n```tsx\nconst Memo = ({ level, count }: Props) => {\n  const obj = useMemo(() => {\n    const result = {\n      values: [] as Record<string, string>[],\n    }\n\n    for (let i = 0; i <= level; i++) {\n      result.values.push({ test: \"mytest\" })\n    }\n    return result\n  }, [level])\n\n  return <div>Benchmark with memo level: {level}</div>\n}\n```\n\n1. props로 전달되는 level만큼 for문을 돈 후, JSX를 리턴한다.\n2. useMemo를 사용해서 for문의 결과를 캐싱한다.\n\n### Test\n\n```tsx\nconst Test = () => {\n  const [count, setCount] = useState<number>(0)\n\n  const timesToRender = 10000\n  const renderTimes: number[] = []\n\n  const calculateAvgTime = () => {\n    const totalTime = renderTimes.reduce((acc, cur) => acc + cur, 0)\n    return totalTime / timesToRender\n  }\n  const logAvgTime = () => {\n    const totalTime = calculateAvgTime()\n    console.log(totalTime)\n  }\n\n  const renderProfiler: ProfilerOnRenderCallback = (\n    id: string,\n    phase: \"mount\" | \"update\",\n    actualDuration: number\n  ) => {\n    const renderTime = actualDuration\n    renderTimes.push(renderTime)\n  }\n\n  return (\n    <p>\n      <button onClick={logAvgTime}>show avg Time</button>\n      <button onClick={() => setCount(count => count + 1)}>rerender</button>\n      {[...Array(timesToRender)].map((_, index) => {\n        return (\n          <Profiler\n            id={`normal-${index}`}\n            key={`normal-${index}`}\n            onRender={renderProfiler}\n          >\n            <Normal level={1000} count={count} />\n            <Memo level={1000} count={count} />\n          </Profiler>\n        )\n      })}\n    </p>\n  )\n}\n```\n\n1. 리액트 컴포넌트 성능을 측정할 수 있는 Profiler 컴포넌트를 사용한다.\n2. 각 테스트케이스에서 Normal, Memo를 각각 10_000번 씩 렌더링하며 렌더링 될때마다 renderTimes배열에 렌더링 시간을 저장한다.\n3. 그 후, 각 컴포넌트가 모두 렌더링 될 때 까지의 평균 시간을 계산한다.\n\n## 결과\n\n1. 제일 첫 번째 렌더링\n\n![](./assets/first-rendering.png)\n\n2. 리렌더링\n\n![](./assets/re-rendering.png)\n\n첫 번째 렌더링은 useMemo를 적용하지 않은 Normal컴포넌트의 렌더링 속도가 더 빨랐다. 리렌더링은 level이 커질수록 useMemo를 적용한 Memo 컴포넌트의 렌더링 속도가 더 빨랐다.ㅠ\n\n## 결론\n\n- 데이터를 계산하는데 드는 비용이 소프트웨어 성능에 영향을 줄 정도로 크지 않다면 useMemo를 사용하는 것이 오히려 오버헤드일 수 있다.\n- useMemo는 함수의 연산량이 많거나, 다루는 데이터가 클 경우 활용을 고려해볼 수 있다.\n- `console.time`, `console.timeEnd`를 사용해 함수의 실행시간을 측정하고 1ms 정도 되는 경우 useMemo사용을 고려해볼 수 있다.(공식문서에서 이 내용을 확인할 수 있다)\n\n## 참고자료\n\n- https://medium.com/swlh/should-you-use-usememo-in-react-a-benchmarked-analysis-159faf6609b7\n- https://ko.react.dev/reference/react/useMemo\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}